-- Multibit serial adder
-- Builds adder chain from individual full adders
-- Demonstrates fixed-size LIST for structural hardware generation

FUNCTION halfadder(a, b) {
    [
        o: a |> Bool/xor(that: b)
        c: a |> Bool/and(that: b)
    ]
}

FUNCTION fulladder(a, b, d) {
    BLOCK {
        ha1: halfadder(a: a, b: b)
        ha2: halfadder(a: ha1.o, b: d)
        [
            o: ha2.o
            c: ha1.c |> Bool/or(that: ha2.c)
        ]
    }
}

FUNCTION serialadder(a, b) {
    -- a, b are BITS { WIDTH, ... } (matches SystemVerilog input [WIDTH-1:0])
    BLOCK {
        -- Convert BITS to fixed-size LIST { WIDTH, Bool }
        a_bits: a |> Bits/to_bool_list()  -- LIST { WIDTH, Bool }
        b_bits: b |> Bits/to_bool_list()  -- LIST { WIDTH, Bool }

        -- Zip creates LIST { WIDTH, [Bool, Bool] } (pairs of bits)
        pairs: a_bits |> List/zip(with: b_bits)

        -- List/scan: thread carry through chain, keep all sums
        -- Transpiler unrolls to WIDTH full adders in chain
        result: pairs |> List/scan(
            init: False  -- Initial carry = False
            pair, carry_in: BLOCK {
                fa: fulladder(a: pair.first, b: pair.second, d: carry_in)
                [sum: fa.o, carry_out: fa.c]
            }
        )
        -- result: [sums: LIST { WIDTH, Bool }, final_carry: Bool]

        -- Build output BITS: concatenate sums + final carry
        [
            o: BITS { __, {
                result.sums |> List/to_u_bits()       -- LIST { WIDTH, Bool } → BITS { WIDTH, ... }
                result.final_carry |> Bool/to_u_bit() -- Bool → BITS { 1, ... }
            }}
            -- Result: BITS { WIDTH+1, ... }
        ]
    }
}
