-- Multibit serial adder
-- Builds adder chain from individual full adders
-- Demonstrates fixed-size LIST for structural hardware generation

FUNCTION halfadder(a, b) {
    [
        o: a |> Bool/xor(that: b)
        c: a |> Bool/and(that: b)
    ]
}

FUNCTION fulladder(a, b, d) {
    BLOCK {
        ha1: halfadder(a: a, b: b)
        ha2: halfadder(a: ha1.o, b: d)
        [
            o: ha2.o
            c: ha1.c |> Bool/or(that: ha2.c)
        ]
    }
}

FUNCTION serialadder(a, b) {
    -- a, b are BITS { WIDTH, ... } (matches SystemVerilog input [WIDTH-1:0])
    BLOCK {
        -- Convert BITS to fixed-size LIST { WIDTH, Bool }
        a_bits: a |> Bits/to_bool_list()  -- LIST { WIDTH, Bool }
        b_bits: b |> Bits/to_bool_list()  -- LIST { WIDTH, Bool }

        -- Zip creates LIST { WIDTH, [Bool, Bool] } (pairs of bits)
        pairs: a_bits |> List/zip(with: b_bits)

        -- List/chain: thread carry through chain, collect all sums
        -- Transpiler unrolls to WIDTH full adders in chain
        result: pairs |> List/chain(
            item
            initial_state: False  -- Initial carry = False
            state
            iteration: BLOCK {
                fa: fulladder(a: item.first, b: item.second, d: state)
                [
                    output_value: fa.o
                    next_state: fa.c
                ]
            }
        )
        -- result: [values: LIST { WIDTH, Bool }, final_state: Bool]

        -- Build output BITS: concatenate sums + final carry
        [
            o: BITS { __, {
                result.values |> List/to_u_bits()       -- LIST { WIDTH, Bool } → BITS { WIDTH, ... }
                result.final_state |> Bool/to_u_bit()   -- Bool → BITS { 1, ... }
            }}
            -- Result: BITS { WIDTH+1, ... }
        ]
    }
}
