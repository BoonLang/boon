-- Accumulator with asynchronous reset
-- Adds input to accumulator on clock cycles
-- Demonstrates Bits/sum for accumulation pattern

-- Transpiler model:
--   - clk implicitly passed from hardware module context
--   - Bits/sum is stateful â†’ this function is actually a register
--   - width parameter â†’ module parameter: #(parameter WIDTH = 4)

FUNCTION cycleadder(width, rst, en, a) {
    BLOCK {
        default: BITS { width, 10u0 }

        -- Bundle control signals for pattern matching
        control_signals: [reset: rst, enabled: en]

        -- Pipeline = next-state logic (accumulator register)
        output: default
            |> Bits/set(control_signals |> WHEN {
                [reset: True, enabled: __] => default
                __ => SKIP
            })
            |> Bits/sum(delta: control_signals |> WHEN {
                [reset: False, enabled: True] => a
                __ => SKIP
            })

        [o: output]
    }
}

-- Alternative: Using LATEST with self-reference (equivalent to Bits/sum pattern above)
-- Commented out: For educational comparison only
--
-- FUNCTION cycleadder_latest(width, rst, en, a) {
--     BLOCK {
--         default: BITS { width, 10u0 }
--         control_signals: [reset: rst, enabled: en]
--
--         output: default |> LATEST output {
--             control_signals |> WHEN {
--                 [reset: True, enabled: __] => default
--                 [reset: False, enabled: True] => output |> Bits/add(a)
--                 __ => output  -- Hold
--             }
--         }
--
--         [o: output]
--     }
-- }
