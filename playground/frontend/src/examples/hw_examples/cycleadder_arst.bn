-- Accumulator with asynchronous reset
-- Adds input to accumulator on clock cycles
-- Demonstrates Bits/sum for accumulation pattern

-- Transpiler model:
--   - clk implicitly passed from hardware module context
--   - Bits/sum is stateful → this function is actually a register
--   - width parameter → module parameter: #(parameter WIDTH = 4)

FUNCTION cycleadder(width, rst, en, a) {
    BLOCK {
        default: BITS { width, 10u0 }

        -- Bundle control signals for pattern matching
        control_signals: [reset: rst, enabled: en]

        -- Pipeline = next-state logic (accumulator register)
        output: default
            |> Bits/set(control_signals |> WHEN {
                [reset: True, enabled: __] => default
                __ => SKIP
            })
            |> Bits/sum(delta: control_signals |> WHEN {
                [reset: False, enabled: True] => a
                __ => SKIP
            })

        [o: output]
    }
}
