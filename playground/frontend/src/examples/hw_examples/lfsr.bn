-- Linear feedback shift register
-- 8-bit LFSR with feedback taps at positions 7 and 3
-- Generates pseudo-random sequences
-- Why BITS: Shift operations are concise (1 line vs 8 lines with LIST)

-- Transpiler mapping:
--   LATEST { ... } → register with implicit clock domain
--   reset |> WHEN { True => ... } → async reset condition

FUNCTION lfsr(clk, reset) {
    -- clk, reset: Bool - define clock domain
    -- Returns: BITS { 8, ... } - current LFSR state

    out: LATEST {
        BITS { 8, 10u0 }  -- Reset value

        reset |> WHEN {
            True => BITS { 8, 10u0 }
            False => BLOCK {
                -- Linear feedback: NOT(out[7] XOR out[3])
                feedback: out |> Bits/get(index: 7) |> Bool/xor(
                    out |> Bits/get(index: 3)
                ) |> Bool/not()

                -- Shift right, feedback enters at MSB (position 7)
                out
                    |> Bits/shift_right(by: 1)
                    |> Bits/set(index: 7, value: feedback)
            }
        }
    }

    [out: out]
}

-- Alternative: Using LIST { Bool } (verbose, not recommended for shift operations)
-- Commented out: No corresponding .sv file (for transpiler development)
-- This demonstrates why BITS is preferred for bit manipulation
--
-- FUNCTION lfsr_list_verbose(clk_event, reset_event) {
--     out: LATEST {
--         LIST { False, False, False, False, False, False, False, False }
--
--         reset_event |> WHEN {
--             Rising => LIST { False, False, False, False, False, False, False, False }
--             __ => SKIP
--         }
--
--         clk_event |> WHEN {
--             Rising => BLOCK {
--                 feedback: out |> List/get(index: 7) |> Bool/xor(
--                     out |> List/get(index: 3)
--                 ) |> Bool/not()
--
--                 -- Manual shift reconstruction (verbose - 8 lines!)
--                 LIST {
--                     out |> List/get(index: 6)
--                     out |> List/get(index: 5)
--                     out |> List/get(index: 4)
--                     out |> List/get(index: 3)
--                     out |> List/get(index: 2)
--                     out |> List/get(index: 1)
--                     out |> List/get(index: 0)
--                     feedback
--                 }
--             }
--             __ => SKIP
--         }
--     }
--
--     [out: out]
-- }
