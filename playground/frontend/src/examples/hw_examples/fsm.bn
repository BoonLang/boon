-- Finite State Machine
-- 4-state FSM with input-dependent transitions
-- Boon's WHEN models state transitions naturally

-- State encoding using tags
-- A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11

-- Transpiler mapping:
--   LATEST { ... } → sequential state register
--   Pattern matching outside LATEST → combinational logic

FUNCTION fsm(clk, rst, a) {
    BLOCK {
        -- clk, rst: Bool - clock domain
        -- a: Bool - input signal

        -- Sequential state register
        state: LATEST {
            B  -- Reset state

            rst |> WHEN {
                True => B
                False => state |> WHEN {
                    A => C                              -- A -> C
                    B => D                              -- B -> D
                    C => a |> WHEN { True => D, False => B }  -- C -> D or B
                    D => A                              -- D -> A
                }
            }
        }

        -- Combinational output logic
        b: state |> WHEN {
            A => False
            B => True
            C => a  -- Output depends on input in state C
            D => False
        }

        [b: b]
    }
}

-- Alternative: Explicit state encoding
-- Commented out: No corresponding .sv file (for transpiler development)
--
-- FUNCTION fsm_encoded(clk_event, rst_event, a) {
--     BLOCK {
--         state: LATEST {
--             LIST { False, True }  -- B = 2'b01
--
--             rst_event |> WHEN {
--                 Rising => LIST { False, True }
--                 __ => SKIP
--             }
--
--             clk_event |> WHEN {
--                 Rising => state |> WHEN {
--                     LIST { False, False } => LIST { True, False }   -- A -> C
--                     LIST { False, True } => LIST { True, True }     -- B -> D
--                     LIST { True, False } => a |> WHEN {
--                         True => LIST { True, True }                 -- C -> D
--                         False => LIST { False, True }               -- C -> B
--                     }
--                     LIST { True, True } => LIST { False, False }    -- D -> A
--                 }
--                 __ => SKIP
--             }
--         }
--
--         b: state |> WHEN {
--             LIST { False, False } => False  -- A
--             LIST { False, True } => True    -- B
--             LIST { True, False } => a       -- C: output depends on input
--             LIST { True, True } => False    -- D
--         }
--
--         [b: b]
--     }
-- }
