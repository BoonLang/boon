-- Finite State Machine
-- 4-state FSM with input-dependent transitions
-- Demonstrates state transitions with pattern matching

-- State encoding using tags
-- A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11

-- Transpiler model:
--   - Clock accessed via PASSED.clk (ambient context from hardware module)
--   - PASSED.clk: [] = impulse, SKIP = no impulse
--   - THEN triggers when PASSED.clk = [] (clock tick/impulse occurs)
--   - When PASSED.clk = SKIP, no update occurs (state holds previous value)
--   - LATEST allows controlled self-reference for state transitions
--   - Pattern matching models state transitions (case statement)

FUNCTION fsm(rst, a) {
    BLOCK {
        -- Sequential state register
        -- PASSED.clk accessed from ambient context (no parameter needed)
        -- THEN triggers on each [] impulse, providing edge-triggered behavior
        -- LATEST holds state between clock ticks
        -- FSMs use LATEST because next state depends on current state
        state: B |> LATEST state {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => B
                    False => state |> WHEN {
                        A => C                              -- A -> C
                        B => D                              -- B -> D
                        C => a |> WHILE { True => D, False => B }  -- C -> D or B
                        D => A                              -- D -> A
                    }
                }
            }
        }

        -- Combinational output logic
        b: state |> WHEN {
            A => False
            B => True
            C => a  -- Output depends on input in state C
            D => False
        }

        [b: b]
    }
}
