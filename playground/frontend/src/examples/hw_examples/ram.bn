-- Simple synchronous RAM
-- Parameterized address and data width
-- Asynchronous read, synchronous write

-- Transpiler model:
--   - clk implicitly passed from hardware module context
--   - MEMORY primitive handles stateful storage (no LATEST needed)
--   - Asynchronous read is combinational

FUNCTION ram(addr, wraddr, wrdata) {
    BLOCK {
        -- addr: Number (0-15) - read address
        -- wraddr: Number (0-15) - write address
        -- wrdata: Number - data to write

        -- Memory state: synchronous write on every clock cycle
        -- MEMORY is stateful by design (no LATEST wrapper needed)
        -- Initial: mem[i] = i
        mem: MEMORY { 16, 0 }
            |> Memory/initialize(i, data: i)
            |> Memory/write(address: wraddr, data: wrdata)

        -- Asynchronous read (combinational)
        data: mem |> Memory/read(address: addr)

        [data: data]
    }
}
