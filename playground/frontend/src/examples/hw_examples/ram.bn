-- Simple synchronous RAM
-- Parameterized address and data width
-- Asynchronous read, synchronous write

-- Transpiler model:
--   - clk implicitly passed from hardware module context
--   - MEMORY primitive handles stateful storage (no LATEST needed)
--   - Asynchronous read is combinational

FUNCTION ram(addr, wraddr, wrdata) {
    BLOCK {
        -- addr: Number (0-15) - read address
        -- wraddr: Number (0-15) - write address
        -- wrdata: Number - data to write

        -- Memory state: synchronous write on every clock cycle
        -- MEMORY is stateful by design (no LATEST wrapper needed)
        -- Initial: mem[i] = i
        mem: MEMORY { 16, 0 }
            |> Memory/initialize(i, data: i)
            |> Memory/write(address: wraddr, data: wrdata)

        -- Asynchronous read (combinational)
        data: mem |> Memory/read(address: addr)

        [data: data]
    }
}





-- Example: RAM with Write Enable
FUNCTION ram_with_we(addr, wraddr, wrdata, write_enable) {
    BLOCK {
        memory: MEMORY { 16, BITS { 8, 2u0 } }
            |> Memory/write_entry(entry: write_enable |> WHEN {
                True => [address: wraddr, data: wrdata]
                False => SKIP
            })

        data: memory |> Memory/read(address: addr)

        [data: data]
    }
}




-- Parameterized version
FUNCTION ram_param(awidth, dwidth, addr, wraddr, wrdata) {
    BLOCK {
        mem_size: 2 |> Number/pow(awidth)

        mem: MEMORY { mem_size, 0 }
            |> Memory/initialize(i, data: i)
            |> Memory/write(address: wraddr, data: wrdata)

        data: mem |> Memory/read(address: addr)

        [
            data: data
            awidth: awidth  -- Metadata for transpiler
            dwidth: dwidth
        ]
    }
}

-- Example usage
-- Commented out: No corresponding .sv file (for transpiler development)
--
-- FUNCTION example_ram_operations() {
--     BLOCK {
--         -- Create RAM instance
--         my_ram: ram(
--             addr: 5           -- Read from address 5
--             wraddr: 3         -- Write to address 3
--             wrdata: 42        -- Write value 42
--         )
--
--         -- Returns data at address 5, after writing 42 to address 3
--         my_ram.data
--     }
-- }
--
-- FUNCTION example_dual_port_ram() {
--     BLOCK {
--         -- Dual-port RAM: independent read and write ports
--         memory: MEMORY { 256, 0 }
--             |> Memory/write(address: wr_addr_a, data: wr_data_a)
--             |> Memory/write(address: wr_addr_b, data: wr_data_b)
--
--         data_a: memory |> Memory/read(address: rd_addr_a)
--         data_b: memory |> Memory/read(address: rd_addr_b)
--
--         [data_a: data_a, data_b: data_b]
--     }
-- }
