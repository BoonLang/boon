-- UART Receiver (8N1 - 8 data bits, No parity, 1 stop bit)
-- Receives bytes serially at configurable baud rate
--
-- Protocol: START(0) + DATA[0:7] + STOP(1) = 10 bits total
-- Idle line state: HIGH (1)
-- Start bit detection: Line goes LOW (1 â†’ 0 transition)
--
-- Sampling Strategy:
-- - Detect start bit (falling edge on serial line)
-- - Wait half baud period (sample at middle of bit)
-- - Sample 8 data bits at baud rate
-- - Check stop bit (should be 1)
-- - Output valid pulse with received byte
--
-- Pattern: CDC + FSM + Baud Generator + Shift Register
-- - CDC synchronizer for async serial_in (metastability protection)
-- - FSM controls receive state (idle/busy)
-- - Baud generator with half-period offset for sampling
-- - Shift register accumulates received bits
--
-- Translated from: super_counter_rust/hardware/src/uart_rx.v
--
-- Parameters:
--   clock_hz: System clock frequency in Hz
--   baud_rate: UART baud rate (bits per second)
--   divisor_width: Bit width for baud divider counter
--                  NOTE: Would be computed as $clog2(clock_hz/baud_rate) in future
--   serial_in: Serial input line (async, needs CDC synchronization)
-- Returns:
--   data: Received 8-bit byte (valid when valid=True)
--   valid: One-cycle pulse when byte successfully received

FUNCTION uart_rx(rst, serial_in, clock_hz, baud_rate, divisor_width) {
    BLOCK {
        divisor: clock_hz / baud_rate
        divisor_minus_1: divisor - 1
        divisor_half: divisor / 2  -- Half period for mid-bit sampling

        -- ========================================
        -- CDC Synchronizer (2-FF chain)
        -- ========================================
        -- Async serial_in crosses clock domain, needs synchronization
        -- See: CDC_PATTERN.md

        -- Stage 1: First register (may go metastable)
        serial_sync0: serial_in |> LATEST s0 {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => True   -- Idle high
                    False => serial_in
                }
            }
        }

        -- Stage 2: Second register (metastability resolved)
        serial_sync1: serial_sync0 |> LATEST s1 {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => True   -- Idle high
                    False => serial_sync0
                }
            }
        }

        -- Synchronized serial signal (safe to use)
        serial: serial_sync1

        -- ========================================
        -- FSM State (idle/receiving)
        -- ========================================

        busy: False |> LATEST busy {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => False
                    False => busy |> WHILE {
                        -- Idle: wait for start bit (serial goes low)
                        False => serial |> WHILE {
                            True => False    -- Still idle (line high)
                            False => True    -- Start bit detected! Begin receiving
                        }
                        -- Receiving: check if done
                        True => BLOCK {
                            baud_tick: baud_counter == BITS[divisor_width] { 10u0 }
                            last_bit: bit_idx == BITS[4] { 10u8 }  -- After 8 data bits

                            baud_tick |> Bool/and(last_bit) |> WHEN {
                                True => False   -- Done receiving, back to idle
                                False => True   -- Keep receiving
                            }
                        }
                    }
                }
            }
        }

        -- ========================================
        -- Baud Rate Counter
        -- ========================================
        -- Counts down from divisor-1 to 0
        -- Special: Initialized to divisor/2 on start bit (sample at mid-bit)

        baud_counter: BITS[divisor_width] { 10u0 } |> LATEST baud_cnt {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => BITS[divisor_width] { 10u0 }
                    False => busy |> WHILE {
                        -- Idle: reset counter, ready for start bit
                        False => serial |> WHILE {
                            True => BITS[divisor_width] { 10u0 }
                            -- Start bit detected: load half period (sample at middle)
                            False => divisor_half |> Bits/from_nat()
                        }
                        -- Receiving: count down
                        True => baud_cnt |> WHEN {
                            BITS[divisor_width] { 10u0 } => divisor_minus_1 |> Bits/from_nat()
                            __ => baud_cnt |> Bits/decrement()
                        }
                    }
                }
            }
        }

        baud_tick: baud_counter == BITS[divisor_width] { 10u0 }

        -- ========================================
        -- Bit Index Counter (0-8)
        -- ========================================
        -- Counts which bit we're sampling (0-7 for data, 8 for stop bit)

        bit_idx: BITS[4] { 10u0 } |> LATEST idx {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => BITS[4] { 10u0 }
                    False => busy |> WHILE {
                        -- Idle: reset index
                        False => BITS[4] { 10u0 }
                        -- Receiving: increment on baud tick
                        True => baud_tick |> WHILE {
                            True => idx |> Bits/increment()
                            False => idx
                        }
                    }
                }
            }
        }

        -- ========================================
        -- Shift Register (accumulates data bits)
        -- ========================================
        -- Samples serial line on each baud tick
        -- Stores bits in shift[bit_idx]

        shift: BITS[8] { 10u0 } |> LATEST shift_reg {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => BITS[8] { 10u0 }
                    False => BLOCK {
                        sampling_data: busy
                            |> Bool/and(baud_tick)
                            |> Bool/and(bit_idx < BITS[4] { 10u8 })

                        sampling_data |> WHEN {
                            True => BLOCK {
                                -- Sample serial bit into shift register
                                -- shift[bit_idx] â† serial
                                -- Implementation: Set or clear bit at position bit_idx

                                bit_value: serial |> WHEN {
                                    True => BITS[8] { 10u1 } |> Bits/shift_left(by: bit_idx |> Bits/to_nat())
                                    False => BITS[8] { 10u0 }
                                }

                                -- Clear bit at position, then OR with new value
                                mask: BITS[8] { 10u1 } |> Bits/shift_left(by: bit_idx |> Bits/to_nat())
                                cleared: shift_reg |> Bits/and(mask |> Bits/not())
                                cleared |> Bits/or(bit_value)
                            }
                            False => shift_reg
                        }
                    }
                }
            }
        }

        -- ========================================
        -- Output Data Register
        -- ========================================
        -- Latches received byte when stop bit is valid

        data_out: BITS[8] { 10u0 } |> LATEST data {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => BITS[8] { 10u0 }
                    False => BLOCK {
                        -- Check if we're at stop bit and it's valid
                        at_stop_bit: busy
                            |> Bool/and(baud_tick)
                            |> Bool/and(bit_idx == BITS[4] { 10u8 })
                        stop_bit_valid: serial  -- Stop bit should be 1

                        at_stop_bit |> Bool/and(stop_bit_valid) |> WHEN {
                            True => shift   -- Latch received data
                            False => data   -- Hold previous value
                        }
                    }
                }
            }
        }

        -- ========================================
        -- Valid Pulse (one-cycle when byte received)
        -- ========================================

        valid_out: False |> LATEST valid {
            PASSED.clk |> THEN {
                rst |> WHILE {
                    True => False
                    False => BLOCK {
                        -- Pulse valid for one cycle when stop bit is good
                        at_stop_bit: busy
                            |> Bool/and(baud_tick)
                            |> Bool/and(bit_idx == BITS[4] { 10u8 })
                        stop_bit_valid: serial

                        at_stop_bit |> Bool/and(stop_bit_valid)
                    }
                }
            }
        }

        [data: data_out, valid: valid_out]
    }
}
