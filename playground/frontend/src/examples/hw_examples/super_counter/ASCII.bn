-- ASCII Helper Module
-- Provides character constants and conversion functions for ASCII text processing
--
-- This module emerged from real-world hardware design patterns in:
-- - UART communication
-- - Protocol parsing (ack_parser)
-- - Text formatting (btn_message)
--
-- All functions are pure combinational logic (no state)

MODULE ASCII {
    -- ========================================
    -- Character Constants
    -- ========================================

    -- Control characters
    CHAR_NULL: BITS[8] { 16u00 }      -- '\0' NULL
    CHAR_LF: BITS[8] { 16u0A }        -- '\n' Line Feed
    CHAR_CR: BITS[8] { 16u0D }        -- '\r' Carriage Return
    CHAR_NEWLINE: BITS[8] { 16u0A }   -- Alias for LF

    -- Whitespace
    CHAR_SPACE: BITS[8] { 16u20 }     -- ' '  Space
    CHAR_TAB: BITS[8] { 16u09 }       -- '\t' Tab

    -- Digits
    CHAR_0: BITS[8] { 16u30 }         -- '0'
    CHAR_1: BITS[8] { 16u31 }         -- '1'
    CHAR_2: BITS[8] { 16u32 }         -- '2'
    CHAR_3: BITS[8] { 16u33 }         -- '3'
    CHAR_4: BITS[8] { 16u34 }         -- '4'
    CHAR_5: BITS[8] { 16u35 }         -- '5'
    CHAR_6: BITS[8] { 16u36 }         -- '6'
    CHAR_7: BITS[8] { 16u37 }         -- '7'
    CHAR_8: BITS[8] { 16u38 }         -- '8'
    CHAR_9: BITS[8] { 16u39 }         -- '9'

    -- Uppercase letters
    CHAR_A: BITS[8] { 16u41 }         -- 'A'
    CHAR_B: BITS[8] { 16u42 }         -- 'B'
    CHAR_C: BITS[8] { 16u43 }         -- 'C'
    CHAR_D: BITS[8] { 16u44 }         -- 'D'
    CHAR_E: BITS[8] { 16u45 }         -- 'E'
    CHAR_F: BITS[8] { 16u46 }         -- 'F'
    CHAR_G: BITS[8] { 16u47 }         -- 'G'
    CHAR_H: BITS[8] { 16u48 }         -- 'H'
    CHAR_I: BITS[8] { 16u49 }         -- 'I'
    CHAR_J: BITS[8] { 16u4A }         -- 'J'
    CHAR_K: BITS[8] { 16u4B }         -- 'K'
    CHAR_L: BITS[8] { 16u4C }         -- 'L'
    CHAR_M: BITS[8] { 16u4D }         -- 'M'
    CHAR_N: BITS[8] { 16u4E }         -- 'N'
    CHAR_O: BITS[8] { 16u4F }         -- 'O'
    CHAR_P: BITS[8] { 16u50 }         -- 'P'
    CHAR_Q: BITS[8] { 16u51 }         -- 'Q'
    CHAR_R: BITS[8] { 16u52 }         -- 'R'
    CHAR_S: BITS[8] { 16u53 }         -- 'S'
    CHAR_T: BITS[8] { 16u54 }         -- 'T'
    CHAR_U: BITS[8] { 16u55 }         -- 'U'
    CHAR_V: BITS[8] { 16u56 }         -- 'V'
    CHAR_W: BITS[8] { 16u57 }         -- 'W'
    CHAR_X: BITS[8] { 16u58 }         -- 'X'
    CHAR_Y: BITS[8] { 16u59 }         -- 'Y'
    CHAR_Z: BITS[8] { 16u5A }         -- 'Z'

    -- Lowercase letters
    CHAR_a: BITS[8] { 16u61 }         -- 'a'
    CHAR_b: BITS[8] { 16u62 }         -- 'b'
    CHAR_c: BITS[8] { 16u63 }         -- 'c'
    CHAR_d: BITS[8] { 16u64 }         -- 'd'
    CHAR_e: BITS[8] { 16u65 }         -- 'e'
    CHAR_f: BITS[8] { 16u66 }         -- 'f'
    CHAR_g: BITS[8] { 16u67 }         -- 'g'
    CHAR_h: BITS[8] { 16u68 }         -- 'h'
    CHAR_i: BITS[8] { 16u69 }         -- 'i'
    CHAR_j: BITS[8] { 16u6A }         -- 'j'
    CHAR_k: BITS[8] { 16u6B }         -- 'k'
    CHAR_l: BITS[8] { 16u6C }         -- 'l'
    CHAR_m: BITS[8] { 16u6D }         -- 'm'
    CHAR_n: BITS[8] { 16u6E }         -- 'n'
    CHAR_o: BITS[8] { 16u6F }         -- 'o'
    CHAR_p: BITS[8] { 16u70 }         -- 'p'
    CHAR_q: BITS[8] { 16u71 }         -- 'q'
    CHAR_r: BITS[8] { 16u72 }         -- 'r'
    CHAR_s: BITS[8] { 16u73 }         -- 's'
    CHAR_t: BITS[8] { 16u74 }         -- 't'
    CHAR_u: BITS[8] { 16u75 }         -- 'u'
    CHAR_v: BITS[8] { 16u76 }         -- 'v'
    CHAR_w: BITS[8] { 16u77 }         -- 'w'
    CHAR_x: BITS[8] { 16u78 }         -- 'x'
    CHAR_y: BITS[8] { 16u79 }         -- 'y'
    CHAR_z: BITS[8] { 16u7A }         -- 'z'

    -- ========================================
    -- Character Classification Functions
    -- ========================================

    -- Check if character is a decimal digit ('0'-'9')
    -- Returns: Bool
    -- Usage: data |> ASCII/is_digit()
    FUNCTION is_digit(char) {
        in_range: (char >= CHAR_0) |> Bool/and(char <= CHAR_9)
        in_range
    }

    -- Check if character is an uppercase letter ('A'-'Z')
    -- Returns: Bool
    FUNCTION is_uppercase(char) {
        in_range: (char >= CHAR_A) |> Bool/and(char <= CHAR_Z)
        in_range
    }

    -- Check if character is a lowercase letter ('a'-'z')
    -- Returns: Bool
    FUNCTION is_lowercase(char) {
        in_range: (char >= CHAR_a) |> Bool/and(char <= CHAR_z)
        in_range
    }

    -- Check if character is a letter ('A'-'Z' or 'a'-'z')
    -- Returns: Bool
    FUNCTION is_letter(char) {
        upper: char |> is_uppercase()
        lower: char |> is_lowercase()
        upper |> Bool/or(lower)
    }

    -- Check if character is alphanumeric ('0'-'9', 'A'-'Z', or 'a'-'z')
    -- Returns: Bool
    FUNCTION is_alphanumeric(char) {
        digit: char |> is_digit()
        letter: char |> is_letter()
        digit |> Bool/or(letter)
    }

    -- Check if character is whitespace (space, tab, newline, CR)
    -- Returns: Bool
    FUNCTION is_whitespace(char) {
        is_space: char == CHAR_SPACE
        is_tab: char == CHAR_TAB
        is_lf: char == CHAR_LF
        is_cr: char == CHAR_CR

        is_space |> Bool/or(is_tab) |> Bool/or(is_lf) |> Bool/or(is_cr)
    }

    -- ========================================
    -- Digit Conversion Functions
    -- ========================================

    -- Convert ASCII digit ('0'-'9') to numeric value (0-9)
    -- Input: BITS[8] character
    -- Returns: BITS[4] value (0-9)
    -- Usage:
    --   digit: ASCII/CHAR_5 |> ASCII/to_digit()  -- Returns 5
    --
    -- Note: Result is undefined if input is not a digit
    --       Use is_digit() to check first if needed
    FUNCTION to_digit(char) {
        char |> Bits/sub(CHAR_0) |> Bits/truncate(width: 4)
    }

    -- Convert ASCII digit to specific bit width
    -- Input: BITS[8] character
    -- Returns: BITS[width] value
    -- Usage:
    --   value: ASCII/CHAR_7 |> ASCII/to_digit_width(width: 32)  -- Returns BITS[32] { 10u7 }
    FUNCTION to_digit_width(char, width) {
        digit: char |> to_digit()
        digit |> Bits/zero_extend(width: width)
    }

    -- Convert numeric value (0-9) to ASCII digit ('0'-'9')
    -- Input: BITS[4] value (0-9)
    -- Returns: BITS[8] ASCII character
    -- Usage:
    --   char: BITS[4] { 10u5 } |> ASCII/from_digit()  -- Returns '5'
    --
    -- Note: Only lower 4 bits are used; values > 9 wrap around
    FUNCTION from_digit(value) {
        digit: value |> Bits/truncate(width: 4)  -- Ensure 4 bits

        digit |> WHEN {
            BITS[4] { 10u0 } => CHAR_0
            BITS[4] { 10u1 } => CHAR_1
            BITS[4] { 10u2 } => CHAR_2
            BITS[4] { 10u3 } => CHAR_3
            BITS[4] { 10u4 } => CHAR_4
            BITS[4] { 10u5 } => CHAR_5
            BITS[4] { 10u6 } => CHAR_6
            BITS[4] { 10u7 } => CHAR_7
            BITS[4] { 10u8 } => CHAR_8
            BITS[4] { 10u9 } => CHAR_9
            -- Values 10-15: undefined behavior
            __ => CHAR_0  -- Default to '0'
        }
    }

    -- ========================================
    -- Case Conversion Functions
    -- ========================================

    -- Convert uppercase letter to lowercase
    -- Input: BITS[8] character
    -- Returns: BITS[8] character (lowercase if input was uppercase, unchanged otherwise)
    -- Usage:
    --   lower: ASCII/CHAR_A |> ASCII/to_lower()  -- Returns 'a'
    FUNCTION to_lower(char) {
        char |> is_uppercase() |> WHEN {
            True => BLOCK {
                -- Add 32 (0x20) to convert upper to lower
                offset: BITS[8] { 16u20 }
                char |> Bits/add(offset)
            }
            False => char  -- Already lowercase or not a letter
        }
    }

    -- Convert lowercase letter to uppercase
    -- Input: BITS[8] character
    -- Returns: BITS[8] character (uppercase if input was lowercase, unchanged otherwise)
    -- Usage:
    --   upper: ASCII/CHAR_a |> ASCII/to_upper()  -- Returns 'A'
    FUNCTION to_upper(char) {
        char |> is_lowercase() |> WHEN {
            True => BLOCK {
                -- Subtract 32 (0x20) to convert lower to upper
                offset: BITS[8] { 16u20 }
                char |> Bits/sub(offset)
            }
            False => char  -- Already uppercase or not a letter
        }
    }

    -- ========================================
    -- Hexadecimal Conversion Functions
    -- ========================================

    -- Check if character is a hex digit ('0'-'9', 'A'-'F', 'a'-'f')
    -- Returns: Bool
    FUNCTION is_hex_digit(char) {
        is_dec: char |> is_digit()
        is_upper_hex: (char >= CHAR_A) |> Bool/and(char <= CHAR_F)
        is_lower_hex: (char >= CHAR_a) |> Bool/and(char <= CHAR_f)

        is_dec |> Bool/or(is_upper_hex) |> Bool/or(is_lower_hex)
    }

    -- Convert ASCII hex digit to numeric value (0-15)
    -- Input: BITS[8] character ('0'-'9', 'A'-'F', 'a'-'f')
    -- Returns: BITS[4] value (0-15)
    -- Note: Result undefined if input is not a hex digit
    FUNCTION to_hex_digit(char) {
        char |> WHEN {
            -- Decimal digits
            CHAR_0 => BITS[4] { 10u0 }
            CHAR_1 => BITS[4] { 10u1 }
            CHAR_2 => BITS[4] { 10u2 }
            CHAR_3 => BITS[4] { 10u3 }
            CHAR_4 => BITS[4] { 10u4 }
            CHAR_5 => BITS[4] { 10u5 }
            CHAR_6 => BITS[4] { 10u6 }
            CHAR_7 => BITS[4] { 10u7 }
            CHAR_8 => BITS[4] { 10u8 }
            CHAR_9 => BITS[4] { 10u9 }

            -- Uppercase hex
            CHAR_A => BITS[4] { 10u10 }
            CHAR_B => BITS[4] { 10u11 }
            CHAR_C => BITS[4] { 10u12 }
            CHAR_D => BITS[4] { 10u13 }
            CHAR_E => BITS[4] { 10u14 }
            CHAR_F => BITS[4] { 10u15 }

            -- Lowercase hex
            CHAR_a => BITS[4] { 10u10 }
            CHAR_b => BITS[4] { 10u11 }
            CHAR_c => BITS[4] { 10u12 }
            CHAR_d => BITS[4] { 10u13 }
            CHAR_e => BITS[4] { 10u14 }
            CHAR_f => BITS[4] { 10u15 }

            __ => BITS[4] { 10u0 }  -- Default
        }
    }

    -- Convert numeric value (0-15) to ASCII uppercase hex digit
    -- Input: BITS[4] value (0-15)
    -- Returns: BITS[8] character ('0'-'9', 'A'-'F')
    FUNCTION from_hex_digit(value) {
        digit: value |> Bits/truncate(width: 4)

        digit |> WHEN {
            BITS[4] { 10u0 }  => CHAR_0
            BITS[4] { 10u1 }  => CHAR_1
            BITS[4] { 10u2 }  => CHAR_2
            BITS[4] { 10u3 }  => CHAR_3
            BITS[4] { 10u4 }  => CHAR_4
            BITS[4] { 10u5 }  => CHAR_5
            BITS[4] { 10u6 }  => CHAR_6
            BITS[4] { 10u7 }  => CHAR_7
            BITS[4] { 10u8 }  => CHAR_8
            BITS[4] { 10u9 }  => CHAR_9
            BITS[4] { 10u10 } => CHAR_A
            BITS[4] { 10u11 } => CHAR_B
            BITS[4] { 10u12 } => CHAR_C
            BITS[4] { 10u13 } => CHAR_D
            BITS[4] { 10u14 } => CHAR_E
            BITS[4] { 10u15 } => CHAR_F
        }
    }
}
