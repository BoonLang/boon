-- Math Helper Module
-- Mathematical functions for hardware design
--
-- This module emerged from real-world hardware design patterns:
-- - Width calculations for counters (uart_tx, uart_rx)
-- - Parametric design with computed bit widths
-- - Power-of-2 alignment checking
--
-- All functions are compile-time constants (ideal for parameter calculation)

MODULE Math {
    -- ========================================
    -- Logarithm Functions
    -- ========================================

    -- Ceiling log base 2
    -- Returns the smallest N such that 2^N >= value
    --
    -- This is the hardware designer's most essential function!
    -- Use it to calculate the bit width needed to represent a value.
    --
    -- Examples:
    --   Math/clog2(1)   = 0  (2^0 = 1)
    --   Math/clog2(2)   = 1  (2^1 = 2)
    --   Math/clog2(3)   = 2  (2^2 = 4 >= 3)
    --   Math/clog2(4)   = 2  (2^2 = 4)
    --   Math/clog2(5)   = 3  (2^3 = 8 >= 5)
    --   Math/clog2(217) = 8  (2^8 = 256 >= 217)
    --
    -- Common use case - baud rate divisor width:
    --   divisor: clock_hz / baud_rate  -- e.g., 25_000_000 / 115_200 = 217
    --   divisor_width: Math/clog2(divisor)  -- Returns 8
    --   counter: BITS[divisor_width] { 10u0 }
    --
    -- SystemVerilog equivalent: $clog2(value)
    FUNCTION clog2(value) {
        value |> WHEN {
            0 => 0  -- Undefined mathematically, but return 0
            1 => 0  -- 2^0 = 1
            2 => 1  -- 2^1 = 2
            3 => 2  -- 2^2 = 4 >= 3
            4 => 2  -- 2^2 = 4
            5 => 3  -- 2^3 = 8 >= 5
            6 => 3
            7 => 3
            8 => 3  -- 2^3 = 8
            9 => 4  -- 2^4 = 16 >= 9
            10 => 4
            11 => 4
            12 => 4
            13 => 4
            14 => 4
            15 => 4
            16 => 4  -- 2^4 = 16
            17 => 5  -- 2^5 = 32 >= 17
            -- Continue pattern...
            __ => BLOCK {
                -- For values > 16, use iterative approach
                -- This is a placeholder - real implementation would need
                -- a more sophisticated algorithm or be evaluated at compile time
                --
                -- Implementation strategy:
                -- 1. Count leading zeros
                -- 2. Adjust based on whether value is power of 2
                --
                -- For now, provide common hardware design values:
                value |> WHEN {
                    -- Common counter values
                    32 => 5
                    64 => 6
                    128 => 7
                    256 => 8
                    512 => 9
                    1024 => 10
                    2048 => 11
                    4096 => 12
                    8192 => 13
                    16384 => 14
                    32768 => 15
                    65536 => 16

                    -- Common clock divisors for baud rates at 25 MHz
                    217 => 8    -- 115200 baud: 25000000/115200 = 217.01
                    434 => 9    -- 57600 baud
                    2604 => 12  -- 9600 baud

                    -- Common clock divisors at 50 MHz
                    434 => 9    -- 115200 baud: 50000000/115200 = 434.02
                    868 => 10   -- 57600 baud
                    5208 => 13  -- 9600 baud

                    -- Default: return 32 (max for most hardware designs)
                    __ => 32
                }
            }
        }
    }

    -- Floor log base 2
    -- Returns the largest N such that 2^N <= value
    --
    -- Examples:
    --   Math/log2(1) = 0  (2^0 = 1)
    --   Math/log2(2) = 1  (2^1 = 2)
    --   Math/log2(3) = 1  (2^1 = 2 <= 3)
    --   Math/log2(4) = 2  (2^2 = 4)
    --   Math/log2(7) = 2  (2^2 = 4 <= 7)
    FUNCTION log2(value) {
        value |> WHEN {
            0 => 0  -- Undefined
            1 => 0
            2 => 1
            3 => 1
            4 => 2
            5 => 2
            6 => 2
            7 => 2
            8 => 3
            9 => 3
            10 => 3
            11 => 3
            12 => 3
            13 => 3
            14 => 3
            15 => 3
            16 => 4
            __ => BLOCK {
                value |> WHEN {
                    32 => 5
                    64 => 6
                    128 => 7
                    256 => 8
                    512 => 9
                    1024 => 10
                    2048 => 11
                    4096 => 12
                    8192 => 13
                    16384 => 14
                    32768 => 15
                    65536 => 16
                    __ => 31
                }
            }
        }
    }

    -- ========================================
    -- Power-of-2 Functions
    -- ========================================

    -- Check if value is a power of 2
    -- Returns: Bool
    --
    -- Examples:
    --   Math/is_power_of_2(1)  = True   (2^0)
    --   Math/is_power_of_2(2)  = True   (2^1)
    --   Math/is_power_of_2(3)  = False
    --   Math/is_power_of_2(4)  = True   (2^2)
    --   Math/is_power_of_2(16) = True   (2^4)
    --
    -- Use case: Optimize division/modulo operations
    --   If divisor is power of 2, can use shift/mask instead
    FUNCTION is_power_of_2(value) {
        value |> WHEN {
            0 => False
            1 => True
            2 => True
            4 => True
            8 => True
            16 => True
            32 => True
            64 => True
            128 => True
            256 => True
            512 => True
            1024 => True
            2048 => True
            4096 => True
            8192 => True
            16384 => True
            32768 => True
            65536 => True
            __ => False  -- Conservative: assume not power of 2
        }
    }

    -- Round up to next power of 2
    -- Returns the smallest power of 2 that is >= value
    --
    -- Examples:
    --   Math/next_power_of_2(1)  = 1
    --   Math/next_power_of_2(3)  = 4
    --   Math/next_power_of_2(5)  = 8
    --   Math/next_power_of_2(16) = 16
    --   Math/next_power_of_2(17) = 32
    FUNCTION next_power_of_2(value) {
        value |> WHEN {
            0 => 1
            1 => 1
            2 => 2
            3 => 4
            4 => 4
            5 => 8
            6 => 8
            7 => 8
            8 => 8
            9 => 16
            10 => 16
            11 => 16
            12 => 16
            13 => 16
            14 => 16
            15 => 16
            16 => 16
            __ => BLOCK {
                value |> WHEN {
                    17 => 32
                    32 => 32
                    33 => 64
                    64 => 64
                    65 => 128
                    128 => 128
                    129 => 256
                    256 => 256
                    257 => 512
                    512 => 512
                    513 => 1024
                    1024 => 1024
                    1025 => 2048
                    2048 => 2048
                    2049 => 4096
                    4096 => 4096
                    4097 => 8192
                    8192 => 8192
                    8193 => 16384
                    16384 => 16384
                    16385 => 32768
                    32768 => 32768
                    32769 => 65536
                    65536 => 65536
                    __ => 65536  -- Max out at 2^16
                }
            }
        }
    }

    -- ========================================
    -- Min/Max Functions
    -- ========================================

    -- Return minimum of two values
    FUNCTION min(a, b) {
        (a < b) |> WHEN {
            True => a
            False => b
        }
    }

    -- Return maximum of two values
    FUNCTION max(a, b) {
        (a > b) |> WHEN {
            True => a
            False => b
        }
    }

    -- Clamp value to range [min_val, max_val]
    FUNCTION clamp(value, min_val, max_val) {
        clamped_min: value |> max(min_val)
        clamped_min |> min(max_val)
    }

    -- ========================================
    -- Division/Modulo Helpers
    -- ========================================

    -- Divide and round up (ceiling division)
    -- Returns ceil(dividend / divisor)
    --
    -- Example:
    --   Math/div_ceil(10, 3) = 4  (10/3 = 3.33... rounds up to 4)
    --   Math/div_ceil(12, 3) = 4  (12/3 = 4 exactly)
    --   Math/div_ceil(13, 3) = 5  (13/3 = 4.33... rounds up to 5)
    FUNCTION div_ceil(dividend, divisor) {
        quotient: dividend / divisor
        remainder: dividend % divisor

        remainder |> WHEN {
            0 => quotient           -- Exact division
            __ => quotient + 1      -- Round up
        }
    }

    -- ========================================
    -- Bit Manipulation Helpers
    -- ========================================

    -- Count number of bits needed to represent a range [0, max_value]
    -- This is just an alias for clog2 with clearer intent
    FUNCTION bits_for_range(max_value) {
        max_value |> clog2()
    }

    -- Count number of values representable with N bits
    -- Returns 2^N
    FUNCTION values_in_bits(num_bits) {
        num_bits |> WHEN {
            0 => 1
            1 => 2
            2 => 4
            3 => 8
            4 => 16
            5 => 32
            6 => 64
            7 => 128
            8 => 256
            9 => 512
            10 => 1024
            11 => 2048
            12 => 4096
            13 => 8192
            14 => 16384
            15 => 32768
            16 => 65536
            __ => 65536  -- Max
        }
    }

    -- ========================================
    -- Common Hardware Constants
    -- ========================================

    -- Common clock frequencies (in Hz)
    CLOCK_1MHZ: 1_000_000
    CLOCK_10MHZ: 10_000_000
    CLOCK_25MHZ: 25_000_000
    CLOCK_50MHZ: 50_000_000
    CLOCK_100MHZ: 100_000_000

    -- Common baud rates
    BAUD_9600: 9600
    BAUD_19200: 19200
    BAUD_38400: 38400
    BAUD_57600: 57600
    BAUD_115200: 115200

    -- Time conversion helpers
    MS_PER_SECOND: 1000
    US_PER_SECOND: 1_000_000
    NS_PER_SECOND: 1_000_000_000
}
