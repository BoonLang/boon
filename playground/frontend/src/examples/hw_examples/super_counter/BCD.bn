-- BCD (Binary-Coded Decimal) Helper Module
-- Operations on BCD digit arrays for decimal displays and counters
--
-- This module emerged from real-world hardware design patterns in btn_message:
-- - Decimal counter with BCD representation
-- - Variable-length number formatting (skip leading zeros)
-- - ASCII conversion for display
--
-- BCD Format:
-- - Each decimal digit stored as 4-bit value (0-9)
-- - Arrays stored little-endian: digits[0] = ones, digits[1] = tens, etc.
-- - Example: 42 = LIST { BITS[4]{10u2}, BITS[4]{10u4} }

MODULE BCD {
    -- ========================================
    -- BCD Arithmetic
    -- ========================================

    -- Increment BCD digit array by 1 with ripple carry
    -- Input: LIST[N] { BITS[4] } - BCD digits (little-endian)
    -- Output: LIST[N] { BITS[4] } - Incremented BCD digits
    --
    -- Example:
    --   input:  [9, 9, 0, 0, 0]  (99)
    --   output: [0, 0, 1, 0, 0]  (100)
    --
    -- Algorithm:
    --   1. Start with carry = True (adding 1)
    --   2. For each digit from LSB to MSB:
    --      - If carry: increment digit
    --      - If digit becomes 10: set to 0, propagate carry
    --      - Otherwise: clear carry, done
    --
    -- This eliminates 20+ lines of fold logic in hardware designs!
    FUNCTION increment(digits) {
        result: digits |> List/fold(
            init: [output: LIST { }, carry: True]
            digit, acc: BLOCK {
                new_state: acc.carry |> WHEN {
                    True => digit |> WHEN {
                        BITS[4] { 10u9 } => [
                            new_digit: BITS[4] { 10u0 }
                            carry: True
                        ]
                        __ => [
                            new_digit: digit |> Bits/increment()
                            carry: False
                        ]
                    }
                    False => [
                        new_digit: digit
                        carry: False
                    ]
                }

                [
                    output: acc.output |> List/append(new_state.new_digit)
                    carry: new_state.carry
                ]
            }
        )

        result.output
    }

    -- Decrement BCD digit array by 1 with ripple borrow
    -- Input: LIST[N] { BITS[4] } - BCD digits (little-endian)
    -- Output: LIST[N] { BITS[4] } - Decremented BCD digits
    --
    -- Example:
    --   input:  [0, 0, 1, 0, 0]  (100)
    --   output: [9, 9, 0, 0, 0]  (99)
    --
    -- Note: Underflow wraps around (0 becomes 99999... for N digits)
    FUNCTION decrement(digits) {
        result: digits |> List/fold(
            init: [output: LIST { }, borrow: True]
            digit, acc: BLOCK {
                new_state: acc.borrow |> WHEN {
                    True => digit |> WHEN {
                        BITS[4] { 10u0 } => [
                            new_digit: BITS[4] { 10u9 }
                            borrow: True
                        ]
                        __ => [
                            new_digit: digit |> Bits/decrement()
                            borrow: False
                        ]
                    }
                    False => [
                        new_digit: digit
                        borrow: False
                    ]
                }

                [
                    output: acc.output |> List/append(new_state.new_digit)
                    borrow: new_state.borrow
                ]
            }
        )

        result.output
    }

    -- Add two BCD digit arrays with ripple carry
    -- Input: Two LIST[N] { BITS[4] } arrays
    -- Output: LIST[N] { BITS[4] } (overflow wraps)
    --
    -- Example:
    --   a: [5, 2, 0, 0, 0]  (25)
    --   b: [7, 1, 0, 0, 0]  (17)
    --   result: [2, 4, 0, 0, 0]  (42)
    FUNCTION add(digits_a, digits_b) {
        result: digits_a |> List/fold_indexed(
            init: [output: LIST { }, carry: BITS[4] { 10u0 }]
            digit_a, idx, acc: BLOCK {
                digit_b: digits_b |> List/get(index: idx)

                -- Add three values: digit_a + digit_b + carry
                sum_bits: digit_a |> Bits/add(digit_b) |> Bits/add(acc.carry)
                sum: sum_bits |> Bits/zero_extend(width: 5)  -- Need 5 bits for sum up to 19

                -- BCD adjustment: if sum >= 10, subtract 10 and carry
                adjusted: sum |> WHEN {
                    -- Sum 0-9: no adjustment
                    __ => (sum >= BITS[5] { 10u10 }) |> WHEN {
                        True => [
                            digit: sum |> Bits/sub(BITS[5] { 10u10 }) |> Bits/truncate(width: 4)
                            carry: BITS[4] { 10u1 }
                        ]
                        False => [
                            digit: sum |> Bits/truncate(width: 4)
                            carry: BITS[4] { 10u0 }
                        ]
                    }
                }

                [
                    output: acc.output |> List/append(adjusted.digit)
                    carry: adjusted.carry
                ]
            }
        )

        result.output
    }

    -- ========================================
    -- Display Helpers
    -- ========================================

    -- Count significant digits (skip leading zeros)
    -- Input: LIST[N] { BITS[4] } - BCD digits (little-endian)
    -- Output: nat (1 to N) - Number of significant digits
    --
    -- Example:
    --   [2, 4, 0, 0, 0]  -> 2  (number is 42)
    --   [0, 0, 0, 0, 0]  -> 1  (show at least one digit: "0")
    --   [5, 6, 7, 8, 9]  -> 5  (number is 98765)
    --
    -- Use case: Variable-length message formatting
    --   "BTN 42\n" instead of "BTN 00042\n"
    --
    -- This eliminates nested WHEN blocks checking each digit!
    FUNCTION count_digits(digits) {
        num_digits: digits |> List/length()

        -- Check from MSB to LSB
        result: num_digits |> WHEN {
            5 => digits |> List/get(index: 4) |> WHEN {
                BITS[4] { 10u0 } => 4 |> WHEN {
                    __ => digits |> List/get(index: 3) |> WHEN {
                        BITS[4] { 10u0 } => 3 |> WHEN {
                            __ => digits |> List/get(index: 2) |> WHEN {
                                BITS[4] { 10u0 } => 2 |> WHEN {
                                    __ => digits |> List/get(index: 1) |> WHEN {
                                        BITS[4] { 10u0 } => 1
                                        __ => 2
                                    }
                                }
                                __ => 3
                            }
                        }
                        __ => 4
                    }
                }
                __ => 5
            }

            4 => digits |> List/get(index: 3) |> WHEN {
                BITS[4] { 10u0 } => 3 |> WHEN {
                    __ => digits |> List/get(index: 2) |> WHEN {
                        BITS[4] { 10u0 } => 2 |> WHEN {
                            __ => digits |> List/get(index: 1) |> WHEN {
                                BITS[4] { 10u0 } => 1
                                __ => 2
                            }
                        }
                        __ => 3
                    }
                }
                __ => 4
            }

            3 => digits |> List/get(index: 2) |> WHEN {
                BITS[4] { 10u0 } => 2 |> WHEN {
                    __ => digits |> List/get(index: 1) |> WHEN {
                        BITS[4] { 10u0 } => 1
                        __ => 2
                    }
                }
                __ => 3
            }

            2 => digits |> List/get(index: 1) |> WHEN {
                BITS[4] { 10u0 } => 1
                __ => 2
            }

            -- 1 or other: always show at least one digit
            __ => 1
        }

        result
    }

    -- ========================================
    -- Conversion Functions
    -- ========================================

    -- Convert binary to BCD (Double Dabble algorithm)
    -- Input: BITS[W] binary value
    -- Output: LIST[N] { BITS[4] } BCD digits
    --
    -- Example:
    --   binary: BITS[8] { 10u42 }
    --   output: [2, 4, 0]  (little-endian: 42)
    --
    -- Note: This is a simplified version for small values
    --       Full implementation would use shift-and-add-3 algorithm
    FUNCTION from_binary(value, num_digits) {
        -- For now, use iterative division by 10
        -- This creates a list of BCD digits
        result: num_digits |> WHEN {
            1 => LIST {
                value % 10 |> Bits/truncate(width: 4)
            }

            2 => BLOCK {
                digit_0: value % 10 |> Bits/truncate(width: 4)
                rest: value / 10
                digit_1: rest % 10 |> Bits/truncate(width: 4)

                LIST { digit_0, digit_1 }
            }

            3 => BLOCK {
                digit_0: value % 10 |> Bits/truncate(width: 4)
                rest_1: value / 10
                digit_1: rest_1 % 10 |> Bits/truncate(width: 4)
                rest_2: rest_1 / 10
                digit_2: rest_2 % 10 |> Bits/truncate(width: 4)

                LIST { digit_0, digit_1, digit_2 }
            }

            4 => BLOCK {
                digit_0: value % 10 |> Bits/truncate(width: 4)
                rest_1: value / 10
                digit_1: rest_1 % 10 |> Bits/truncate(width: 4)
                rest_2: rest_1 / 10
                digit_2: rest_2 % 10 |> Bits/truncate(width: 4)
                rest_3: rest_2 / 10
                digit_3: rest_3 % 10 |> Bits/truncate(width: 4)

                LIST { digit_0, digit_1, digit_2, digit_3 }
            }

            5 => BLOCK {
                digit_0: value % 10 |> Bits/truncate(width: 4)
                rest_1: value / 10
                digit_1: rest_1 % 10 |> Bits/truncate(width: 4)
                rest_2: rest_1 / 10
                digit_2: rest_2 % 10 |> Bits/truncate(width: 4)
                rest_3: rest_2 / 10
                digit_3: rest_3 % 10 |> Bits/truncate(width: 4)
                rest_4: rest_3 / 10
                digit_4: rest_4 % 10 |> Bits/truncate(width: 4)

                LIST { digit_0, digit_1, digit_2, digit_3, digit_4 }
            }

            -- Default: 5 digits
            __ => BLOCK {
                digit_0: value % 10 |> Bits/truncate(width: 4)
                rest_1: value / 10
                digit_1: rest_1 % 10 |> Bits/truncate(width: 4)
                rest_2: rest_1 / 10
                digit_2: rest_2 % 10 |> Bits/truncate(width: 4)
                rest_3: rest_2 / 10
                digit_3: rest_3 % 10 |> Bits/truncate(width: 4)
                rest_4: rest_3 / 10
                digit_4: rest_4 % 10 |> Bits/truncate(width: 4)

                LIST { digit_0, digit_1, digit_2, digit_3, digit_4 }
            }
        }

        result
    }

    -- Convert BCD to binary
    -- Input: LIST[N] { BITS[4] } BCD digits (little-endian)
    -- Output: BITS[W] binary value
    --
    -- Example:
    --   digits: [2, 4, 0, 0, 0]  (BCD for 42)
    --   output: BITS[16] { 10u42 }
    --
    -- Algorithm: Horner's method (reverse multiply-by-10-and-add)
    --   For [2, 4]: result = 4*10 + 2 = 42
    FUNCTION to_binary(digits, width) {
        -- Process digits from MSB to LSB (reverse order)
        num_digits: digits |> List/length()

        result: num_digits |> WHEN {
            1 => digits |> List/get(index: 0) |> Bits/zero_extend(width: width)

            2 => BLOCK {
                digit_1: digits |> List/get(index: 1) |> Bits/zero_extend(width: width)
                digit_0: digits |> List/get(index: 0) |> Bits/zero_extend(width: width)
                ten: BITS[width] { 10u10 }

                digit_1 |> Bits/multiply(ten) |> Bits/add(digit_0)
            }

            3 => BLOCK {
                digit_2: digits |> List/get(index: 2) |> Bits/zero_extend(width: width)
                digit_1: digits |> List/get(index: 1) |> Bits/zero_extend(width: width)
                digit_0: digits |> List/get(index: 0) |> Bits/zero_extend(width: width)
                ten: BITS[width] { 10u10 }

                temp: digit_2 |> Bits/multiply(ten) |> Bits/add(digit_1)
                temp |> Bits/multiply(ten) |> Bits/add(digit_0)
            }

            4 => BLOCK {
                digit_3: digits |> List/get(index: 3) |> Bits/zero_extend(width: width)
                digit_2: digits |> List/get(index: 2) |> Bits/zero_extend(width: width)
                digit_1: digits |> List/get(index: 1) |> Bits/zero_extend(width: width)
                digit_0: digits |> List/get(index: 0) |> Bits/zero_extend(width: width)
                ten: BITS[width] { 10u10 }

                temp_3: digit_3 |> Bits/multiply(ten) |> Bits/add(digit_2)
                temp_2: temp_3 |> Bits/multiply(ten) |> Bits/add(digit_1)
                temp_2 |> Bits/multiply(ten) |> Bits/add(digit_0)
            }

            5 => BLOCK {
                digit_4: digits |> List/get(index: 4) |> Bits/zero_extend(width: width)
                digit_3: digits |> List/get(index: 3) |> Bits/zero_extend(width: width)
                digit_2: digits |> List/get(index: 2) |> Bits/zero_extend(width: width)
                digit_1: digits |> List/get(index: 1) |> Bits/zero_extend(width: width)
                digit_0: digits |> List/get(index: 0) |> Bits/zero_extend(width: width)
                ten: BITS[width] { 10u10 }

                temp_4: digit_4 |> Bits/multiply(ten) |> Bits/add(digit_3)
                temp_3: temp_4 |> Bits/multiply(ten) |> Bits/add(digit_2)
                temp_2: temp_3 |> Bits/multiply(ten) |> Bits/add(digit_1)
                temp_2 |> Bits/multiply(ten) |> Bits/add(digit_0)
            }

            -- Default: treat as 5 digits
            __ => BLOCK {
                digit_4: digits |> List/get_or_default(index: 4, default: BITS[4] { 10u0 }) |> Bits/zero_extend(width: width)
                digit_3: digits |> List/get_or_default(index: 3, default: BITS[4] { 10u0 }) |> Bits/zero_extend(width: width)
                digit_2: digits |> List/get_or_default(index: 2, default: BITS[4] { 10u0 }) |> Bits/zero_extend(width: width)
                digit_1: digits |> List/get_or_default(index: 1, default: BITS[4] { 10u0 }) |> Bits/zero_extend(width: width)
                digit_0: digits |> List/get_or_default(index: 0, default: BITS[4] { 10u0 }) |> Bits/zero_extend(width: width)
                ten: BITS[width] { 10u10 }

                temp_4: digit_4 |> Bits/multiply(ten) |> Bits/add(digit_3)
                temp_3: temp_4 |> Bits/multiply(ten) |> Bits/add(digit_2)
                temp_2: temp_3 |> Bits/multiply(ten) |> Bits/add(digit_1)
                temp_2 |> Bits/multiply(ten) |> Bits/add(digit_0)
            }
        }

        result
    }

    -- ========================================
    -- Validation
    -- ========================================

    -- Check if a 4-bit value is a valid BCD digit (0-9)
    -- Returns: Bool
    FUNCTION is_valid_digit(digit) {
        digit |> WHEN {
            BITS[4] { 10u0 } => True
            BITS[4] { 10u1 } => True
            BITS[4] { 10u2 } => True
            BITS[4] { 10u3 } => True
            BITS[4] { 10u4 } => True
            BITS[4] { 10u5 } => True
            BITS[4] { 10u6 } => True
            BITS[4] { 10u7 } => True
            BITS[4] { 10u8 } => True
            BITS[4] { 10u9 } => True
            __ => False  -- Values 10-15 are invalid
        }
    }

    -- Check if all digits in array are valid BCD (0-9)
    -- Returns: Bool
    FUNCTION is_valid(digits) {
        -- Use fold to check all digits
        result: digits |> List/fold(
            init: True
            digit, acc: BLOCK {
                valid_digit: digit |> is_valid_digit()
                acc |> Bool/and(valid_digit)
            }
        )

        result
    }
}
