-- Generates Assets.bn from SVG icon files
-- THROW/CATCH error handling (similar to PASS/PASSED)
-- THROW skips pipeline until CATCH (mandatory)
-- CATCH returns values, not errors

icons_directory: TEXT { ./assets/icons }
output_file: TEXT { ./Generated/Assets.bn }

svg_files: Directory/entries(icons_directory)
    |> List/retain(item, if: item.extension = TEXT { svg })
    |> List/sort_by(item, key: item.path)

generation: svg_files
    |> List/map(old, new: icon_code(old))
    |> List/retain(result, if: result |> WHEN {
        ReadError[message] => BLOCK {
            logged: TEXT { Cannot read icon: {message} } |> Log/error()
            FALSE
        }
        EncodeError[message] => BLOCK {
            logged: TEXT { Cannot encode icon: {message} } |> Log/error()
            FALSE
        }
        __ => TRUE
    })
    |> Text/join_lines()
    |> WHEN { code => TEXT {
        -- Generated from {icons_directory}

        icon: [
            {code}
        ]

    } }
    |> File/write_text(path: output_file)
    |> WHEN {
        Ok => []
        error => THROW { error }
    }
    |> THEN { BLOCK {
        count: svg_files |> List/count()
        logged: TEXT { Included {count} icons } |> Log/info()
        Build/succeed()
    } }
    |> CATCH {
        WriteError[message] => BLOCK {
            logged: TEXT { FATAL: Cannot write {output_file}: {message} } |> Log/error()
            Build/fail()
        }
    }

-- Process single icon
-- No CATCH - errors propagate as TEXT | ReadError | EncodeError
FUNCTION icon_code(item) {
    item.path
        |> File/read_text()
        |> WHEN {
            Ok[text] => text
            error => THROW { error }
        }
        |> Url/encode()
        |> WHEN {
            Ok[encoded] => encoded
            error => THROW { error }
        }
        |> WHEN { encoded =>
            TEXT { {item.file_stem}: data:image/svg+xml;utf8,{encoded} }
        }
}
