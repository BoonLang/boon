-- FLUSH Error Handling Pattern
-- Technical Specification and Implementation Guide
-- Date: 2025-11-16
-- Status: Design Document

-- ============================================================================
-- TABLE OF CONTENTS
-- ============================================================================
-- 1. Introduction
-- 2. Core Mechanism
-- 3. Semantics and Behavior
-- 4. Dataflow Model
-- 5. Hardware/FPGA Implementation
-- 6. Parallel Processing
-- 7. Streaming/Continuous Processing
-- 8. Actor Model Implementation
-- 9. Type System Integration
-- 10. Examples and Patterns
-- 11. Guarantees and Properties
-- 12. Comparison with Alternatives

-- ============================================================================
-- 1. INTRODUCTION
-- ============================================================================

-- WHAT IS FLUSH?
-- FLUSH is a control flow operator for early exit from pipeline expressions.
-- It creates a hidden wrapper that propagates transparently through pipelines.

-- WHY FLUSH?
-- - Fail-fast error handling without special collection functions
-- - Hardware-friendly (standard pipeline flush pattern)
-- - Actor-friendly (message passing with cancellation)
-- - Diagram-friendly (clear dataflow visualization)
-- - Type-safe (hidden from user namespace)

-- EXAMPLE:
example_usage: items
    |> List/map(item =>
        item |> process() |> WHEN {
            Ok[value] => value
            error => FLUSH { error }  -- Exit early, stop List/map
        }
    )
    |> next_operation()

-- ============================================================================
-- 2. CORE MECHANISM
-- ============================================================================

-- FLUSHED[value] - HIDDEN WRAPPER
-- When FLUSH { value } executes, it creates FLUSHED[value: value]
-- This is an INTERNAL compiler/runtime construct, NOT user-accessible

-- Properties:
-- - Hidden from user namespace (cannot clash with user types)
-- - Uppercase convention indicates internal/special status
-- - Contains wrapped value that can be unwrapped at boundaries
-- - Carries semantic meaning: "this value should propagate immediately"

-- Example (conceptual):
--   FLUSH { error }
--   => FLUSHED[value: error]  -- Internal representation

-- ============================================================================
-- 3. SEMANTICS AND BEHAVIOR
-- ============================================================================

-- FLUSH HAS THREE EFFECTS:

-- 1. LOCAL EXIT
--    Exits the current pipeline expression immediately
--    Remaining steps in that expression are skipped

pipeline_example: input
    |> step1()
    |> step2() |> WHEN {
        error => FLUSH { error }  -- Exits here
    }
    |> step3()  -- SKIPPED if FLUSH occurs

-- 2. WRAPPER CREATION
--    Creates FLUSHED[value] that propagates through pipeline

wrapper_example: operation() |> WHEN {
    error => FLUSH { error }  -- Returns: FLUSHED[error] internally
}

-- 3. TRANSPARENT PROPAGATION
--    FLUSHED[value] automatically bypasses functions until boundary

propagation_example: value
    |> function1()  -- Receives FLUSHED[T], bypasses, returns FLUSHED[T]
    |> function2()  -- Receives FLUSHED[T], bypasses, returns FLUSHED[T]
    |> function3()  -- Receives FLUSHED[T], bypasses, returns FLUSHED[T]

-- BOUNDARY UNWRAPPING
-- FLUSHED[value] unwraps to value at:
-- - Variable bindings
-- - Function returns
-- - BLOCK returns

boundary_example: items |> process()  -- Returns FLUSHED[error] internally
-- Variable binding unwraps:
-- boundary_example = error  (unwrapped)

-- ============================================================================
-- 4. DATAFLOW MODEL
-- ============================================================================

-- DATAFLOW WITH FLUSH

dataflow_visualization: svg_files
    |> List/map(old, new:
        old |> icon_code() |> WHEN {
            Ok[text] => text                    -- Normal flow: text
            error => FLUSH { error }             -- Flush flow: FLUSHED[error]
        }
    )
    -- List/map sees FLUSHED[error]
    -- Stops processing remaining items (fail-fast)
    -- Returns FLUSHED[error]

    |> Text/join_lines()
    -- Signature: [TEXT] -> TEXT
    -- Receives: FLUSHED[error]
    -- Runtime check: is FLUSHED? Yes
    -- Action: bypass processing, return FLUSHED[error]

    |> File/write_text(path: output_file)
    -- Signature: TEXT -> []
    -- Receives: FLUSHED[error]
    -- Runtime check: is FLUSHED? Yes
    -- Action: bypass processing, return FLUSHED[error]

    |> WHEN {
        Ok => []
        error => FLUSH { error }
    }
    -- Receives: FLUSHED[error]
    -- Runtime check: is FLUSHED? Yes
    -- Action: bypass WHEN, return FLUSHED[error]

-- Boundary: variable binding
-- dataflow_visualization = error  (FLUSHED unwrapped)

-- ============================================================================
-- 5. HARDWARE/FPGA IMPLEMENTATION
-- ============================================================================

-- HARDWARE REPRESENTATION
-- FLUSHED[value] = value + 1-bit FLUSHED flag

-- Memory layout:
-- [value_data (N bits) | FLUSHED_bit (1 bit)]

-- BYPASS LOGIC PER COMPONENT

-- Each pipeline component:
--   Input → Check FLUSHED bit
--            ↓
--        [Is FLUSHED set?]
--            ↓ Yes: Bypass MUX → Output = Input (passthrough)
--            ↓ No: Process MUX → Output = Process(Input)

-- EXAMPLE COMPONENT:
--
--   ┌─────────────────────────────────┐
--   │  Text/join_lines Component      │
--   ├─────────────────────────────────┤
--   │                                 │
--   │  Input ──→ FLUSHED? ──→ MUX   │
--   │              │           ↓↓    │
--   │              No         Yes    │
--   │              ↓          ↓      │
--   │           Process    Bypass    │
--   │              ↓          ↓      │
--   │              └──→ MUX ←─┘     │
--   │                   ↓            │
--   │                Output          │
--   └─────────────────────────────────┘

-- PIPELINE FLUSH SIGNAL
-- This is a STANDARD hardware pattern (like CPU pipeline flush)

-- Parallel processing lanes:
--   Lane1 → FLUSHED? → Set global FLUSH signal
--   Lane2 → Check signal → Stop if set
--   Lane3 → Check signal → Stop if set
--   Lane4 → Check signal → Stop if set

-- Control unit:
-- - Monitors FLUSHED bits from all lanes
-- - Broadcasts FLUSH signal on first detection
-- - Stops feeding new items to lanes
-- - Drains in-flight items
-- - Outputs first FLUSHED value (by input order)

-- FPGA RESOURCE COST
-- - 1 bit per value (FLUSHED flag)
-- - 1 MUX per component (2:1, bypass vs process)
-- - 1 global FLUSH signal (broadcast)
-- - Minimal overhead, standard practice

-- ============================================================================
-- 6. PARALLEL PROCESSING
-- ============================================================================

-- PARALLEL List/map SEMANTICS

-- Rule: "First FLUSHED in INPUT ORDER wins"

-- Example with 4 parallel threads:
--
-- Input:  [A, B, C, D, E, F, G, H]
--          ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
-- Thread1: A  E  (processing...)
-- Thread2: B  F  (processing...)
-- Thread3: C  G  (processing...)
-- Thread4: D  H  (processing...)
--
-- Results (as completed):
-- Thread1: A → ok, E → FLUSHED[error_E] (timestamp: T1)
-- Thread2: B → ok, F → ok (timestamp: T2)
-- Thread3: C → FLUSHED[error_C] (timestamp: T0)  ← First by time!
-- Thread4: D → ok, H → processing...
--
-- But: First by INPUT ORDER is C (index 2)
-- Action: Return FLUSHED[error_C], cancel threads 1,2,4

-- IMPLEMENTATION STRATEGY

-- Order-preserving parallel processing:
-- 1. Process items in parallel (non-deterministic timing)
-- 2. Collect results in ORDER BUFFER (maintains input order)
-- 3. Emit results in INPUT ORDER
-- 4. On first FLUSHED in order:
--    - Stop emitting
--    - Cancel remaining workers
--    - Return FLUSHED value

-- COORDINATION MECHANISM

-- Shared state:
-- - Atomic FLUSH flag (initially false)
-- - First FLUSHED value (protected by lock)
-- - Input order index (which item FLUSHed)

-- Worker behavior:
-- 1. Check FLUSH flag before starting new item
-- 2. If flag set, stop processing
-- 3. On FLUSHED result:
--    - Try to set FLUSH flag (atomic compare-and-swap)
--    - If first to set, store value and index
-- 4. Return result to coordinator

-- Coordinator behavior:
-- 1. Distribute work to workers
-- 2. Collect results in order buffer
-- 3. Emit results in order
-- 4. When FLUSHED encountered in order:
--    - Set global FLUSH flag
--    - Send cancel to all workers
--    - Return FLUSHED value

-- DETERMINISM GUARANTEE
-- Result is ALWAYS first FLUSHED in input order
-- Independent of thread timing or execution order
-- Parallel execution is optimization, semantics match sequential

-- TRADE-OFFS
-- ✅ Deterministic (input order preserved)
-- ✅ Parallel speedup (process multiple items simultaneously)
-- ⚠️ Some wasted work (out-of-order items may be discarded)
-- ⚠️ Coordination overhead (order buffer, FLUSH flag checks)
-- ✅ Overall: Acceptable for fail-fast semantics

-- ============================================================================
-- 7. STREAMING/CONTINUOUS PROCESSING
-- ============================================================================

-- STREAMING WITH FLUSH

-- Stream model:
--   Source → Map → Filter → Sink
--            ↓
--         FLUSH
--            ↓
--       Cancel upstream

-- FLUSH as STREAM CANCELLATION
-- FLUSHED[value] in streaming context = cancel signal

streaming_example: input_stream
    |> Stream/map(item =>
        item |> process() |> WHEN {
            error => FLUSH { error }  -- Cancel stream
        }
    )
    |> Stream/filter(predicate)
    |> Stream/collect()

-- Behavior:
-- 1. Stream processes items in order
-- 2. On FLUSHED[error]:
--    - Stop consuming from source
--    - Propagate FLUSHED downstream
--    - Send cancel signal upstream (backpressure)
--    - Close stream resources

-- BACKPRESSURE PROPAGATION
-- FLUSHED propagates both downstream (as value) and upstream (as signal)

-- Downstream: FLUSHED[error] flows through pipeline
-- Upstream: Cancel message to source (stop producing)

-- RESOURCE CLEANUP
-- On FLUSH:
-- - Close file handles
-- - Release network connections
-- - Free buffers
-- - Notify dependent streams

-- ADVANTAGES FOR STREAMING
-- ✅ Natural cancellation semantics
-- ✅ Immediate resource cleanup
-- ✅ Backpressure support
-- ✅ Composable (streams of streams)
-- ✅ No buffering waste (stop consuming immediately)

-- ============================================================================
-- 8. ACTOR MODEL IMPLEMENTATION
-- ============================================================================

-- ACTORS WITH FLUSH

-- Actor types:
-- - Source actors (produce items)
-- - Worker actors (process items)
-- - Coordinator actors (distribute work, collect results)
-- - Sink actors (consume results)

-- MESSAGE TYPES
-- - NormalValue[data]
-- - FLUSHED[value]  -- Hidden wrapper in message
-- - Cancel  -- Explicit cancel command
-- - Result[value]

-- WORKER ACTOR BEHAVIOR

worker_actor_pseudocode: ACTOR Worker {
    state: [processing, idle, cancelled]

    receive message:
        message |> WHEN {
            WorkItem[item] => BLOCK {
                checked: state |> WHEN {
                    cancelled => send_to_coordinator(Cancelled)
                    __ => process_item(item)
                }
                result: checked |> WHEN {
                    FLUSHED[value] => BLOCK {
                        sent: send_to_coordinator(FLUSHED[value])
                        state: cancelled  -- Update state
                    }
                    value => send_to_coordinator(Result[value])
                }
            }

            Cancel => BLOCK {
                state: cancelled
            }
        }
}

-- COORDINATOR ACTOR BEHAVIOR

coordinator_actor_pseudocode: ACTOR Coordinator {
    state: [
        items: [A, B, C, D, E]
        workers: [Worker1, Worker2, Worker3]
        results: []  -- Order buffer
        flush_detected: FALSE
    ]

    receive message:
        message |> WHEN {
            Start => distribute_work()

            Result[value] => BLOCK {
                updated_results: [...results, value]
                check_order_and_emit(updated_results)
            }

            FLUSHED[value] => BLOCK {
                state.flush_detected: TRUE
                broadcast_cancel_to_workers()
                emit_to_sink(FLUSHED[value])
            }
        }
}

-- ADVANTAGES FOR ACTORS
-- ✅ Standard message passing (FLUSHED is just a message type)
-- ✅ Clean cancellation (send Cancel message)
-- ✅ Supervisor trees (propagate FLUSH to supervisor)
-- ✅ Location transparency (local or distributed)
-- ✅ Fault tolerance (FLUSHED can represent failure)

-- ============================================================================
-- 9. TYPE SYSTEM INTEGRATION
-- ============================================================================

-- TYPE SIGNATURES WITH FLUSH

-- User perspective (FLUSHED is hidden):
function_signature: TEXT -> TEXT

-- With potential FLUSH:
function_with_flush: TEXT -> TEXT | Error
    -- If function contains FLUSH, return type includes error

-- Internal representation (compiler sees FLUSHED):
function_internal: TEXT -> TEXT | FLUSHED[Error]
    -- FLUSHED[Error] unwraps to Error at boundary

-- TYPE INFERENCE

-- Compiler infers FLUSH possibility from code:
inferred_example: FUNCTION process(x) {
    x |> operation() |> WHEN {
        error => FLUSH { error }  -- Compiler sees FLUSH
    }
}
-- Inferred type: T -> U | Error (FLUSHED unwrapped)

-- LIST/MAP TYPE SIGNATURE

-- Without FLUSH in callback:
List/map: ([A], (A -> B)) -> [B]

-- With FLUSH in callback:
List/map: ([A], (A -> B | E)) -> [B] | E
    -- Where E might be FLUSHED[error] internally
    -- Unwrapped to error at binding

-- BOUNDARY UNWRAPPING RULES

-- Variable binding:
result: operation()  -- Returns FLUSHED[error] internally
-- Unwrapped: result = error

-- Function return:
FUNCTION helper() {
    operation() |> WHEN {
        error => FLUSH { error }  -- Returns FLUSHED[error]
    }
}
-- Caller sees: Error (unwrapped)

-- BLOCK return:
BLOCK {
    logged: msg |> Log/error()
    operation() |> WHEN {
        error => FLUSH { error }  -- BLOCK returns FLUSHED[error]
    }
}
-- Unwrapped: Error

-- TYPE SAFETY
-- ✅ FLUSHED[T] cannot clash with user types (hidden)
-- ✅ Type inference tracks FLUSH possibility
-- ✅ Automatic unwrapping at boundaries
-- ✅ Type signatures remain clean (no explicit FLUSHED)

-- ============================================================================
-- 10. EXAMPLES AND PATTERNS
-- ============================================================================

-- PATTERN 1: FAIL-FAST COLLECTION PROCESSING

pattern_fail_fast: items
    |> List/map(item =>
        item |> risky_operation() |> WHEN {
            Ok[value] => value
            error => FLUSH { error }  -- Stop on first error
        }
    )
    |> next_operation()

-- PATTERN 2: NESTED PIPELINES

pattern_nested: outer_items
    |> List/map(outer =>
        inner_items
            |> List/map(inner =>
                inner |> process() |> WHEN {
                    error => FLUSH { error }  -- Exits to outer List/map
                }
            )
            |> combine_with(outer)
    )

-- PATTERN 3: MULTI-STEP PIPELINE WITH FLUSH

pattern_multi_step: input
    |> step1() |> WHEN {
        error => FLUSH { error }
        Ok[v1] => v1
    }
    |> step2() |> WHEN {
        error => FLUSH { error }
        Ok[v2] => v2
    }
    |> step3() |> WHEN {
        error => FLUSH { error }
        Ok[v3] => v3
    }

-- PATTERN 4: CONDITIONAL FLUSH

pattern_conditional: item
    |> validate() |> WHEN {
        Invalid[reason] => FLUSH { ValidationError[reason: reason] }
        Valid[data] => data
    }
    |> process()

-- PATTERN 5: FLUSH WITH TRANSFORMATION

pattern_transform: item
    |> operation() |> WHEN {
        DatabaseError[message] => FLUSH {
            UserFacingError[message: TEXT { Database unavailable }]
        }
        Ok[value] => value
    }

-- PATTERN 6: RESOURCE CLEANUP WITH FLUSH

pattern_cleanup: FUNCTION process_with_cleanup(resource) {
    resource
        |> acquire()
        |> WHEN {
            error => FLUSH { error }  -- Skip processing, still cleanup
            Ok[handle] => handle
        }
        |> use_resource()
        |> WHEN {
            error => BLOCK {
                cleanup: resource |> release()
                FLUSH { error }
            }
            Ok[result] => BLOCK {
                cleanup: resource |> release()
                result
            }
        }
}

-- ============================================================================
-- 11. GUARANTEES AND PROPERTIES
-- ============================================================================

-- DETERMINISM GUARANTEE
-- - Sequential execution: deterministic (obvious)
-- - Parallel execution: first FLUSHED in INPUT ORDER (deterministic)
-- - Streaming: first FLUSHED in STREAM ORDER (deterministic)

-- ORDERING GUARANTEE
-- - FLUSHED values maintain input order semantics
-- - Parallel processing preserves input order for result selection
-- - No race conditions affect which error is returned

-- RESOURCE SAFETY
-- - FLUSHED triggers immediate cleanup in streaming
-- - Functions can intercept FLUSHED for cleanup
-- - No resource leaks from early exit

-- TYPE SAFETY
-- - FLUSHED[T] is hidden, cannot clash with user types
-- - Type system tracks FLUSH possibility
-- - Automatic unwrapping prevents type confusion

-- COMPOSABILITY
-- - FLUSH works in nested contexts
-- - Functions don't need to know about FLUSHED
-- - Pipelines compose naturally

-- PERFORMANCE
-- - Fail-fast: stops processing immediately
-- - No unnecessary work after FLUSH
-- - Minimal overhead (1-bit check per value)
-- - Parallel speedup preserved (deterministic coordination)

-- CORRECTNESS
-- - FLUSH semantics match sequential execution
-- - Parallel optimization doesn't change semantics
-- - Streaming cancellation is immediate

-- ============================================================================
-- 12. COMPARISON WITH ALTERNATIVES
-- ============================================================================

-- ALTERNATIVE 1: THROW/CATCH (Exception-like)

-- throw_catch_example: items
--     |> List/map(item =>
--         item |> process() |> WHEN {
--             error => THROW { error }  -- Throw exception
--         }
--     )
--     |> CATCH { error => handle(error) }  -- Catch required

-- Problems:
-- ❌ Requires CATCH blocks (more boilerplate)
-- ❌ Non-local jump semantics (confusing)
-- ❌ Mandatory CATCH (compilation error if missing)
-- ❌ Less hardware-friendly (exception handling complex)

-- FLUSH advantages:
-- ✅ No CATCH needed (handle at variable)
-- ✅ Transparent propagation (simpler)
-- ✅ Hardware-friendly (bypass logic)

-- ALTERNATIVE 2: List/try_map (Special Function)

-- try_map_example: items
--     |> List/try_map(item =>
--         item |> process()  -- Returns T | Error
--     )
--     -- List/try_map stops on error

-- Problems:
-- ❌ Need special functions (try_map, try_fold, try_filter, etc.)
-- ❌ More functions to learn
-- ❌ Cannot use regular List/map for fail-fast

-- FLUSH advantages:
-- ✅ One List/map works for both (with or without FLUSH)
-- ✅ Less functions to maintain
-- ✅ More flexible (FLUSH anywhere in expression)

-- ALTERNATIVE 3: Result Monad (Explicit Chaining)

-- monad_example: items
--     |> List/map(item =>
--         item
--             |> process()
--             |> Result/and_then(v1 => step2(v1))
--             |> Result/and_then(v2 => step3(v2))
--     )

-- Problems:
-- ❌ Verbose (explicit and_then everywhere)
-- ❌ Callback nesting (harder to read)
-- ❌ Still need special List/try_map for fail-fast

-- FLUSH advantages:
-- ✅ Cleaner syntax (just |> WHEN)
-- ✅ No nesting (flat pipelines)
-- ✅ Works with regular List/map

-- ALTERNATIVE 4: Transparent Propagation Only (No FLUSH)

-- transparent_example: items
--     |> List/map(item =>
--         item |> process()  -- Returns T | Error
--     )
--     -- List/map returns [T | Error, T | Error, ...]

-- Problems:
-- ❌ No fail-fast (processes all items even after error)
-- ❌ Mixed success/error results (harder to handle)
-- ❌ Wasted processing

-- FLUSH advantages:
-- ✅ Fail-fast (stop on first error)
-- ✅ Clean result (not mixed list)
-- ✅ Efficient (no wasted work)

-- SUMMARY: WHY FLUSH?

-- ✅ Simple: No special functions, no CATCH blocks
-- ✅ Efficient: Fail-fast, minimal overhead
-- ✅ Hardware-friendly: Standard bypass pattern
-- ✅ Actor-friendly: Message passing with cancellation
-- ✅ Type-safe: Hidden wrapper, automatic unwrapping
-- ✅ Composable: Works in nested contexts
-- ✅ Deterministic: Input order preserved
-- ✅ Flexible: Use with any collection function

-- ============================================================================
-- END OF DOCUMENT
-- ============================================================================
