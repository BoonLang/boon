-- Generates Assets.bn from SVG icon files
-- WITH ERROR HANDLING using THROW/CATCH pattern

icons_directory: TEXT { ./assets/icons }
output_file: TEXT { ./Generated/Assets.bn }

svg_files: Directory/entries(icons_directory)
    |> List/retain(item, if: item.extension = TEXT { svg })
    |> List/sort_by(item, key: item.path)

generation: svg_files
    |> List/map(old, new: icon_code(old))
    |> collect_results()
    |> WHEN {
        [successes, errors] => BLOCK {
            -- Log statistics
            success_count: successes |> List/count()
            error_count: errors |> List/count()

            stats_logged: TEXT { Icons: {success_count} succeeded, {error_count} failed }
                |> Log/info()

            -- Log individual errors
            errors_logged: errors
                |> List/each(error, do: error |> Log/error())

            -- Generate module
            module: successes
                |> Text/join_lines()
                |> WHEN { code => TEXT {
                    -- Generated from {icons_directory}
                    -- Stats: {success_count} loaded, {error_count} failed

                    icon: [
                        {code}
                    ]

                } }

            -- Write to file
            module
                |> File/write_text(path: output_file)
                |> WHEN {
                    WriteError[message] => BLOCK {
                        logged: TEXT { FATAL: Cannot write {output_file}: {message} }
                            |> Log/error()
                        THROW { WriteError[message: message] }
                    }
                    __ => Build/success()
                }
        }
    }

-- Process single icon with error recovery
FUNCTION icon_code(item) {
    item.path
        |> File/read_text()
        |> WHEN {
            ReadError[message] => THROW { IconError[
                stage: TEXT { read }
                path: item.path
                reason: message
            ] }
            text => text
        }
        |> Url/encode()
        |> WHEN {
            EncodeError[message] => THROW { IconError[
                stage: TEXT { encode }
                path: item.path
                reason: message
            ] }
            encoded => encoded
        }
        |> WHEN { encoded =>
            TEXT { {item.file_stem}: data:image/svg+xml;utf8,{encoded} }
        }
        |> CATCH {
            IconError[stage, path, reason] => BLOCK {
                error_message: TEXT { {stage} failed for {path}: {reason} }
                logged: error_message |> Log/error()
                Error[message: error_message]
            }
        }
}

-- Collect successes and errors separately
FUNCTION collect_results(results) {
    results |> List/fold(
        init: [successes: LIST {}, errors: LIST {}]
        step: accumulate_result
    )
}

FUNCTION accumulate_result(acc, result) {
    result |> WHEN {
        Error[message] => [
            successes: acc.successes
            errors: acc.errors |> List/append(message)
        ]
        icon_line => [
            successes: acc.successes |> List/append(icon_line)
            errors: acc.errors
        ]
    }
}
