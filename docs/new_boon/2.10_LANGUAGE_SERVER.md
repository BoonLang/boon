## Chapter 2.10: Language Server

Boon provides an **in-browser Language Server** that runs entirely in WebAssembly. No external server required - it works offline and provides instant feedback.

---

### 2.10.1 Overview

**Core features:**

| Feature | Description |
|---------|-------------|
| **Inline types** | Show inferred types: `counter<Number>: 0` |
| **Diagnostics** | Parse and type errors inline in editor |
| **Hover info** | Full type details on hover |
| **Completions** | Variables in scope, function paths (future) |

**Design principles:**

| Principle | Rationale |
|-----------|-----------|
| **Fully in-browser** | Works offline, no server dependency |
| **WebWorker** | No UI blocking - analysis runs in background |
| **Reading-focused** | Priority on understanding code, not just writing |
| **Reuse parser** | Type checker added to existing `crates/boon/src/parser/` |

---

### 2.10.2 Architecture

```
┌──────────────────────┐     postMessage      ┌───────────────────────┐
│    CodeMirror 6      │ <── JSON msgs ──>   │    Boon LSP (WASM)    │
│    (Main Thread)     │                     │    (WebWorker)        │
└──────────────────────┘                     └───────────────────────┘
          │                                            │
          v                                            v
┌──────────────────────┐                     ┌───────────────────────┐
│ Decorations:         │                     │ Analysis Pipeline:    │
│ - Type annotations   │                     │ - Lexer               │
│ - Error underlines   │                     │ - Parser              │
│ - Hover tooltips     │                     │ - Scope Resolver      │
└──────────────────────┘                     │ - Type Checker        │
                                             └───────────────────────┘
```

**Why WebWorker:**
- Type inference can take 50-200ms for large files
- Main thread must stay responsive for typing
- WebWorker runs analysis in background, sends results when ready

**Message flow:**

1. User types in editor (CodeMirror)
2. After 300ms debounce, send code to WebWorker
3. WebWorker runs: parse → scope → type check
4. WebWorker sends back: type annotations + diagnostics
5. CodeMirror applies decorations

---

### 2.10.3 Message Protocol

```typescript
// Request: Main thread -> Worker
interface AnalysisRequest {
  id: number;
  type: "analyze" | "hover" | "complete";
  code: string;
  cursor?: { line: number; column: number };
}

// Response: Worker -> Main thread
interface AnalysisResponse {
  id: number;
  types: TypeAnnotation[];
  diagnostics: Diagnostic[];
  hover?: HoverInfo;
  completions?: Completion[];
}

interface TypeAnnotation {
  insertPosition: number;  // Byte offset after variable name
  displayType: string;     // e.g., "<Number>", "<List<Todo>>"
  fullType: string;        // For hover - full type if truncated
}

interface Diagnostic {
  span: { start: number; end: number };
  severity: "error" | "warning" | "info";
  message: string;
  code?: string;           // Error code for documentation lookup
}

interface HoverInfo {
  span: { start: number; end: number };
  type: string;
  documentation?: string;
}

interface Completion {
  label: string;
  kind: "variable" | "function" | "module" | "tag";
  detail?: string;
  insertText: string;
}
```

---

### 2.10.4 Inline Type Display

Types appear inline after variable names:

```boon
counter<Number>: 0 |> HOLD state { ... }
todos<List<Todo>>: LIST { }
filter<All | Active | Completed>: All
```

#### Display Format

| Type | Display | Example |
|------|---------|---------|
| Primitive | `<Number>`, `<Text>`, `<Bool>` | `x<Number>: 42` |
| Tag | `<TagName>` | `status<Active>` |
| Union | `<A \| B \| C>` | `filter<All \| Active \| Completed>` |
| TaggedObject | `<Tag[...]>` | `item<Todo[text: Text, done: Bool]>` |
| Object (short) | `<[field: T, ...]>` | `config<[name: Text, age: Number]>` |
| Object (long) | `<[N fields]>` | `config<[5 fields]>` |
| List | `<List<T>>` | `items<List<Number>>` |
| List with union | `<List<A \| B>>` | `items<List<Number \| Text>>` |
| Error union | `<T \| Error>` | `parsed<Number \| ParseError>` |
| Unknown | `<?>` | `x<?>` |

#### Truncation Rules

Long types are truncated inline with full type on hover:

| Condition | Display | Hover |
|-----------|---------|-------|
| Object > 2 fields | `<[5 fields]>` | Full `[name: Text, age: Number, ...]` |
| Union > 3 variants | `<A \| B \| ...>` | Full list of variants |
| Nested > 2 levels | `<List<...>>` | Full nested type |

#### CodeMirror Widget

```typescript
class TypeAnnotationWidget extends WidgetType {
  constructor(
    readonly displayType: string,
    readonly fullType: string
  ) { super() }

  toDOM(): HTMLElement {
    const span = document.createElement("span");
    span.className = "cm-boon-type-annotation";
    span.textContent = this.displayType;
    span.title = this.fullType;  // Tooltip on hover
    return span;
  }
}
```

#### Styling

```css
.cm-boon-type-annotation {
  color: #8b98b8;           /* Muted blue-gray */
  font-style: italic;
  font-size: 0.85em;
  opacity: 0.8;
  margin-left: 2px;
  user-select: none;
  pointer-events: none;
}

/* Brighter on active line */
.cm-activeLine .cm-boon-type-annotation {
  opacity: 1.0;
}

/* Error state for unknown types */
.cm-boon-type-annotation.unknown {
  color: #ff6b6b;
}
```

---

### 2.10.5 Diagnostics

Parse and type errors appear inline with underlines and gutter markers.

#### Error Types

| Category | Examples |
|----------|----------|
| Parse errors | Unexpected token, missing closing bracket |
| Type errors | Mismatch in HOLD, non-exhaustive WHEN |
| Scope errors | Undefined variable, unused variable warning |

#### CodeMirror Lint Integration

```typescript
import { linter, Diagnostic } from "@codemirror/lint";

const boonLinter = linter(async (view) => {
  const code = view.state.doc.toString();
  const response = await analyzeCode(code);

  return response.diagnostics.map(d => ({
    from: d.span.start,
    to: d.span.end,
    severity: d.severity,
    message: d.message,
  }));
});
```

#### Error Display

```
Error: Type mismatch in HOLD body
  Expected: Number (matching initial value)
  Found: Text

  ╭─[counter.bn:3:5]
  │
1 │ counter: 0 |> HOLD state {
  │          ─ initial value is Number
  │
3 │     button.event.press |> THEN { "clicked" }
  │                                  ^^^^^^^^^^ this is Text
  │
  ╰─ hint: HOLD body must produce the same type as the initial value
```

---

### 2.10.6 Implementation

#### File Structure

**Rust (in existing parser):**

```
crates/boon/src/parser/
├── mod.rs                  # Add: pub mod type_checker;
├── lexer.rs                # Existing - reuse
├── parser.rs               # Existing - reuse (AST with spans)
├── scope_resolver.rs       # Existing - reuse
├── type_checker/           # NEW
│   ├── mod.rs              # Entry: check_types() function
│   ├── types.rs            # Type enum (per §2.9)
│   ├── inference.rs        # Constraint generation from AST
│   ├── unification.rs      # Unification algorithm
│   └── builtins.rs         # Built-in function type signatures
```

**TypeScript (CodeMirror):**

```
playground/frontend/typescript/code_editor/
├── boon-lsp-worker.ts      # WebWorker: loads WASM, runs analysis
├── boon-lsp-client.ts      # Main thread: manages worker, debouncing
├── boon-type-annotations.ts # ViewPlugin for inline type display
├── code_editor.ts          # Updated: integrate LSP extensions
├── boon-language.ts        # Existing: syntax highlighting
```

#### WASM Export

```rust
// In crates/boon/src/lib.rs or platform/browser/
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn analyze_code(source_code: &str) -> String {
    let result = parser::analyze(source_code);
    serde_json::to_string(&result).unwrap_or_default()
}

// In parser/mod.rs
pub fn analyze(source: &str) -> AnalysisResult {
    let tokens = lexer::lex(source);
    let ast = parser::parse(&tokens);
    let scoped = scope_resolver::resolve(&ast);
    let (types, type_errors) = type_checker::check(&scoped);

    AnalysisResult {
        types: type_annotations_from(&types),
        diagnostics: collect_diagnostics(&ast, &type_errors),
    }
}
```

#### WebWorker Setup

```typescript
// boon-lsp-worker.ts
import init, { analyze_code } from '../wasm/boon.js';

let initialized = false;

self.onmessage = async (event: MessageEvent<AnalysisRequest>) => {
  if (!initialized) {
    await init();
    initialized = true;
  }

  const request = event.data;
  const resultJson = analyze_code(request.code);
  const result: AnalysisResponse = JSON.parse(resultJson);
  result.id = request.id;

  self.postMessage(result);
};
```

#### Debounced Updates

```typescript
// boon-lsp-client.ts
class BoonLspClient {
  private worker: Worker;
  private debounceTimer: number | null = null;
  private requestId = 0;

  constructor() {
    this.worker = new Worker('./boon-lsp-worker.ts', { type: 'module' });
    this.worker.onmessage = this.handleResponse.bind(this);
  }

  scheduleAnalysis(view: EditorView) {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    this.debounceTimer = window.setTimeout(() => {
      this.analyze(view);
    }, 300);  // 300ms debounce
  }

  private analyze(view: EditorView) {
    const code = view.state.doc.toString();
    this.worker.postMessage({
      id: ++this.requestId,
      type: "analyze",
      code,
    });
  }

  private handleResponse(event: MessageEvent<AnalysisResponse>) {
    // Dispatch to CodeMirror state
    this.view.dispatch({
      effects: setTypeAnnotations.of(event.data.types)
    });
  }
}
```

---

### 2.10.7 Future Features

| Feature | Priority | Description |
|---------|----------|-------------|
| **Completions** | Medium | Variables in scope, module paths, function names |
| **Go-to-definition** | Medium | Jump to variable definition |
| **Find references** | Low | Find all uses of a variable |
| **Rename symbol** | Low | Rename variable across all references |
| **Exhaustiveness hints** | High | Suggest missing WHEN/WHILE patterns |
| **Quick fixes** | Medium | Add missing pattern, fix type mismatch |

#### Exhaustiveness Hints

When WHEN/WHILE patterns are non-exhaustive:

```boon
filter |> WHEN {
    All => items
    Active => items |> List/filter(...)
    // Missing: Completed
}
```

**Diagnostic:**
```
Warning: Non-exhaustive pattern match
  Missing variants: Completed

  hint: Add pattern for 'Completed' or use wildcard '_'
```

**Quick fix:**
```boon
// Add missing pattern
    Completed => ...
```

---

### 2.10.8 Performance Considerations

| Aspect | Strategy |
|--------|----------|
| **Debounce** | 300ms after last keystroke before analysis |
| **Incremental** | Future: only re-analyze changed spans |
| **Caching** | Cache type info keyed by AST node hash |
| **Large files** | Warning if file > 1000 lines, suggest splitting |
| **Worker pool** | Future: multiple workers for parallel analysis |

---

### 2.10.9 Integration with Playground

The playground already uses CodeMirror with Boon syntax highlighting. Add LSP features by:

1. **Import extensions** in `code_editor.ts`:
   ```typescript
   import { boonTypeAnnotations } from "./boon-type-annotations";
   import { boonLinter } from "./boon-lsp-client";
   ```

2. **Add to extensions array**:
   ```typescript
   const extensions = [
     basicSetup,
     oneDark,
     boon(),
     boonTypeAnnotations(),  // NEW
     boonLinter,             // NEW
   ];
   ```

3. **Initialize LSP client** when editor mounts

---

