## Chapter 2.3: Message Passing

### 2.3.1 Message Format

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Message {
    pub source: NodeAddress,
    pub payload: Payload,
    pub version: u64,
    pub idempotency_key: u64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Payload {
    // Scalars
    Number(f64),
    Text(Arc<str>),   // Immutable, reference-counted sharing is safe (no reactive lifecycle issues)
    Tag(u32),         // Tag ID from intern table
    Bool(bool),       // True/False are conceptually tags, but runtime uses native bool for efficiency
    Unit,             // Boon literal: []; signal with no data (like Rust's `()`)

    // Containers (handles, not storage - see F3)
    ListHandle(SlotId),      // Reference to Bus node
    ObjectHandle(SlotId),    // Reference to Router node
    TaggedObject {           // e.g., Duration[seconds: 1], Oklch[lightness: 0.5]
        tag: u32,            // Tag ID (e.g., Duration, Oklch, Hidden, Todo)
        fields: SlotId,      // Reference to Router node containing fields
    },

    // Error wrapper (see §2.6 for FLUSH semantics)
    Flushed(Box<Payload>),

    // Deltas for efficient sync (see Section 3.4)
    ListDelta(ListDelta),
    ObjectDelta(ObjectDelta),
}
```

### 2.3.2 Node Kinds (Hardware Primitives)

| Boon Construct | Node Kind | Hardware Equivalent |
|----------------|-----------|---------------------|
| Constant | `Producer` | Tied signal |
| Variable | `Wire` | Named wire |
| Object | `Router` | Demultiplexer |
| List | `Bus` | Address decoder |
| LATEST | `Combiner` | Multiplexer |
| HOLD | `Register` | D flip-flop |
| THEN | `Transformer` | Combinational logic |
| WHEN | `PatternMux` | Pattern decoder |
| WHILE | `SwitchedWire` | Tri-state buffer |
| LINK | `IOPad` | I/O port |
| TEXT { {expr} } | `TextTemplate` | String formatter with reactive deps |
| Cross-domain | `TransportEdge` | I/O buffer with handshake |

**Note:** `BLOCK { bindings; output }` doesn't create a node - it's a compile-time construct that creates local bindings in the same scope (see Issue 19 for full model).

### 2.3.2.1 BLOCK Compilation Model

BLOCK is a lexical scope with local bindings, NOT a runtime node:

```rust
// BLOCK { x: 1, y: x + 1, x * y }
// Compiles to:
//   slot_x = Producer(1)
//   slot_y = Transformer(slot_x, |x| x + 1)
//   slot_output = Transformer([slot_x, slot_y], |x, y| x * y)
//   return slot_output

pub fn compile_block(block: &Block, ctx: &mut CompileContext) -> SlotId {
    // Same scope_id as parent (BLOCK doesn't create new scope)
    let scope = ctx.current_scope;

    for binding in &block.bindings {
        let slot = ctx.compile_expr(&binding.value);
        ctx.local_bindings.insert(binding.name.clone(), slot);
    }

    ctx.compile_expr(&block.output)
}
```

**FLUSH boundary:** When FLUSH hits variable assignment within BLOCK, it unwraps at that binding (per §2.6).

### 2.3.2.2 TransportEdge (Cross-Domain Routing)

Cross-domain edges become explicit `TransportEdge` nodes:

```rust
#[derive(Clone, Debug)]
pub struct TransportEdge {
    pub source_domain: Domain,
    pub target_domain: Domain,
    pub source_node: NodeAddress,
    pub target_node: NodeAddress,

    // Protocol state
    pub next_seq: u64,
    pub pending_acks: VecDeque<(u64, Message)>,  // (seq, msg) for retry
    pub last_ack_seq: u64,
}

impl TransportEdge {
    fn send(&mut self, msg: Message) -> TransportMessage {
        let seq = self.next_seq;
        self.next_seq += 1;
        self.pending_acks.push_back((seq, msg.clone()));

        TransportMessage {
            seq,
            idempotency_key: msg.idempotency_key,
            payload: msg.payload,
        }
    }

    fn on_ack(&mut self, ack_seq: u64) {
        self.pending_acks.retain(|(seq, _)| *seq > ack_seq);
        self.last_ack_seq = ack_seq;
    }

    fn resync_from(&self, from_seq: u64) -> Vec<TransportMessage> {
        // Replay messages since from_seq for reconnection
        self.pending_acks
            .iter()
            .filter(|(seq, _)| *seq >= from_seq)
            .map(|(seq, msg)| TransportMessage { seq: *seq, .. })
            .collect()
    }
}
```

**Benefits:**
- Explicit cross-domain edges (not implicit network magic)
- Transport logic is isolatable and testable
- Natural place for retry, buffering, reconnection
- Same pattern works for WebWorker and WebSocket

### 2.3.2.3 TextTemplate Node (Reactive TEXT Interpolation)

`TEXT { Value: {store.value} }` needs reactive updates when dependencies change:

```rust
pub struct TextTemplate {
    template: String,           // "Value: {0}"
    dependencies: Vec<SlotId>,  // [store.value slot]
    cached_output: Option<String>,
}

impl TextTemplate {
    fn on_dependency_change(&mut self, _slot: SlotId, _value: Payload) {
        // Re-render template with new values
        self.cached_output = None;  // Invalidate cache
        self.emit_rendered_text();
    }
}
```

**Mapping:** `TEXT { Value: {expr} }` compiles to TextTemplate with dependency on `expr`.

### 2.3.2.4 List/map External Dependency Tracking

**Problem:** `list_map_external_dep.bn` - List/map item subgraphs don't re-run when external dependencies change.

```rust
pub struct ListMapNode {
    pub source_list: SlotId,
    pub item_subgraphs: HashMap<ItemKey, ItemSubgraph>,
}

pub struct ItemSubgraph {
    pub root_slot: SlotId,
    pub external_deps: Vec<SlotId>,  // Deps outside the item scope
}

impl ListMapNode {
    fn on_external_dep_change(&mut self, dep: SlotId, event_loop: &mut EventLoop) {
        // Re-evaluate all items that depend on this external
        for (key, subgraph) in &self.item_subgraphs {
            if subgraph.external_deps.contains(&dep) {
                event_loop.mark_dirty(subgraph.root_slot);
            }
        }
    }
}
```

**Compile-time:** During List/map body compilation, track which SlotIds are external (not created within item scope).

### 2.3.2.5 Chained List/remove Semantics

**Problem:** `chained_list_remove_bug.bn` - chaining `List/remove` breaks when upstream triggers Replace.

```rust
pub struct ListRemoveNode {
    pub source: SlotId,                   // Upstream list
    pub site_id: SourceId,                // This remove site
    pub removed_keys: HashSet<ItemKey>,   // Keys removed BY THIS SITE
}

impl ListRemoveNode {
    fn on_upstream_delta(&mut self, delta: ListDelta) -> Option<ListDelta> {
        match delta {
            ListDelta::Insert { key, .. } => {
                if self.removed_keys.contains(&key) {
                    None  // Filter out: this key was removed downstream
                } else {
                    Some(delta)  // Pass through
                }
            }
            ListDelta::Remove { key } => {
                // Propagate removal, update our set
                self.removed_keys.remove(&key);
                Some(delta)
            }
            ListDelta::Replace { items } => {
                // On Replace, keep our removed_keys and filter
                let filtered: Vec<_> = items.into_iter()
                    .filter(|item| !self.removed_keys.contains(&item.key))
                    .collect();
                Some(ListDelta::Replace { items: filtered })
            }
            _ => Some(delta),
        }
    }
}
```

**Key insight:** Each remove-site maintains its OWN removed-keys set, applied to upstream deltas.

### 2.3.3 HOLD State Restrictions

**HOLD (Register) stores only scalar/simple values:**

| Allowed in HOLD | NOT Allowed |
|-----------------|-------------|
| Number | List / Bus |
| Text | Nested Objects |
| Tag | Objects containing List |
| Bool (True/False) | Recursive structures |
| Unit ([]) | TaggedObject with nested containers |
| Flat Object (fields are scalars only) | |

**Why:** Register is a D flip-flop - one storage cell for one value. Collections use Bus instead.

**Flat Object Runtime Model:**
Flat objects in HOLD (e.g., `[x: 0, y: 0]`) are stored efficiently:
- **Compile-time:** Desugars to Router with a Register for each field
- **Runtime:** Field updates modify existing Register nodes, no new Router allocations
- **Effect:** `[x: state.x + 1, y: state.y]` updates only the `x` Register node, `y` is preserved

This avoids per-tick object allocation. The "flat object" appears as one value in source code,
but compiles to a Router pointing to per-field Registers. This is why nested objects are NOT
allowed - they would require dynamically allocating Routers for each level.

**Pattern:**
```boon
-- CORRECT: scalar state in HOLD
counter: 0 |> HOLD state { trigger |> THEN { state + 1 } }
editing: None |> HOLD state { start |> THEN { Editing[id] } }

-- CORRECT: flat object in HOLD (all fields are scalars)
-- Compiles to: Router { x: Register(0), y: Register(0) }
position: [x: 0, y: 0] |> HOLD state { move |> THEN { [x: state.x + 1, y: state.y] } }

-- CORRECT: object CONTAINING HOLD nodes (each field has its own HOLD)
todo_item: [
    title: "Buy milk" |> HOLD state { edit |> THEN { new_title } },
    completed: False |> HOLD state { toggle |> THEN { not(state) } }
]

-- CORRECT: collection in LIST (not HOLD)
items: LIST {} |> List/append(item: new_item)

-- WRONG: List in HOLD
items: LIST {} |> HOLD state { ... }  -- NOT ALLOWED

-- WRONG: nested object in HOLD
item: [data: [nested: 1]] |> HOLD state { ... }  -- NOT ALLOWED (nested object)
```

**Distinction:** "Object containing HOLD nodes" ≠ "HOLD containing objects"
- Objects can have HOLD nodes for their scalar fields (each field has independent state)
- HOLD cannot store nested/complex objects (Register is a single storage cell)

### 2.3.4 Delta Streams for Containers (Scalability)

**Problem:** Materialized values don't scale for large lists with nested data.

```
500 users, one status change:
  Materialized: Diff O(500), copy nested data, send 5KB over WebSocket
  Delta stream: Emit delta, O(1), send 50 bytes
```

**Solution:** Containers emit delta events, not full values.

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ListDelta {
    Insert { key: ItemKey, index: u32, value: Payload },   // Add item at index
    Update { key: ItemKey, value: Payload },                // Replace item value
    FieldUpdate { key: ItemKey, field: FieldId, value: Payload }, // Nested field within item
    Remove { key: ItemKey },                                // Remove item by key
    Move { key: ItemKey, from_index: u32, to_index: u32 },  // Reorder item
    Replace { items: Vec<(ItemKey, Payload)> },             // Full list replacement
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ObjectDelta {
    FieldUpdate { field: FieldId, value: Payload },  // Set/update field value
    FieldRemove { field: FieldId },                  // Remove field from object
}
```

**How it works:**

```
User status changes:
  1. HOLD emits new status value
  2. Parent Router (user object) wraps in ObjectDelta::FieldUpdate
  3. Parent Bus (users list) wraps in ListDelta::FieldUpdate { key: user_123, field: "status", ... }
  4. Subscribers receive delta, update only affected part
  5. WebSocket: serialize just the delta
```

**Materialization points:**
- UI rendering (convert deltas to DOM ops)
- Snapshots (accumulate deltas into full state)
- WHEN pattern matching (may need full value)

**Benefits for backend:**
- WebSocket sync: O(delta_size) not O(list_size)
- Reconnect: send snapshot + replay deltas from checkpoint
- Nested lists: independent delta streams, no parent copying

### 2.3.5 Routing Table

Explicit routing instead of implicit subscriptions:

```rust
pub struct RoutingTable {
    // Static routes (from source code)
    static_routes: HashMap<NodeAddress, Vec<NodeAddress>>,
    // Dynamic routes (from WHILE, List changes)
    dynamic_routes: HashMap<NodeAddress, Vec<NodeAddress>>,
}
```

### 2.3.6 Message Storage Model

**Decision: Last-Value Cache per Node**

Each node stores its most recently emitted value. Subscribers read source nodes' cached values when triggered.

```rust
// Conceptual view - actual fields stored in NodeExtension (see §2.2.5)
pub struct ReactiveNode {
    pub generation: u32,
    pub version: u32,           // Incremented on each emit
    pub dirty: bool,
    pub kind: NodeKind,
    // Value storage in extension (heap-allocated):
    // pub current_value: Option<Payload>,  // Last emitted value (cache)
    // pub pending_deltas: Vec<Payload>,    // Accumulated deltas this tick
}
```

**Note:** For the actual 64-byte cache-aligned struct layout, see §2.2.5. Value storage (`current_value`, `pending_deltas`) lives in `NodeExtension` to keep the inline node compact.

**Why Last-Value Cache (not message queues):**

| Approach | Pros | Cons |
|----------|------|------|
| **Last-Value Cache** (chosen) | Simple, O(1) lookup, matches hardware registers | Can't track multiple in-flight messages |
| Message Queue per Edge | Handles fast producers | O(edges) memory, complex lifecycle |
| Central Message Store | Single location for all messages | HashMap lookup overhead, concurrent access issues |

**Last-Value Cache is correct for Boon because:**
1. **Reactive semantics:** Nodes care about "current value", not message history
2. **Tick-based processing:** Within a tick, only latest value matters
3. **Hardware model:** Registers hold ONE value (flip-flop semantics)
4. **Simplicity:** No queue management, no memory growth

**How Combiners (LATEST) Read Multiple Inputs:**

```rust
impl EventLoop {
    fn process_combiner(&mut self, combiner_slot: SlotId) {
        let combiner = self.arena.get(combiner_slot)?;
        let NodeKind::Combiner { inputs, .. } = &combiner.kind else { return };

        // Read current values from all input sources
        let values: Vec<Option<Payload>> = inputs.iter()
            .map(|input_slot| {
                self.arena.get(*input_slot)
                    .and_then(|node| node.current_value.clone())
            })
            .collect();

        // Emit combined value if all inputs have values
        if values.iter().all(|v| v.is_some()) {
            let combined = self.combine_values(values);
            self.emit(combiner_slot, combined);
        }
    }
}
```

**How Register (HOLD) Updates State:**

```rust
impl EventLoop {
    fn process_register(&mut self, register_slot: SlotId) {
        let register = self.arena.get_mut(register_slot)?;
        let NodeKind::Register { stored_value, body_input } = &mut register.kind else { return };

        // Body produced a new value - update stored state
        if let Some(body_slot) = body_input {
            if let Some(body_node) = self.arena.get(*body_slot) {
                if let Some(new_value) = &body_node.current_value {
                    *stored_value = Some(new_value.clone());
                    // Mark register as having new output
                    self.emit(register_slot, new_value.clone());
                }
            }
        }
    }
}
```

**Value Lifecycle:**

1. **Node emits:** Sets `current_value`, increments `version`, marks subscribers dirty
2. **Subscriber processes:** Reads source's `current_value` when scheduled
3. **Tick ends:** Values persist until next emit (they're cached, not queued)
4. **Node freed:** `current_value` is dropped with node

**Edge Cases:**

| Scenario | Behavior |
|----------|----------|
| Multiple emits per tick (scalars) | Only last value seen by subscribers |
| Multiple emits per tick (deltas) | All deltas delivered in order (see below) |
| Source freed before subscriber reads | Subscriber sees `None` (stale SlotId detection) |
| Subscriber reads before source emits | Returns `None` (no value yet) |
| Subscriber faster than source | Always reads latest available value |

**Scalars vs Deltas - Important Distinction:**

The last-value cache model applies to **scalar payloads** (Number, Text, Bool, etc.). For **delta payloads** (ListDelta, ObjectDelta), different semantics apply:

| Payload Type | Storage Model | Multiple Emits per Tick |
|--------------|---------------|-------------------------|
| Scalars (Number, Text, etc.) | Last-value cache | Only last value matters |
| Delta (ListDelta, ObjectDelta) | Per-tick accumulator | All deltas preserved in order |

**Why deltas need accumulation:**
```
// Wrong (if we used last-value for deltas):
List/append(A) → Insert(A)
List/append(B) → Insert(B)  // Overwrites Insert(A)!
Subscriber sees only Insert(B) → Missing item A!

// Correct (delta accumulation):
List/append(A) → Accumulator: [Insert(A)]
List/append(B) → Accumulator: [Insert(A), Insert(B)]
Subscriber processes both deltas → Sees items A and B
```

**Implementation:**
```rust
// Value storage in NodeExtension (see §2.2.5 for full struct layout)
impl EventLoop {
    fn emit(&mut self, slot: SlotId, payload: Payload) {
        let node = self.arena.get_mut(slot)?;
        let ext = node.extension.get_or_insert_with(Default::default);

        match &payload {
            Payload::ListDelta(_) | Payload::ObjectDelta(_) => {
                // Deltas: accumulate, don't replace
                ext.pending_deltas.push(payload);
            }
            _ => {
                // Scalars: last-value cache
                ext.current_value = Some(payload);
            }
        }

        node.version += 1;
        self.mark_subscribers_dirty(slot);
    }

    fn end_tick(&mut self) {
        // Clear delta accumulators after tick completes
        for node in self.arena.nodes_mut() {
            if let Some(ext) = &mut node.extension {
                ext.pending_deltas.clear();
            }
        }
    }
}
```

**Determinism:** Processing order (by NodeAddress sort) ensures same subscriber always sees same value/delta sequence across runs.

### 2.3.7 Routing Table Management

**Route Addition:**
Routes are added when nodes are created during compilation:

```rust
impl CompileContext {
    fn compile_wire(&mut self, source: SlotId, wire_name: &str) -> SlotId {
        let wire_slot = self.event_loop.arena.alloc();
        // ... initialize wire node ...

        // Add route: when source emits, wire receives
        self.event_loop.routing.add_route(source, wire_slot, Port::Output);

        wire_slot
    }
}
```

**Dynamic Routes (WHILE/WHEN switches):**

```rust
impl EventLoop {
    fn switch_while_arm(&mut self, while_slot: SlotId, new_arm: usize) {
        let while_node = self.arena.get_mut(while_slot)?;
        let NodeKind::SwitchedWire { current_arm, arm_outputs, .. } = &mut while_node.kind else { return };

        // 1. Finalize old arm scope (removes routes)
        if let Some(old_arm) = *current_arm {
            let old_output = arm_outputs[old_arm];
            self.finalize_scope(old_output);  // Recursively removes routes
        }

        // 2. Activate new arm (routes already exist from compilation)
        *current_arm = Some(new_arm);

        // 3. Mark new arm output as dirty (propagate current value)
        self.mark_dirty(arm_outputs[new_arm], Port::Output);
    }
}
```

**Dynamic Routes (List/map items):**

```rust
impl EventLoop {
    fn list_append(&mut self, list_slot: SlotId, initial: Payload) -> ItemKey {
        let list_node = self.arena.get_mut(list_slot)?;
        let NodeKind::Bus { items, alloc_site } = &mut list_node.kind else { return ItemKey(0) };

        // 1. Allocate new item key
        let key = alloc_site.allocate();

        // 2. Create item scope (compiles body with item_key as scope discriminator)
        let item_scope = self.current_scope.child(key);
        let item_slot = self.compile_list_item_body(list_slot, item_scope, initial);

        // 3. Routes were added during body compilation
        items.push((key, item_slot));

        // 4. Emit insert delta
        self.emit(list_slot, Payload::ListDelta(ListDelta::Insert { key, index: items.len() as u32 - 1, initial }));

        key
    }

    fn list_remove(&mut self, list_slot: SlotId, key: ItemKey) {
        let list_node = self.arena.get_mut(list_slot)?;
        let NodeKind::Bus { items, .. } = &mut list_node.kind else { return };

        // 1. Find and remove item
        if let Some(pos) = items.iter().position(|(k, _)| *k == key) {
            let (_, item_slot) = items.remove(pos);

            // 2. Finalize item scope (removes routes, frees nodes)
            self.finalize_scope(item_slot);

            // 3. Emit remove delta
            self.emit(list_slot, Payload::ListDelta(ListDelta::Remove { key }));
        }
    }
}
```

**Route Removal (Scope Finalization):**

```rust
impl EventLoop {
    fn finalize_scope(&mut self, root_slot: SlotId) {
        // Collect all slots in this scope (BFS from root)
        let scope_slots = self.collect_scope_slots(root_slot);

        for slot in scope_slots {
            // 1. Remove all routes FROM this node
            self.routing.remove_source(slot);

            // 2. Remove all routes TO this node
            self.routing.remove_target(slot);

            // 3. Unbind any LINK event listeners
            if let Some(node) = self.arena.get(slot) {
                if matches!(node.kind, NodeKind::IOPad { .. }) {
                    self.unbind_link(slot);
                }
            }

            // 4. Free the slot
            self.arena.free(slot);
        }
    }
}
```

**Files to modify:**
- `crates/boon/src/engine_v2/message.rs` - Message, Payload types
- `crates/boon/src/engine_v2/routing.rs` - RoutingTable
- `crates/boon/src/engine_v2/node.rs` - Node kind implementations
- `crates/boon/src/engine_v2/arena.rs` - Add current_value to ReactiveNode

---

