## Chapter 2.3: Message Passing

### 2.3.1 Message Format

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Message {
    pub source: NodeAddress,
    pub payload: Payload,
    pub version: u64,
    pub idempotency_key: u64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Payload {
    // Scalars
    Number(f64),
    Text(Arc<str>),   // Immutable, reference-counted sharing is safe (no reactive lifecycle issues)
    Tag(u32),         // Tag ID from intern table
    Bool(bool),       // True/False are conceptually tags, but runtime uses native bool for efficiency
    Unit,             // Boon literal: []; signal with no data (like Rust's `()`)

    // Containers (handles, not storage - see F3)
    ListHandle(SlotId),      // Reference to Bus node
    ObjectHandle(SlotId),    // Reference to Router node
    TaggedObject {           // e.g., Duration[seconds: 1], Oklch[lightness: 0.5]
        tag: u32,            // Tag ID (e.g., Duration, Oklch, Hidden, Todo)
        fields: SlotId,      // Reference to Router node containing fields
    },

    // Error wrapper (see §2.6 for FLUSH semantics)
    Flushed(Box<Payload>),

    // Deltas for efficient sync (see Section 3.4)
    ListDelta(ListDelta),
    ObjectDelta(ObjectDelta),
}
```

### 2.3.2 Node Kinds (Hardware Primitives)

| Boon Construct | Node Kind | Hardware Equivalent |
|----------------|-----------|---------------------|
| Constant | `Producer` | Tied signal |
| Variable | `Wire` | Named wire |
| Object | `Router` | Demultiplexer |
| List | `Bus` | Address decoder |
| LATEST | `Combiner` | Multiplexer |
| HOLD | `Register` | D flip-flop |
| THEN | `Transformer` | Combinational logic |
| WHEN | `PatternMux` | Pattern decoder |
| WHILE | `SwitchedWire` | Tri-state buffer |
| LINK | `IOPad` | I/O port |
| TEXT { {expr} } | `TextTemplate` | String formatter with reactive deps |
| Cross-domain | `TransportEdge` | I/O buffer with handshake |

**Note:** `BLOCK { bindings; output }` doesn't create a node - it's a compile-time construct that creates local bindings in the same scope (see Issue 19 for full model).

### 2.3.2.1 BLOCK Compilation Model

BLOCK is a lexical scope with local bindings, NOT a runtime node:

```rust
// BLOCK { x: 1, y: x + 1, x * y }
// Compiles to:
//   slot_x = Producer(1)
//   slot_y = Transformer(slot_x, |x| x + 1)
//   slot_output = Transformer([slot_x, slot_y], |x, y| x * y)
//   return slot_output

pub fn compile_block(block: &Block, ctx: &mut CompileContext) -> SlotId {
    // Same scope_id as parent (BLOCK doesn't create new scope)
    let scope = ctx.current_scope;

    for binding in &block.bindings {
        let slot = ctx.compile_expr(&binding.value);
        ctx.local_bindings.insert(binding.name.clone(), slot);
    }

    ctx.compile_expr(&block.output)
}
```

**FLUSH boundary:** When FLUSH hits variable assignment within BLOCK, it unwraps at that binding (per §2.6).

### 2.3.2.2 TransportEdge (Cross-Domain Routing)

Cross-domain edges become explicit `TransportEdge` nodes:

```rust
#[derive(Clone, Debug)]
pub struct TransportEdge {
    pub source_domain: Domain,
    pub target_domain: Domain,
    pub source_node: NodeAddress,
    pub target_node: NodeAddress,

    // Protocol state
    pub next_seq: u64,
    pub pending_acks: VecDeque<(u64, Message)>,  // (seq, msg) for retry
    pub last_ack_seq: u64,
}

impl TransportEdge {
    fn send(&mut self, msg: Message) -> TransportMessage {
        let seq = self.next_seq;
        self.next_seq += 1;
        self.pending_acks.push_back((seq, msg.clone()));

        TransportMessage {
            seq,
            idempotency_key: msg.idempotency_key,
            payload: msg.payload,
        }
    }

    fn on_ack(&mut self, ack_seq: u64) {
        self.pending_acks.retain(|(seq, _)| *seq > ack_seq);
        self.last_ack_seq = ack_seq;
    }

    fn resync_from(&self, from_seq: u64) -> Vec<TransportMessage> {
        // Replay messages since from_seq for reconnection
        self.pending_acks
            .iter()
            .filter(|(seq, _)| *seq >= from_seq)
            .map(|(seq, msg)| TransportMessage { seq: *seq, .. })
            .collect()
    }
}
```

**Benefits:**
- Explicit cross-domain edges (not implicit network magic)
- Transport logic is isolatable and testable
- Natural place for retry, buffering, reconnection
- Same pattern works for WebWorker and WebSocket

### 2.3.2.3 TextTemplate Node (Reactive TEXT Interpolation)

`TEXT { Value: {store.value} }` needs reactive updates when dependencies change:

```rust
pub struct TextTemplate {
    template: String,           // "Value: {0}"
    dependencies: Vec<SlotId>,  // [store.value slot]
    cached_output: Option<String>,
}

impl TextTemplate {
    fn on_dependency_change(&mut self, _slot: SlotId, _value: Payload) {
        // Re-render template with new values
        self.cached_output = None;  // Invalidate cache
        self.emit_rendered_text();
    }
}
```

**Mapping:** `TEXT { Value: {expr} }` compiles to TextTemplate with dependency on `expr`.

### 2.3.2.4 List/map External Dependency Tracking

**Problem:** `list_map_external_dep.bn` - List/map item subgraphs don't re-run when external dependencies change.

```rust
pub struct ListMapNode {
    pub source_list: SlotId,
    pub item_subgraphs: HashMap<ItemKey, ItemSubgraph>,
}

pub struct ItemSubgraph {
    pub root_slot: SlotId,
    pub external_deps: Vec<SlotId>,  // Deps outside the item scope
}

impl ListMapNode {
    fn on_external_dep_change(&mut self, dep: SlotId, event_loop: &mut EventLoop) {
        // Re-evaluate all items that depend on this external
        for (key, subgraph) in &self.item_subgraphs {
            if subgraph.external_deps.contains(&dep) {
                event_loop.mark_dirty(subgraph.root_slot);
            }
        }
    }
}
```

**Compile-time:** During List/map body compilation, track which SlotIds are external (not created within item scope).

### 2.3.2.5 Chained List/remove Semantics

**Problem:** `chained_list_remove_bug.bn` - chaining `List/remove` breaks when upstream triggers Replace.

```rust
pub struct ListRemoveNode {
    pub source: SlotId,                   // Upstream list
    pub site_id: SourceId,                // This remove site
    pub removed_keys: HashSet<ItemKey>,   // Keys removed BY THIS SITE
}

impl ListRemoveNode {
    fn on_upstream_delta(&mut self, delta: ListDelta) -> Option<ListDelta> {
        match delta {
            ListDelta::Insert { key, .. } => {
                if self.removed_keys.contains(&key) {
                    None  // Filter out: this key was removed downstream
                } else {
                    Some(delta)  // Pass through
                }
            }
            ListDelta::Remove { key } => {
                // Propagate removal, update our set
                self.removed_keys.remove(&key);
                Some(delta)
            }
            ListDelta::Replace { items } => {
                // On Replace, keep our removed_keys and filter
                let filtered: Vec<_> = items.into_iter()
                    .filter(|item| !self.removed_keys.contains(&item.key))
                    .collect();
                Some(ListDelta::Replace { items: filtered })
            }
            _ => Some(delta),
        }
    }
}
```

**Key insight:** Each remove-site maintains its OWN removed-keys set, applied to upstream deltas.

### 2.3.3 HOLD State Restrictions

**HOLD (Register) stores only scalar/simple values:**

| Allowed in HOLD | NOT Allowed |
|-----------------|-------------|
| Number | List / Bus |
| Text | Nested Objects |
| Tag | Objects containing List |
| Bool (True/False) | Recursive structures |
| Unit ([]) | TaggedObject with nested containers |
| Flat Object (fields are scalars only) | |

**Why:** Register is a D flip-flop - one storage cell for one value. Collections use Bus instead.

**Pattern:**
```boon
-- CORRECT: scalar state in HOLD
counter: 0 |> HOLD state { trigger |> THEN { state + 1 } }
editing: None |> HOLD state { start |> THEN { Editing[id] } }

-- CORRECT: flat object in HOLD (all fields are scalars)
position: [x: 0, y: 0] |> HOLD state { move |> THEN { [x: state.x + 1, y: state.y] } }

-- CORRECT: object CONTAINING HOLD nodes (each field has its own HOLD)
todo_item: [
    title: "Buy milk" |> HOLD state { edit |> THEN { new_title } },
    completed: False |> HOLD state { toggle |> THEN { not(state) } }
]

-- CORRECT: collection in LIST (not HOLD)
items: LIST {} |> List/append(item: new_item)

-- WRONG: List in HOLD
items: LIST {} |> HOLD state { ... }  -- NOT ALLOWED

-- WRONG: nested object in HOLD
item: [data: [nested: 1]] |> HOLD state { ... }  -- NOT ALLOWED (nested object)
```

**Distinction:** "Object containing HOLD nodes" ≠ "HOLD containing objects"
- Objects can have HOLD nodes for their scalar fields (each field has independent state)
- HOLD cannot store nested/complex objects (Register is a single storage cell)

### 2.3.4 Delta Streams for Containers (Scalability)

**Problem:** Materialized values don't scale for large lists with nested data.

```
500 users, one status change:
  Materialized: Diff O(500), copy nested data, send 5KB over WebSocket
  Delta stream: Emit delta, O(1), send 50 bytes
```

**Solution:** Containers emit delta events, not full values.

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ListDelta {
    Insert { key: ItemKey, index: u32, initial: Payload },
    Update { key: ItemKey, field: FieldId, value: Payload },
    Remove { key: ItemKey },
    Move { key: ItemKey, from_index: u32, to_index: u32 },
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ObjectDelta {
    FieldUpdate { field: FieldId, value: Payload },
}
```

**How it works:**

```
User status changes:
  1. HOLD emits new status value
  2. Parent Router (user object) wraps in ObjectDelta::FieldUpdate
  3. Parent Bus (users list) wraps in ListDelta::Update { key: user_123, field: "status", ... }
  4. Subscribers receive delta, update only affected part
  5. WebSocket: serialize just the delta
```

**Materialization points:**
- UI rendering (convert deltas to DOM ops)
- Snapshots (accumulate deltas into full state)
- WHEN pattern matching (may need full value)

**Benefits for backend:**
- WebSocket sync: O(delta_size) not O(list_size)
- Reconnect: send snapshot + replay deltas from checkpoint
- Nested lists: independent delta streams, no parent copying

### 2.3.5 Routing Table

Explicit routing instead of implicit subscriptions:

```rust
pub struct RoutingTable {
    // Static routes (from source code)
    static_routes: HashMap<NodeAddress, Vec<NodeAddress>>,
    // Dynamic routes (from WHILE, List changes)
    dynamic_routes: HashMap<NodeAddress, Vec<NodeAddress>>,
}
```

**Files to modify:**
- `crates/boon/src/platform/browser/engine.rs` - Message, Payload, RoutingTable types

---

