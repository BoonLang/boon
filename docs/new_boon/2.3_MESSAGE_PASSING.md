## Chapter 2.3: Message Passing

### 2.3.1 Message Format

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Message {
    pub source: NodeAddress,
    pub payload: Payload,
    pub version: u64,
    pub idempotency_key: u64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Payload {
    // Scalars
    Number(f64),
    Text(Arc<str>),   // Immutable, reference-counted sharing is safe (no reactive lifecycle issues)
    Tag(u32),         // Tag ID from intern table
    Bool(bool),       // True/False are conceptually tags, but runtime uses native bool for efficiency
    Unit,             // Boon literal: []; signal with no data (like Rust's `()`)

    // Containers (handles, not storage - see F3)
    ListHandle(SlotId),      // Reference to Bus node
    ObjectHandle(SlotId),    // Reference to Router node
    TaggedObject {           // e.g., Duration[seconds: 1], Oklch[lightness: 0.5]
        tag: u32,            // Tag ID (e.g., Duration, Oklch, Hidden, Todo)
        fields: SlotId,      // Reference to Router node containing fields
    },

    // Error wrapper (see §2.6 for FLUSH semantics)
    Flushed(Box<Payload>),

    // Deltas for efficient sync (see Section 3.4)
    ListDelta(ListDelta),
    ObjectDelta(ObjectDelta),
}
```

### 2.3.1.1 FieldId and Tag Interning

**FieldId and Tag are intern table indices:**

```rust
pub type FieldId = u32;  // Index into Arena.field_names
pub type TagId = u32;    // Index into Arena.tag_names

impl Arena {
    // Intern tables - mapping between IDs and human-readable names
    pub field_names: HashMap<FieldId, Arc<str>>,  // e.g., 0 → "status", 1 → "count"
    pub tag_names: HashMap<TagId, Arc<str>>,      // e.g., 0 → "True", 1 → "False", 2 → "Enter"

    // Reverse lookup for interning
    field_ids: HashMap<Arc<str>, FieldId>,
    tag_ids: HashMap<Arc<str>, TagId>,
    next_field_id: FieldId,
    next_tag_id: TagId,
}

impl Arena {
    /// Intern a field name, returning existing ID or allocating new one
    pub fn intern_field(&mut self, name: &str) -> FieldId {
        if let Some(&id) = self.field_ids.get(name) {
            return id;
        }
        let id = self.next_field_id;
        self.next_field_id += 1;
        let name: Arc<str> = name.into();
        self.field_names.insert(id, name.clone());
        self.field_ids.insert(name, id);
        id
    }

    /// Look up field name by ID (for JSON materialization, debugging)
    pub fn field_name(&self, id: FieldId) -> Option<&str> {
        self.field_names.get(&id).map(|s| s.as_ref())
    }

    // Similar methods for tag_names...
}
```

**Representation across layers:**

| Context | FieldId Representation | TagId Representation |
|---------|----------------------|---------------------|
| **Engine (runtime)** | `u32` index | `u32` index |
| **Protocol JSON** | String field name (human-readable) | String tag name |
| **CLI materialization** | String field name | String tag name |
| **Persistence/snapshot** | Intern tables serialized alongside GraphSnapshot |

**Persistence:** When serializing a GraphSnapshot, the intern tables (`field_names`, `tag_names`) are serialized alongside so that IDs can be resolved after restore. This ensures stable field/tag resolution across reloads.

### 2.3.2 Node Kinds (Hardware Primitives)

| Boon Construct | Node Kind | Hardware Equivalent |
|----------------|-----------|---------------------|
| Constant | `Producer` | Tied signal |
| Variable | `Wire` | Named wire |
| Object | `Router` | Demultiplexer |
| List | `Bus` | Address decoder |
| LATEST | `Combiner` | Multiplexer |
| HOLD | `Register` | D flip-flop |
| THEN | `Transformer` | Combinational logic |
| WHEN | `PatternMux` | Pattern decoder |
| WHILE | `SwitchedWire` | Tri-state buffer |
| LINK | `IOPad` | I/O port |
| TEXT { {expr} } | `TextTemplate` | String formatter with reactive deps |
| Cross-domain | `TransportEdge` | I/O buffer with handshake |

**Note:** `BLOCK { bindings; output }` doesn't create a node - it's a compile-time construct that creates local bindings in the same scope (see Issue 19 for full model).

### 2.3.2.1 BLOCK Compilation Model

BLOCK is a lexical scope with local bindings, NOT a runtime node:

```rust
// BLOCK { x: 1, y: x + 1, x * y }
// Compiles to:
//   slot_x = Producer(1)
//   slot_y = Transformer(slot_x, |x| x + 1)
//   slot_output = Transformer([slot_x, slot_y], |x, y| x * y)
//   return slot_output

pub fn compile_block(block: &Block, ctx: &mut CompileContext) -> SlotId {
    // Same scope_id as parent (BLOCK doesn't create new scope)
    let scope = ctx.current_scope;

    for binding in &block.bindings {
        let slot = ctx.compile_expr(&binding.value);
        ctx.local_bindings.insert(binding.name.clone(), slot);
    }

    ctx.compile_expr(&block.output)
}
```

**FLUSH boundary:** When FLUSH hits variable assignment within BLOCK, it unwraps at that binding (per §2.6).

### 2.3.2.2 TransportEdge (Cross-Domain Routing)

Cross-domain edges become explicit `TransportEdge` nodes:

```rust
#[derive(Clone, Debug)]
pub struct TransportEdge {
    pub source_domain: Domain,
    pub target_domain: Domain,
    pub source_node: NodeAddress,
    pub target_node: NodeAddress,

    // Protocol state
    pub next_seq: u64,
    pub pending_acks: VecDeque<(u64, Message)>,  // (seq, msg) for retry
    pub last_ack_seq: u64,
}

impl TransportEdge {
    fn send(&mut self, msg: Message) -> TransportMessage {
        let seq = self.next_seq;
        self.next_seq += 1;
        self.pending_acks.push_back((seq, msg.clone()));

        TransportMessage {
            seq,
            idempotency_key: msg.idempotency_key,
            payload: msg.payload,
        }
    }

    fn on_ack(&mut self, ack_seq: u64) {
        self.pending_acks.retain(|(seq, _)| *seq > ack_seq);
        self.last_ack_seq = ack_seq;
    }

    fn resync_from(&self, from_seq: u64) -> Vec<TransportMessage> {
        // Replay messages since from_seq for reconnection
        self.pending_acks
            .iter()
            .filter(|(seq, _)| *seq >= from_seq)
            .map(|(seq, msg)| TransportMessage { seq: *seq, .. })
            .collect()
    }
}
```

**Benefits:**
- Explicit cross-domain edges (not implicit network magic)
- Transport logic is isolatable and testable
- Natural place for retry, buffering, reconnection
- Same pattern works for WebWorker and WebSocket

### 2.3.2.3 TextTemplate Node (Reactive TEXT Interpolation)

`TEXT { Value: {store.value} }` needs reactive updates when dependencies change:

```rust
pub struct TextTemplate {
    template: String,           // "Value: {0}"
    dependencies: Vec<SlotId>,  // [store.value slot]
    cached_output: Option<String>,
}

impl TextTemplate {
    fn on_dependency_change(&mut self, _slot: SlotId, _value: Payload) {
        // Re-render template with new values
        self.cached_output = None;  // Invalidate cache
        self.emit_rendered_text();
    }
}
```

**Mapping:** `TEXT { Value: {expr} }` compiles to TextTemplate with dependency on `expr`.

**Dependency Tracking (Compile-Time):**

Dependencies are computed during AST walk when compiling `TEXT { ... }`:

```rust
impl CompileContext {
    fn compile_text_template(&mut self, template: &TextLiteral) -> SlotId {
        let mut dependencies: Vec<SlotId> = Vec::new();
        let mut template_parts: Vec<TemplatePart> = Vec::new();

        for part in &template.parts {
            match part {
                TextPart::Literal(text) => {
                    template_parts.push(TemplatePart::Literal(text.clone()));
                }
                TextPart::Interpolation(expr) => {
                    // Compile the expression, which returns a SlotId
                    let slot = self.compile_expr(expr);
                    dependencies.push(slot);
                    template_parts.push(TemplatePart::Slot(dependencies.len() - 1));
                }
            }
        }

        // Create TextTemplate node with collected dependencies
        let slot = self.arena.alloc();
        self.arena.init(slot, NodeKind::TextTemplate {
            template: template_parts,
            dependencies: dependencies.clone(),
        });

        // Subscribe to all dependencies
        for dep_slot in dependencies {
            self.routing.add_route(dep_slot, slot, Port::Output);
        }

        slot
    }
}
```

**Rule:** TextTemplate `dependencies` contains all SlotIds referenced in template interpolation expressions (`{expr}`). The TextTemplate node subscribes to all these slots and re-renders when any dependency emits a new value.

### 2.3.2.4 List/map External Dependency Tracking

**Problem:** `list_map_external_dep.bn` - List/map item subgraphs don't re-run when external dependencies change.

```rust
pub struct ListMapNode {
    pub source_list: SlotId,
    pub item_subgraphs: HashMap<ItemKey, ItemSubgraph>,
}

pub struct ItemSubgraph {
    pub root_slot: SlotId,
    pub external_deps: Vec<SlotId>,  // Deps outside the item scope
}

impl ListMapNode {
    fn on_external_dep_change(&mut self, dep: SlotId, event_loop: &mut EventLoop) {
        // Re-evaluate all items that depend on this external
        for (key, subgraph) in &self.item_subgraphs {
            if subgraph.external_deps.contains(&dep) {
                event_loop.mark_dirty(subgraph.root_slot);
            }
        }
    }
}
```

**Compile-time:** During List/map body compilation, track which SlotIds are external (not created within item scope).

**List/map Item Body Compilation Model:**

The body expression is compiled **once** as a template with `item` as a parameter slot. Each list item then instantiates this template with its own scope:

```rust
impl CompileContext {
    fn compile_list_map(&mut self, list_slot: SlotId, body: &Expr) -> SlotId {
        // 1. Create the List/map node
        let map_slot = self.arena.alloc();

        // 2. Compile body ONCE with placeholder `item` binding
        //    This produces a "template" subgraph, not actual nodes yet
        let item_placeholder = self.arena.alloc();  // Placeholder for item value
        self.local_bindings.insert("item".into(), item_placeholder);

        // Track which slots are external (defined outside this body)
        let pre_compile_slots = self.arena.slot_count();
        let body_output = self.compile_expr(body);
        let post_compile_slots = self.arena.slot_count();

        // All slots in range [pre, post) are "internal" to the body
        // All slots referenced but < pre are "external dependencies"
        let external_deps = self.collect_external_deps(body, pre_compile_slots);

        // 3. Store compiled body as template
        self.arena.init(map_slot, NodeKind::ListMap {
            source: list_slot,
            body_template: BodyTemplate {
                item_slot: item_placeholder,
                output_slot: body_output,
                external_deps,
            },
            items: HashMap::new(),  // Populated at runtime
        });

        map_slot
    }

    fn instantiate_list_item(&mut self, map_slot: SlotId, key: ItemKey, initial: Payload) {
        // Clone the body template for this specific item
        // - item_slot receives the actual item value
        // - All internal slots get fresh SlotIds in item's scope
        // - External deps remain pointing to original slots
        let item_scope = self.current_scope.child(key);
        // ... instantiate template with item_scope ...
    }
}
```

**Key insight:** Body is compiled once, then instantiated per-item with scope isolation. This means:
- `item` binds to each item's value (different SlotId per item)
- External references (closures over outer scope) share the same SlotIds
- External deps trigger re-evaluation of ALL items that reference them

### 2.3.2.5 Chained List/remove Semantics

**Problem:** `chained_list_remove_bug.bn` - chaining `List/remove` breaks when upstream triggers Replace.

```rust
pub struct ListRemoveNode {
    pub source: SlotId,                   // Upstream list
    pub site_id: SourceId,                // This remove site
    pub removed_keys: HashSet<ItemKey>,   // Keys removed BY THIS SITE
}

impl ListRemoveNode {
    fn on_upstream_delta(&mut self, delta: ListDelta) -> Option<ListDelta> {
        match delta {
            ListDelta::Insert { key, .. } => {
                if self.removed_keys.contains(&key) {
                    None  // Filter out: this key was removed downstream
                } else {
                    Some(delta)  // Pass through
                }
            }
            ListDelta::Remove { key } => {
                // Propagate removal, update our set
                self.removed_keys.remove(&key);
                Some(delta)
            }
            ListDelta::Replace { items } => {
                // On Replace, keep our removed_keys and filter
                let filtered: Vec<_> = items.into_iter()
                    .filter(|item| !self.removed_keys.contains(&item.key))
                    .collect();
                Some(ListDelta::Replace { items: filtered })
            }
            _ => Some(delta),
        }
    }
}
```

**Key insight:** Each remove-site maintains its OWN removed-keys set, applied to upstream deltas.

### 2.3.3 HOLD State Restrictions

**HOLD (Register) stores only scalar/simple values:**

| Allowed in HOLD | NOT Allowed |
|-----------------|-------------|
| Number | List / Bus |
| Text | Nested Objects |
| Tag | Objects containing List |
| Bool (True/False) | Recursive structures |
| Unit ([]) | TaggedObject with nested containers |
| Flat Object (fields are scalars only) | |

**Why:** Register is a D flip-flop - one storage cell for one value. Collections use Bus instead.

**Flat Object Runtime Model:**
Flat objects in HOLD (e.g., `[x: 0, y: 0]`) are stored efficiently:
- **Compile-time:** Desugars to Router with a Register for each field
- **Runtime:** Field updates modify existing Register nodes, no new Router allocations
- **Effect:** `[x: state.x + 1, y: state.y]` updates only the `x` Register node, `y` is preserved

This avoids per-tick object allocation. The "flat object" appears as one value in source code,
but compiles to a Router pointing to per-field Registers. This is why nested objects are NOT
allowed - they would require dynamically allocating Routers for each level.

**Pattern:**
```boon
-- CORRECT: scalar state in HOLD
counter: 0 |> HOLD state { trigger |> THEN { state + 1 } }
editing: None |> HOLD state { start |> THEN { Editing[id] } }

-- CORRECT: flat object in HOLD (all fields are scalars)
-- Compiles to: Router { x: Register(0), y: Register(0) }
position: [x: 0, y: 0] |> HOLD state { move |> THEN { [x: state.x + 1, y: state.y] } }

-- CORRECT: object CONTAINING HOLD nodes (each field has its own HOLD)
todo_item: [
    title: "Buy milk" |> HOLD state { edit |> THEN { new_title } },
    completed: False |> HOLD state { toggle |> THEN { not(state) } }
]

-- CORRECT: collection in LIST (not HOLD)
items: LIST {} |> List/append(item: new_item)

-- WRONG: List in HOLD
items: LIST {} |> HOLD state { ... }  -- NOT ALLOWED

-- WRONG: nested object in HOLD
item: [data: [nested: 1]] |> HOLD state { ... }  -- NOT ALLOWED (nested object)
```

**Distinction:** "Object containing HOLD nodes" ≠ "HOLD containing objects"
- Objects can have HOLD nodes for their scalar fields (each field has independent state)
- HOLD cannot store nested/complex objects (Register is a single storage cell)

**Compile-Time Validation:**

The compiler validates HOLD initial values and body expressions to ensure they produce allowed types:

```rust
impl CompileContext {
    fn validate_hold_value_type(&self, value: &Expr, span: Span) -> Result<(), CompileError> {
        match self.infer_value_shape(value) {
            ValueShape::Scalar => Ok(()),           // Number, Text, Tag, Bool, Unit
            ValueShape::FlatObject(fields) => {
                // Check all fields are scalars
                for (name, field_shape) in fields {
                    if !matches!(field_shape, ValueShape::Scalar) {
                        return Err(CompileError::new(
                            span,
                            format!(
                                "HOLD cannot store nested objects. Field '{}' contains a non-scalar value. \
                                Consider using separate HOLD nodes for each field, or storing the collection in a LIST instead.",
                                name
                            )
                        ));
                    }
                }
                Ok(())
            }
            ValueShape::List => Err(CompileError::new(
                span,
                "HOLD cannot store lists. Use LIST {} with List/append, List/remove instead. \
                HOLD (Register) stores a single value; lists require Bus nodes for item management."
            )),
            ValueShape::NestedObject => Err(CompileError::new(
                span,
                "HOLD cannot store nested objects (objects containing objects or lists). \
                Flatten the structure or use separate HOLD nodes for each level."
            )),
            ValueShape::TaggedObject(tag) => {
                // TaggedObjects with scalar fields are allowed (e.g., Duration, Oklch)
                // TaggedObjects with nested containers are not
                self.validate_tagged_object_for_hold(tag, span)
            }
        }
    }
}
```

**Error message examples:**
- `HOLD cannot store lists. Use LIST {} with List/append, List/remove instead.`
- `HOLD cannot store nested objects. Field 'data' contains a non-scalar value.`
- `HOLD cannot store nested objects (objects containing objects or lists).`

### 2.3.4 Delta Streams for Containers (Scalability)

**Problem:** Materialized values don't scale for large lists with nested data.

```
500 users, one status change:
  Materialized: Diff O(500), copy nested data, send 5KB over WebSocket
  Delta stream: Emit delta, O(1), send 50 bytes
```

**Solution:** Containers emit delta events, not full values.

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ListDelta {
    Insert { key: ItemKey, index: u32, value: Payload },   // Add item at index
    Update { key: ItemKey, value: Payload },                // Replace item value
    FieldUpdate { key: ItemKey, field: FieldId, value: Payload }, // Nested field within item
    Remove { key: ItemKey },                                // Remove item by key
    Move { key: ItemKey, from_index: u32, to_index: u32 },  // Reorder item
    Replace { items: Vec<(ItemKey, Payload)> },             // Full list replacement
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ObjectDelta {
    FieldUpdate { field: FieldId, value: Payload },  // Set/update field value
    FieldRemove { field: FieldId },                  // Remove field from object
}
```

**How it works:**

```
User status changes:
  1. HOLD emits new status value
  2. Parent Router (user object) wraps in ObjectDelta::FieldUpdate
  3. Parent Bus (users list) wraps in ListDelta::FieldUpdate { key: user_123, field: "status", ... }
  4. Subscribers receive delta, update only affected part
  5. WebSocket: serialize just the delta
```

**Materialization points:**
- UI rendering (convert deltas to DOM ops)
- Snapshots (accumulate deltas into full state)
- WHEN pattern matching (may need full value)

**Benefits for backend:**
- WebSocket sync: O(delta_size) not O(list_size)
- Reconnect: send snapshot + replay deltas from checkpoint
- Nested lists: independent delta streams, no parent copying

### 2.3.5 Routing Table

Explicit routing instead of implicit subscriptions:

```rust
pub struct RoutingTable {
    // Static routes (from source code)
    static_routes: HashMap<NodeAddress, Vec<NodeAddress>>,
    // Dynamic routes (from WHILE, List changes)
    dynamic_routes: HashMap<NodeAddress, Vec<NodeAddress>>,
}
```

### 2.3.6 Message Storage Model

**Decision: Last-Value Cache per Node**

Each node stores its most recently emitted value. Subscribers read source nodes' cached values when triggered.

```rust
// Conceptual view - actual fields stored in NodeExtension (see §2.2.5)
pub struct ReactiveNode {
    pub generation: u32,
    pub version: u32,           // Incremented on each emit
    pub dirty: bool,
    pub kind: NodeKind,
    // Value storage in extension (heap-allocated):
    // pub current_value: Option<Payload>,  // Last emitted value (cache)
    // pub pending_deltas: Vec<Payload>,    // Accumulated deltas this tick
}
```

**Note:** For the actual 64-byte cache-aligned struct layout, see §2.2.5. Value storage (`current_value`, `pending_deltas`) lives in `NodeExtension` to keep the inline node compact.

**Why Last-Value Cache (not message queues):**

| Approach | Pros | Cons |
|----------|------|------|
| **Last-Value Cache** (chosen) | Simple, O(1) lookup, matches hardware registers | Can't track multiple in-flight messages |
| Message Queue per Edge | Handles fast producers | O(edges) memory, complex lifecycle |
| Central Message Store | Single location for all messages | HashMap lookup overhead, concurrent access issues |

**Last-Value Cache is correct for Boon because:**
1. **Reactive semantics:** Nodes care about "current value", not message history
2. **Tick-based processing:** Within a tick, only latest value matters
3. **Hardware model:** Registers hold ONE value (flip-flop semantics)
4. **Simplicity:** No queue management, no memory growth

### 2.3.6.1 Wire Transparency Principle

**CRITICAL:** Wire nodes are meant to be **transparent** - they should always forward to their source, never return cached values.

When reading values via `get_current_value()`:

| Node Kind | Behavior | Why |
|-----------|----------|-----|
| **Wire** | ALWAYS follow source chain | Wires are transparent references, not storage |
| **Register (HOLD)** | ALWAYS return `stored_value` | Register is the authoritative state holder |
| **Producer** | Return stored value | Constants don't change |
| **Other nodes** | Use `current_value` cache | Performance optimization |

**Implementation (get_current_value):**
```rust
fn get_current_value_depth(&self, slot: SlotId, depth: usize) -> Option<&Payload> {
    // Check node kind FIRST for types that need special handling

    // Wire: ALWAYS follow source chain (never use cached current_value)
    if let Some(NodeKind::Wire { source: Some(source_slot) }) = node.kind() {
        return self.get_current_value_depth(*source_slot, depth + 1);
    }

    // Register (HOLD): ALWAYS use stored_value (the authoritative state)
    if let Some(NodeKind::Register { stored_value: Some(val), .. }) = node.kind() {
        return Some(val);
    }

    // ... other node types can use current_value cache
}
```

**Why this matters for HOLD:**

In the HOLD pattern, a `state_wire` is created to reference the Register's value inside the body:

```boon
0 |> HOLD counter { tick |> THEN { counter + 1 } }
```

The `state_wire` (for `counter` inside the body) points to the Register but is NOT subscribed to it (to prevent infinite loops). This means:

1. The `state_wire.current_value` is set once at initialization (e.g., 0)
2. When THEN fires, it triggers body re-evaluation
3. Body reads `counter` via `get_current_value(state_wire)`
4. If Wire returned cached value → body always sees 0 → counter stuck at 1
5. If Wire follows source chain → body sees Register's current `stored_value` → counter increments correctly

**Rule:** Wire nodes are like "named wires" in hardware - they carry signals, they don't store values. `get_current_value` must respect this by always following the Wire's source.

**How Combiners (LATEST) Read Multiple Inputs:**

```rust
impl EventLoop {
    fn process_combiner(&mut self, combiner_slot: SlotId) {
        let combiner = self.arena.get(combiner_slot)?;
        let NodeKind::Combiner { inputs, .. } = &combiner.kind else { return };

        // Read current values from all input sources
        let values: Vec<Option<Payload>> = inputs.iter()
            .map(|input_slot| {
                self.arena.get(*input_slot)
                    .and_then(|node| node.current_value.clone())
            })
            .collect();

        // Emit combined value if all inputs have values
        if values.iter().all(|v| v.is_some()) {
            let combined = self.combine_values(values);
            self.emit(combiner_slot, combined);
        }
    }
}
```

**LATEST (Combiner) Input Semantics:**

| Phase | Behavior |
|-------|----------|
| **Initialization** | Wait until ALL inputs have emitted at least one value |
| **After initialization** | Emit on ANY input change (using last-value cache for other inputs) |
| **Triggering input** | The input that caused this tick's processing; its NEW value is used |
| **Non-triggering inputs** | Their CACHED last-values are used |

**Rule:** LATEST emits only when all inputs have at least one value. After that, it emits on every subsequent input change, combining the triggering input's new value with cached values from other inputs.

```boon
-- Example: LATEST { a, b, c }
-- Timeline:
-- Tick 1: a=1 emits      → No output (b, c have no values)
-- Tick 2: b=2 emits      → No output (c has no value)
-- Tick 3: c=3 emits      → Output: [a: 1, b: 2, c: 3] (all have values now)
-- Tick 4: a=10 emits     → Output: [a: 10, b: 2, c: 3] (a changed, b/c cached)
-- Tick 5: b=20, c=30     → Output: [a: 10, b: 20, c: 30] (both changed this tick)
```

**How Register (HOLD) Updates State:**

```rust
impl EventLoop {
    fn process_register(&mut self, register_slot: SlotId) {
        let register = self.arena.get_mut(register_slot)?;
        let NodeKind::Register { stored_value, body_input } = &mut register.kind else { return };

        // Body produced a new value - update stored state
        if let Some(body_slot) = body_input {
            if let Some(body_node) = self.arena.get(*body_slot) {
                if let Some(new_value) = &body_node.current_value {
                    *stored_value = Some(new_value.clone());
                    // Mark register as having new output
                    self.emit(register_slot, new_value.clone());
                }
            }
        }
    }
}
```

**Value Lifecycle:**

1. **Node emits:** Sets `current_value`, increments `version`, marks subscribers dirty
2. **Subscriber processes:** Reads source's `current_value` when scheduled
3. **Tick ends:** Values persist until next emit (they're cached, not queued)
4. **Node freed:** `current_value` is dropped with node

**Edge Cases:**

| Scenario | Behavior |
|----------|----------|
| Multiple emits per tick (scalars) | Only last value seen by subscribers |
| Multiple emits per tick (deltas) | All deltas delivered in order (see below) |
| Source freed before subscriber reads | Subscriber sees `None` (stale SlotId detection) |
| Subscriber reads before source emits | Returns `None` (no value yet) |
| Subscriber faster than source | Always reads latest available value |

**Scalars vs Deltas - Important Distinction:**

The last-value cache model applies to **scalar payloads** (Number, Text, Bool, etc.). For **delta payloads** (ListDelta, ObjectDelta), different semantics apply:

| Payload Type | Storage Model | Multiple Emits per Tick |
|--------------|---------------|-------------------------|
| Scalars (Number, Text, etc.) | Last-value cache | Only last value matters |
| Delta (ListDelta, ObjectDelta) | Per-tick accumulator | All deltas preserved in order |

**Why deltas need accumulation:**
```
// Wrong (if we used last-value for deltas):
List/append(A) → Insert(A)
List/append(B) → Insert(B)  // Overwrites Insert(A)!
Subscriber sees only Insert(B) → Missing item A!

// Correct (delta accumulation):
List/append(A) → Accumulator: [Insert(A)]
List/append(B) → Accumulator: [Insert(A), Insert(B)]
Subscriber processes both deltas → Sees items A and B
```

**Implementation:**
```rust
// Value storage in NodeExtension (see §2.2.5 for full struct layout)
impl EventLoop {
    fn emit(&mut self, slot: SlotId, payload: Payload) {
        let node = self.arena.get_mut(slot)?;
        let ext = node.extension.get_or_insert_with(Default::default);

        match &payload {
            Payload::ListDelta(_) | Payload::ObjectDelta(_) => {
                // Deltas: accumulate, don't replace
                ext.pending_deltas.push(payload);
            }
            _ => {
                // Scalars: last-value cache
                ext.current_value = Some(payload);
            }
        }

        node.version += 1;
        self.mark_subscribers_dirty(slot);
    }

    fn end_tick(&mut self) {
        // Clear delta accumulators after tick completes
        for node in self.arena.nodes_mut() {
            if let Some(ext) = &mut node.extension {
                ext.pending_deltas.clear();
            }
        }
    }
}
```

**Determinism:** Processing order (by NodeAddress sort) ensures same subscriber always sees same value/delta sequence across runs.

### 2.3.7 Routing Table Management

**Route Addition:**
Routes are added when nodes are created during compilation:

```rust
impl CompileContext {
    fn compile_wire(&mut self, source: SlotId, wire_name: &str) -> SlotId {
        let wire_slot = self.event_loop.arena.alloc();
        // ... initialize wire node ...

        // Add route: when source emits, wire receives
        self.event_loop.routing.add_route(source, wire_slot, Port::Output);

        wire_slot
    }
}
```

**Dynamic Routes (WHILE/WHEN switches):**

```rust
impl EventLoop {
    fn switch_while_arm(&mut self, while_slot: SlotId, new_arm: usize) {
        let while_node = self.arena.get_mut(while_slot)?;
        let NodeKind::SwitchedWire { current_arm, arm_outputs, .. } = &mut while_node.kind else { return };

        // 1. Finalize old arm scope (removes routes)
        if let Some(old_arm) = *current_arm {
            let old_output = arm_outputs[old_arm];
            self.finalize_scope(old_output);  // Recursively removes routes
        }

        // 2. Activate new arm (routes already exist from compilation)
        *current_arm = Some(new_arm);

        // 3. Mark new arm output as dirty (propagate current value)
        self.mark_dirty(arm_outputs[new_arm], Port::Output);
    }
}
```

**Dynamic Routes (List/map items):**

```rust
impl EventLoop {
    fn list_append(&mut self, list_slot: SlotId, initial: Payload) -> ItemKey {
        let list_node = self.arena.get_mut(list_slot)?;
        let NodeKind::Bus { items, alloc_site } = &mut list_node.kind else { return ItemKey(0) };

        // 1. Allocate new item key
        let key = alloc_site.allocate();

        // 2. Create item scope (compiles body with item_key as scope discriminator)
        let item_scope = self.current_scope.child(key);
        let item_slot = self.compile_list_item_body(list_slot, item_scope, initial);

        // 3. Routes were added during body compilation
        items.push((key, item_slot));

        // 4. Emit insert delta
        self.emit(list_slot, Payload::ListDelta(ListDelta::Insert { key, index: items.len() as u32 - 1, initial }));

        key
    }

    fn list_remove(&mut self, list_slot: SlotId, key: ItemKey) {
        let list_node = self.arena.get_mut(list_slot)?;
        let NodeKind::Bus { items, .. } = &mut list_node.kind else { return };

        // 1. Find and remove item
        if let Some(pos) = items.iter().position(|(k, _)| *k == key) {
            let (_, item_slot) = items.remove(pos);

            // 2. Finalize item scope (removes routes, frees nodes)
            self.finalize_scope(item_slot);

            // 3. Emit remove delta
            self.emit(list_slot, Payload::ListDelta(ListDelta::Remove { key }));
        }
    }
}
```

**Route Removal (Scope Finalization):**

```rust
impl EventLoop {
    fn finalize_scope(&mut self, root_slot: SlotId) {
        // Collect all slots in this scope (BFS from root)
        let scope_slots = self.collect_scope_slots(root_slot);

        for slot in scope_slots {
            // 1. Remove all routes FROM this node
            self.routing.remove_source(slot);

            // 2. Remove all routes TO this node
            self.routing.remove_target(slot);

            // 3. Unbind any LINK event listeners
            if let Some(node) = self.arena.get(slot) {
                if matches!(node.kind, NodeKind::IOPad { .. }) {
                    self.unbind_link(slot);
                }
            }

            // 4. Free the slot
            self.arena.free(slot);
        }
    }
}
```

**Files to modify:**
- `crates/boon/src/engine_v2/message.rs` - Message, Payload types
- `crates/boon/src/engine_v2/routing.rs` - RoutingTable
- `crates/boon/src/engine_v2/node.rs` - Node kind implementations
- `crates/boon/src/engine_v2/arena.rs` - Add current_value to ReactiveNode

---

