## Chapter 2.1: Node Identification

### 2.1.1 SourceId (Parse-Time)

Every AST node gets a stable structural hash ID during parsing (see Issue 26 for full details):

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct SourceId {
    pub stable_id: u64,    // Structural hash (survives whitespace/comment changes)
    pub parse_order: u32,  // For debugging and collision tiebreaking
}
```

**Assignment:** Computed via structural hash of node kind, parent path, and content. Stored in `Spanned<T>` alongside span.

**Files to modify:**
- `crates/boon/src/parser.rs` - Add SourceId to Spanned struct
- `crates/boon/src/parser/persistence_resolver.rs` - Integrate with PersistenceId

#### SourceId Collision Handling

**Collision probability:** With a 64-bit hash, probability of collision is ~1 in 10^18 for typical program sizes. This is effectively zero for practical purposes.

**Detection:** If two nodes produce the same `stable_id`:
1. Compare `(stable_id, parse_order)` tuple
2. If `stable_id` matches but `parse_order` differs, they are different nodes
3. Log warning for debugging: `"SourceId collision detected: nodes at parse positions {} and {} have same stable_id {:#x}"`

**Resolution strategy:**

```rust
impl SourceId {
    /// Compare two SourceIds, using parse_order as tiebreaker
    pub fn same_node(&self, other: &Self) -> bool {
        self.stable_id == other.stable_id && self.parse_order == other.parse_order
    }

    /// For debugging: detect potential collision
    pub fn potential_collision(&self, other: &Self) -> bool {
        self.stable_id == other.stable_id && self.parse_order != other.parse_order
    }
}
```

**Impact on persistence:**
- Persistence keys use `(module_path, SourceId)` tuple
- Even with collision, parse_order ensures different keys
- Worst case: two nodes share a persistence key (extremely rare, data corruption risk)

**Mitigation in practice:**
- Hash includes parent path, node kind, and content
- Collisions require exactly matching structure in different positions
- If collision detected at runtime, log warning and continue (don't crash)

### 2.1.2 ScopeId (Runtime)

Captures dynamic instantiation context:

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ScopeId(u64);  // Hash of scope path

impl ScopeId {
    pub const ROOT: Self = Self(0);

    pub fn child(&self, discriminator: u64) -> Self {
        Self(self.0.wrapping_mul(31).wrapping_add(discriminator))
    }
}
```

**Propagation rules:**
| Context | Scope Change |
|---------|--------------|
| Top-level | `ScopeId::ROOT` |
| Function call | `parent.child(call_site_source_id)` |
| LIST item | `parent.child(item_key)` via AllocSite |
| HOLD body | Same scope (NO new child scope per iteration) - see Issue 1 |
| WHILE arm | `parent.child(arm_index)` |
| BLOCK | Same scope (local bindings, no scope change) |

### 2.1.2.1 AllocSite for List Item Identity

**Problem:** When `List/append(item: new_todo())` creates items, each needs a stable identity that:
- Survives page reload (persistence)
- Handles "removed then re-added" correctly
- Avoids fragile call-stack tracking

**Solution:** Each append site is a "factory" with monotonic instance IDs:

```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub struct AllocSite {
    pub site_source_id: SourceId,  // The List/append call site
    pub next_instance: u64,        // Monotonic counter, persisted
}

pub type ItemKey = u64;  // The instance_id from AllocSite

impl AllocSite {
    pub fn allocate(&mut self) -> ItemKey {
        let id = self.next_instance;
        self.next_instance += 1;
        id
    }
}
```

**How it works:**
1. Each `List/append` call site has its own AllocSite
2. When append triggers, allocate a new InstanceId
3. Item's ScopeId = `parent.child(instance_id)`
4. Persist AllocSite counter for reload stability

**Benefits:**
- Stable persistence keys for dynamically created items
- No fragile origin tracking needed
- Works correctly with removal + re-addition
- Each append location is its own numbered "factory"

### 2.1.3 NodeAddress (Combined with Domain)

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct NodeAddress {
    pub domain: Domain,   // Execution location
    pub source_id: SourceId,
    pub scope_id: ScopeId,
    pub port: Port,       // Which input/output of the node
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
pub enum Domain {
    #[default]
    Main,           // UI thread (browser main, or single-threaded mode)
    Worker(u8),     // WebWorker index
    Server,         // Backend (future: over WebSocket)
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Port {
    Output,           // Default output
    Input(u8),        // Numbered input (for LATEST, etc.)
    Field(u32),       // Field ID (for Router/Object field projection)
}

// Port::Field usage clarification:
// - Router nodes have multiple output "ports" - one per field
// - When subscribing to `store.items`, you subscribe to Port::Field(items_id)
// - The FieldId is a hash of the field name for fast lookup
// - Example: store: [items: LIST {}, filter: Text] has ports Field(hash("items")), Field(hash("filter"))
```

**Port JSON representation (canonical):**
```json
{"type": "output"}
{"type": "input", "n": 0}
{"type": "input", "n": 1}
{"type": "field", "id": 42}
```

**Why domain is needed:**
- Same NodeId can exist in different execution contexts
- Explicit routing for WebWorkers and backend distribution
- Clean message routing: "this message goes to Worker[2]"
- Same pattern works for local threading and remote WebSocket

**Why port is needed:**
- LATEST has multiple inputs - need to address "input 2 of this LATEST"
- Objects have multiple fields - each is a distinct output
- Hardware-inspired: each port maps conceptually to a wire (mental model, not synthesizable - see Issue 3)
- Precise debugging (which input triggered this node?)

**Files to modify:**
- `crates/boon/src/engine_v2/address.rs` - NodeAddress, SourceId, ScopeId, Port types

### 2.1.4 Alias Field-Path Resolution

Examples heavily use field-path expressions like `store.filter_buttons.all.event.press`. These resolve through chain of Router projections:

```rust
// Expression::FieldAccess compilation
// `store.filter_buttons.all.event.press` becomes:
//
// 1. Resolve `store` -> SlotId of store Router
// 2. Access field `filter_buttons` -> SlotId of nested Router
// 3. Access field `all` -> SlotId of LinkNode
// 4. Access field `event` -> SlotId of events Router within LinkNode
// 5. Access field `press` -> SlotId of press event stream

pub fn resolve_field_path(base: SlotId, path: &[FieldId], arena: &Arena) -> SlotId {
    let mut current = base;
    for field in path {
        current = arena.get(current).get_field(*field)
            .expect("Field path resolution failed");
    }
    current
}
```

**Key rule:** Each field access returns a SlotId, not a cloned value. Paths are chains of Router projections.

---

