## Chapter 2.9: Type System

Boon uses a **fully inferred, fully strict** type system. No type annotations appear in syntax - all types are inferred from usage. Programs with ambiguous types are rejected at compile time.

---

### 2.9.1 Overview

**Core principles:**

| Principle | Meaning |
|-----------|---------|
| **Fully inferred** | No type annotations in syntax - all types derived from usage |
| **Fully strict** | All types must be known at compile time, reject ambiguous programs |
| **No reactive wrappers** | Types are just `T` - reactivity is a runtime concern |
| **Structural typing** | Objects are typed by structure, not by name (duck typing) |
| **Contextual tags** | Tag unions inferred from usage context (WHEN arms) |

**Why no type annotations:**
- Boon is a dataflow language - code describes data transformations
- Types should "just work" without manual declarations
- Simpler syntax for UI-focused development
- Errors caught at compile time, not runtime

**Why fully strict:**
- Ambiguous programs are likely bugs
- Clear error messages at compile time vs mysterious runtime failures
- Enables future FPGA synthesis (hardware needs concrete types)

---

### 2.9.2 Type Representation

#### Core Type Enum

```rust
pub enum Type {
    // Primitives
    Number,                    // f64 - single numeric type (like JavaScript)
    Text,                      // String
    Bool,                      // True/False tags
    Unit,                      // Empty object []

    // Tags (contextually inferred)
    Tag(TagId),                // Single tag: Active, Completed

    // Unions - ANY types can be unioned (not just tags)
    Union(Vec<Type>),          // A | B | C - works for any types

    // Composites (structural typing)
    Object(ObjectType),        // Record: [name: Text, age: Number]
    TaggedObject(TagId, ObjectType), // Discriminated: Todo[text: Text, done: Bool]
    List(Box<Type>),           // LIST { T } - generic inferred from usage

    // UNPLUGGED - optional field access
    Unplugged,                 // Structural absence marker

    // Control flow
    Skip,                      // No value in pipeline (filtered out)
    Never,                     // Diverges (e.g., infinite loop, panic)

    // Type inference
    Var(TypeVarId),            // Type variable: ?T0 (resolved during inference)

    // Functions
    Function {
        params: BTreeMap<String, Type>,
        return_type: Box<Type>,
    },
}

// Supporting types
pub struct ObjectType {
    pub fields: BTreeMap<String, Type>,
}

pub type TagId = String;    // Or interned string for efficiency
pub type TypeVarId = u32;   // Fresh variable counter
```

#### Full Union Support

Any types can be unioned, not just tags:

```boon
// Tag unions (common case)
filter: All | Active | Completed

// Value type unions
value: Number | Text

// List with union element type
items: List<Number | Text>

// Error unions (replaces Flushed<T>)
result: Number | ParseError

// Object unions
response: SuccessData | ErrorData
```

**Union simplification:** `Number | Number` simplifies to `Number`. `A | B | A` simplifies to `A | B`.

#### Primitives

| Type | Boon Values | Notes |
|------|-------------|-------|
| `Number` | `42`, `3.14`, `-7` | f64 only, no Int/Float distinction |
| `Text` | `TEXT { hello }` | String type |
| `Bool` | `True`, `False` | Conceptually tags; runtime uses `Payload::Bool(bool)` for efficiency |
| `Unit` | `[]` | Empty object literal; runtime uses `Payload::Unit`; JSON: `null` |

#### Tags

Tags are inferred from usage context. WHEN arms define the variants:

```boon
// Tags grouped by WHEN arms define a union
filter |> WHEN {
    All => items
    Active => items |> List/filter(item -> !item.completed)
    Completed => items |> List/filter(item -> item.completed)
}
// filter : All | Active | Completed
```

#### TaggedObject

TaggedObjects combine a tag with data fields:

```boon
todo: Todo[text: TEXT { Buy groceries }, done: False]
// todo : Todo[text: Text, done: Bool]

// Pattern match on tagged objects
item |> WHEN {
    Todo todo => TEXT { Task: {todo.text} }
    Note note => TEXT { Note: {note.content} }
}
// item : Todo[...] | Note[...]
```

#### Built-in Tagged Objects

**Duration** - Time interval for timers and delays:

```boon
// Duration is a tagged object with mutually exclusive fields
interval: Duration[seconds: 1]        // 1 second
delay: Duration[milliseconds: 500]    // 500ms
timeout: Duration[ms: 100]            // 100ms (alias for milliseconds)

// Type signature
Duration[seconds: Number] | Duration[milliseconds: Number] | Duration[ms: Number]

// Usage with Timer functions
ticks: Duration[seconds: 1] |> Timer/interval()
```

**Evaluation rules:**

| Form | Evaluation | Example |
|------|------------|---------|
| Literal fields | Compile-time constant folding | `Duration[seconds: 1]` → `1000.0` |
| Dynamic fields | Runtime evaluation | `Duration[seconds: x]` → evaluated when `x` changes |

Duration is a **runtime tagged object**, not a compile-time-only construct. When fields are literals, the compiler can constant-fold to milliseconds. When fields are reactive, the Duration is evaluated during runtime and Timer/interval receives the computed milliseconds.

```rust
// Evaluator converts Duration to milliseconds
fn evaluate_duration(tagged: &TaggedObject, arena: &Arena) -> SlotId {
    let field_slot = tagged.fields.values().next().unwrap();
    let multiplier = match tagged.fields.keys().next().unwrap().as_str() {
        "seconds" => 1000.0,
        "milliseconds" | "ms" => 1.0,
        _ => panic!("Invalid Duration field"),
    };
    // Create transformer: field_value * multiplier
    arena.alloc_transformer(field_slot, move |v| v.as_number() * multiplier)
}
```

#### Objects (Structural Typing)

Objects are typed by their structure, not by name:

```boon
person: [name: TEXT { Alice }, age: 30]
// person : [name: Text, age: Number]
```

**Exact matching (no width subtyping):**
- `[a: Number, b: Text]` is NOT a subtype of `[a: Number]`
- Objects must have exactly the expected fields
- This prevents accidental field access bugs

#### No Reactive Wrappers

Reactivity is a **runtime concern**, not a type-level distinction:

```boon
counter: 0 |> HOLD state {
    button.event.press |> THEN { state + 1 }
}
// counter : Number (not Stream<Number> or Behavior<Number>)
```

**Rationale:**
- All values in Boon are potentially reactive
- The type system tracks the **shape** of data, not temporal behavior
- `HOLD`, `LATEST`, `THEN` are flow operators, not type constructors
- Simplifies type system without losing safety

---

### 2.9.3 Type Inference Algorithm

Boon uses **constraint-based inference** (Hindley-Milner style):

#### Phase 1: Constraint Generation

Walk the AST and generate constraints:

```rust
pub enum Constraint {
    // T1 must equal T2
    Equal(Type, Type, Span),

    // T must have field `name` of type FieldType
    HasField(Type, String, Type, Span),

    // All types must unify to result
    Unify(Vec<Type>, Type, Span),
}
```

**Example constraint generation:**

```boon
x: 5
y: x + 3
```

Generates:
1. `x : ?T0`
2. `5 : Number` → `Equal(?T0, Number)`
3. `y : ?T1`
4. `x + 3` requires `x : Number`, `3 : Number` → `Equal(?T0, Number)`, result `Number`
5. `Equal(?T1, Number)`

#### Phase 2: Constraint Solving (Unification)

```rust
impl TypeChecker {
    fn unify(&mut self, t1: &Type, t2: &Type, span: Span) -> Result<(), TypeError> {
        match (t1, t2) {
            // Variable binds to type
            (Type::Var(id), t) | (t, Type::Var(id)) => {
                self.bind_var(*id, t.clone());
                Ok(())
            }

            // Primitives must match exactly
            (Type::Number, Type::Number) => Ok(()),
            (Type::Text, Type::Text) => Ok(()),
            (Type::Bool, Type::Bool) => Ok(()),

            // Objects: check all fields match (exact, no width subtyping)
            (Type::Object(o1), Type::Object(o2)) => {
                if o1.fields.keys().collect::<BTreeSet<_>>()
                    != o2.fields.keys().collect::<BTreeSet<_>>() {
                    return Err(TypeError::ObjectFieldMismatch(span));
                }
                for (name, t1) in &o1.fields {
                    let t2 = o2.fields.get(name).unwrap();
                    self.unify(t1, t2, span)?;
                }
                Ok(())
            }

            // Lists: element types must unify
            (Type::List(elem1), Type::List(elem2)) => {
                self.unify(elem1, elem2, span)
            }

            // Mismatch
            _ => Err(TypeError::Mismatch(t1.clone(), t2.clone(), span)),
        }
    }
}
```

#### Phase 3: Apply Substitution

Replace type variables with their resolved types:

```rust
impl TypeChecker {
    fn apply_substitution(&self, ty: &Type) -> Type {
        match ty {
            Type::Var(id) => {
                self.substitution.get(id)
                    .map(|t| self.apply_substitution(t))
                    .unwrap_or(ty.clone())
            }
            Type::List(elem) => {
                Type::List(Box::new(self.apply_substitution(elem)))
            }
            Type::Object(obj) => {
                Type::Object(ObjectType {
                    fields: obj.fields.iter()
                        .map(|(k, v)| (k.clone(), self.apply_substitution(v)))
                        .collect()
                })
            }
            // ... other cases
            _ => ty.clone(),
        }
    }
}
```

#### Edge Cases

**Empty collections:**
```boon
items: LIST { }
items |> List/push([name: "test"])  // Infers List<[name: Text]>
```
Type is inferred from how the collection is used later.

**Mutual recursion (Strongly Connected Components):**
```boon
is_even: n |> WHEN { 0 => True, _ => n - 1 |> is_odd() }
is_odd: n |> WHEN { 0 => False, _ => n - 1 |> is_even() }
```
1. Identify SCCs in the dependency graph
2. Assign fresh type variables to all functions in SCC
3. Generate constraints from all bodies together
4. Solve all constraints simultaneously

**Unused definitions:** If a function is defined but never called, error if type cannot be fully determined.

---

### 2.9.4 Type Rules by Construct

#### LATEST

```
LATEST { e1, e2, ..., en } : T
  where all ei : Ti
  and T = unify(T1, T2, ..., Tn)
```

All branches must unify to the same type:

```boon
value: LATEST {
    button_a.event.press |> THEN { 1 }
    button_b.event.press |> THEN { 2 }
    button_c.event.press |> THEN { 3 }
}
// value : Number (all arms produce Number)
```

**Error example:**
```boon
value: LATEST {
    button_a.event.press |> THEN { 1 }
    button_b.event.press |> THEN { "text" }  // ERROR: Number vs Text
}
```

#### HOLD

```
initial |> HOLD state { body } : T
  where initial : T
  and state : T (snapshot variable in body scope)
  and body : T
```

State, initial value, and body result must all have the same type:

```boon
counter: 0 |> HOLD state {
    button.event.press |> THEN { state + 1 }
}
// counter : Number
// 0 : Number, state : Number, state + 1 : Number ✓
```

**Error example:**
```boon
counter: 0 |> HOLD state {
    button.event.press |> THEN { "clicked" }  // ERROR: Number vs Text
}
```

#### THEN

```
input |> THEN { body } : U
  where input : T
  and body : U (evaluated with input value in scope)
```

Body type becomes output type:

```boon
button.event.press |> THEN { [timestamp: now()] }
// Result: [timestamp: Number]
```

#### WHEN (Pattern Matching)

```
input |> WHEN { pattern1 => body1, pattern2 => body2, ... } : T
  where all bodyi : Ti
  and T = unify(T1, T2, ..., Tn)
  and patterns are exhaustive
```

All arms must produce the same type.

```boon
filter |> WHEN {
    All => items
    Active => items |> List/filter(...)
    Completed => items |> List/filter(...)
}
// All arms return List<Todo>
```

**Exhaustiveness check:** The type checker ensures all patterns are exhaustive:

```boon
// ERROR: Non-exhaustive pattern match
filter |> WHEN {
    All => items
    Active => items |> List/filter(...)
    // Missing: Completed
}
```

**Fix options:**
1. Add the missing pattern: `Completed => ...`
2. Use wildcard to catch all: `_ => default_value`

**Tag inference from WHEN arms:**
```boon
status |> WHEN {
    Active => "active"
    Completed => "done"
}
// status : Active | Completed (inferred from arms)
```

#### WHILE

Same typing rules as WHEN, but continuous flow while pattern matches:

```boon
input |> WHILE {
    Some value => process(value)
    None => Skip  // Filters out
}
```

**Exhaustiveness:** WHILE also requires exhaustive patterns. If input type is `Some | None`, both must be handled.

#### Pipe Operator

```
a |> f : U
  where a : T
  and f : T -> U
```

Types thread through pipes:

```boon
5 |> add(3) |> multiply(2)
// 5 : Number
// add(3) : Number -> Number
// multiply(2) : Number -> Number
// Result: Number
```

---

### 2.9.5 UNPLUGGED Handling

Optional field access with `?` produces `T | Unplugged`:

```
obj.field? : T | Unplugged
  where obj : [field: T, ...]
```

**Must be handled before use:**

```boon
item.name?
|> WHEN {
    UNPLUGGED => TEXT { No name }      // Handles absence
    name => TEXT { Name: {name} }      // name : Text (narrowed)
}
```

**Type narrowing:** After pattern match, inner scope sees just `T`:

```boon
user.email?
|> WHEN {
    UNPLUGGED => show_email_input()
    email => {
        // email : Text (not Text | Unplugged)
        send_to(email)
    }
}
```

**Error if not handled:**

```boon
// ERROR: Cannot use Text | Unplugged where Text expected
message: TEXT { Hello {user.name?} }
```

---

### 2.9.6 Error Handling with Unions

**At the type level**, errors are represented as **regular union types** for pattern matching:

```
expression |> operation : T | ErrorType
  where operation can fail
```

**Type vs Runtime distinction:**

| Level | Representation | Purpose |
|-------|----------------|---------|
| **Type system** | `T \| ErrorType` union | Pattern matching, static analysis |
| **Runtime** | `Payload::Flushed(error)` wrapper | Transparent propagation (bypass nodes) |

The programmer writes WHEN patterns against union types. At runtime, `Payload::Flushed` enables transparent propagation through pipelines until unwrapped at boundaries (see §2.6).

**Example:** `parse_number()` returns `Number | ParseError`

**Propagation through pipes:**

```boon
input
|> parse_number()     // : Number | ParseError
|> add(5)             // : Number | ParseError (propagates)
|> multiply(2)        // : Number | ParseError (propagates)
```

The error type propagates through the pipeline until handled.

**Explicit handling via WHEN:**

```boon
input
|> parse_number()
|> WHEN {
    ParseError error => 0           // Handle error
    value => value + 1              // Handle success
}
// Result: Number (error handled, no more union)
```

**FLUSH keyword creates error value:**

```boon
validated: input |> WHEN {
    n if n >= 0 => n
    _ => FLUSH ValidationError["Must be non-negative"]
}
// validated : Number | ValidationError
```

**Item-level isolation in Lists:**

When mapping over a list, errors in one item don't affect others:

```boon
items |> List/map(item -> item |> risky_operation())
// Each item may independently succeed or produce error
// Result: List<T | ErrorType>
```

See §2.6 (Error Handling) for full FLUSH semantics.

---

### 2.9.7 Built-in Function Types

#### Math Functions

```
Math/abs    : Number -> Number
Math/floor  : Number -> Number
Math/ceil   : Number -> Number
Math/round  : Number -> Number
Math/sqrt   : Number -> Number | MathError  // negative input
Math/pow    : (Number, Number) -> Number
Math/min    : (Number, Number) -> Number
Math/max    : (Number, Number) -> Number
```

#### Text Functions

```
Text/concat    : (Text, Text) -> Text
Text/length    : Text -> Number
Text/slice     : (Text, Number, Number) -> Text
Text/uppercase : Text -> Text
Text/lowercase : Text -> Text
Text/trim      : Text -> Text
Text/split     : (Text, Text) -> List<Text>
Text/join      : (List<Text>, Text) -> Text
```

#### List Functions (Polymorphic)

```
List/length  : List<T> -> Number
List/push    : (List<T>, T) -> List<T>
List/pop     : List<T> -> List<T>
List/get     : (List<T>, Number) -> T | Unplugged
List/map     : (List<T>, T -> U) -> List<U>
List/filter  : (List<T>, T -> Bool) -> List<T>
List/reduce  : (List<T>, U, (U, T) -> U) -> U
List/find    : (List<T>, T -> Bool) -> T | Unplugged
List/concat  : (List<T>, List<T>) -> List<T>
```

#### Timer Functions

```
Timer/interval : Duration -> Number          // Emits tick count at interval
Timer/delay    : (T, Duration) -> T          // Delays value by duration
Timer/throttle : (T, Duration) -> T          // Rate limit
Timer/debounce : (T, Duration) -> T          // Debounce
```

#### Stream Functions

```
Stream/pulses  : Number -> Number            // Emits 0..n-1 across n ticks
Stream/skip    : (T, Number) -> T            // Skip first n emissions
```

#### Element Functions

```
Element/button : [content: Element | Text, ...] -> Element
Element/input  : [...] -> Element
Element/div    : [content: Element | List<Element>, ...] -> Element
Element/text   : Text -> Element
```

---

### 2.9.8 Implementation Outline

#### File Structure

```
crates/boon/src/parser/
├── type_checker/
│   ├── mod.rs          # Entry point, TypeChecker struct
│   ├── types.rs        # Type enum, ObjectType, supporting types
│   ├── inference.rs    # Constraint generation from AST
│   ├── unification.rs  # Unification algorithm, substitution
│   ├── builtins.rs     # Built-in function type signatures
│   └── errors.rs       # TypeError enum, error formatting
```

#### Integration Point

```
Source → Lexer → Parser → Scope Resolver → Persistence Resolver
    → Static Expression → TYPE CHECKER (NEW) → Evaluator
```

The type checker runs after scope resolution and before evaluation:

```rust
pub fn compile(source: &str) -> Result<TypedAST, CompileError> {
    let tokens = lexer::lex(source)?;
    let ast = parser::parse(tokens)?;
    let scoped = scope_resolver::resolve(ast)?;
    let persisted = persistence_resolver::resolve(scoped)?;
    let typed = type_checker::check(persisted)?;  // NEW
    Ok(typed)
}
```

#### Error Reporting

Use ariadne (existing dependency) for rich error messages:

```
Error: Type mismatch in HOLD body
  Expected: Number (matching initial value)
  Found: Text

  ╭─[counter.bn:3:5]
  │
1 │ counter: 0 |> HOLD state {
  │          ─ initial value is Number
  │
3 │     button.event.press |> THEN { "clicked" }
  │                                  ^^^^^^^^^^ this is Text
  │
  ╰─ help: HOLD body must produce the same type as the initial value
```

---

### 2.9.9 Examples

#### Counter Type Derivation

```boon
counter: 0 |> HOLD state {
    button.event.press |> THEN { state + 1 }
}
```

**Inference steps:**
1. `0` : `Number`
2. `HOLD` initial: `?T0`, constraint: `Equal(?T0, Number)`
3. `state` in body: `?T0` (same as initial)
4. `state + 1`: requires `state : Number`, produces `Number`
5. Body produces `Number`, constraint: `Equal(?T0, Number)`
6. Solve: `?T0 = Number`
7. Result: `counter : Number`

#### TODO Filter (Tag Inference)

```boon
filter: All |> HOLD state {
    LATEST {
        btn_all.event.press |> THEN { All }
        btn_active.event.press |> THEN { Active }
        btn_completed.event.press |> THEN { Completed }
    }
}

visible_todos: filter |> WHEN {
    All => todos
    Active => todos |> List/filter(t -> !t.completed)
    Completed => todos |> List/filter(t -> t.completed)
}
```

**Inference steps:**
1. `All` used as initial: `All : Tag(All)`
2. LATEST branches: `All`, `Active`, `Completed` - all are tags
3. HOLD requires same type → union: `All | Active | Completed`
4. WHEN patterns: `All`, `Active`, `Completed` - exhaustive for union
5. Result: `filter : All | Active | Completed`

#### Error Handling (Union Types)

```boon
user_age: input_text
    |> Text/parse_number()      // Number | ParseError
    |> WHEN {
        ParseError _ => 0       // Default on error
        age => age
    }
    // user_age : Number (error handled)

validated_age: user_age |> WHEN {
    age if age >= 0 && age <= 150 => age
    _ => FLUSH ValidationError["Invalid age"]
}
// validated_age : Number | ValidationError
```

---

### 2.9.10 Deferred Decisions

The following are deferred for future consideration:

| Decision | Status | Notes |
|----------|--------|-------|
| Generic variance | DEFER | Covariant/contravariant for List<T> etc. |
| Recursive types | DEFER | Self-referential types like linked lists |
| Type aliases | DEFER | Named type abbreviations |
| Type matching in WHEN | DEFER | Match by primitive type in unions (see below) |

#### Type Matching in WHEN/WHILE

**Question:** Should WHEN/WHILE support matching by primitive types for unions like `Number | Text`?

```boon
// Hypothetical - NOT currently supported
value |> WHEN {
    <Text> text => TEXT { String: {text} }
    <Number> n => TEXT { Number: {n} }
}
```

**Syntax options considered:**

| Option | Syntax | Pros | Cons |
|--------|--------|------|------|
| A | `<Type> binding` | Clear type annotation, no tag conflict | New syntax, `<` in guards |
| B | `binding<Type>` | Matches inline display `x<Number>` | Looks like `n < Number` |
| C | `Type binding` | No new syntax | Ambiguous with tags |

**Decision: DEFER.** Reasons:

1. **Rare use case** - Boon's typed dataflow rarely produces `Number | Text` unions
2. **TaggedObject alternative** - Explicit wrappers work today:
   ```boon
   // Use IntValue[...] | TextValue[...] instead of Number | Text
   data |> WHEN {
       IntValue v => v.value + 1
       TextValue v => Text/length(v.value)
   }
   ```
3. **Syntax complexity** - All options have trade-offs
4. **Wait for real usage** - Add when developers actually need this

If added later, **Option B (`binding<Type>`)** has best consistency with inline type display.

See §6.7 (Open Questions) for full decision log.

---

