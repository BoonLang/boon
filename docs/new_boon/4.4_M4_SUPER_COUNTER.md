# Milestone 4: Super-Counter

**Status**: Not Started

## Overview

Build the complete super-counter demonstration: a physical button on an iCESugar FPGA board triggers a counter update on a Raspberry Pi backend, which notifies all connected clients (web app, CLI, and the FPGA LED) via reactive dataflow. Includes basic boon-console to visualize events flowing across all platforms.

---

## Success Criteria

- [ ] Physical button on iCESugar board works
- [ ] Raspberry Pi backend receives button press
- [ ] Database stores counter value persistently
- [ ] Web app displays and updates counter
- [ ] CLI tool shows counter and runs commands
- [ ] FPGA LED responds to counter state
- [ ] All clients stay synchronized in real-time
- [ ] Basic boon-console shows events across all clients

---

## Dependencies

- **Requires**: M0 (Boon CLI) - for server runtime and CLI client
- **Requires**: M3 (FPGA Transpiler) - for FPGA button/LED
- **Enables**: Proof that Boon works across hardware + software, M10 (full boon-console)

---

## Database Integration

**Technology choice: SQLite**

| Option | Pros | Cons |
|--------|------|------|
| SQLite | Embedded, no external deps, Raspberry Pi friendly | Single-writer limitation |
| PostgreSQL | Concurrent writes, more features | Requires separate process, overkill for counter |
| File-based JSON | Simplest | No ACID, corruption risk |

**Decision: SQLite** - Embedded database requires no external dependencies, works well on Raspberry Pi, and provides ACID guarantees for counter persistence.

**Connection pattern:**

```rust
pub struct DatabaseConfig {
    pub path: PathBuf,              // e.g., "./data/super_counter.db"
    pub connection_pool_size: usize, // Default: 1 (SQLite is single-writer)
}

pub trait PersistenceBackend: Send + Sync {
    fn get_counter(&self) -> Result<i64, Error>;
    fn set_counter(&self, value: i64) -> Result<(), Error>;
    fn increment_counter(&self, delta: i64) -> Result<i64, Error>;
}

pub struct SqliteBackend {
    conn: rusqlite::Connection,
}

impl SqliteBackend {
    pub fn new(config: &DatabaseConfig) -> Result<Self, Error> {
        let conn = rusqlite::Connection::open(&config.path)?;

        // Create table if not exists
        conn.execute(
            "CREATE TABLE IF NOT EXISTS state (
                key TEXT PRIMARY KEY,
                value INTEGER NOT NULL
            )",
            [],
        )?;

        // Initialize counter if not exists
        conn.execute(
            "INSERT OR IGNORE INTO state (key, value) VALUES ('counter', 0)",
            [],
        )?;

        Ok(Self { conn })
    }
}

impl PersistenceBackend for SqliteBackend {
    fn increment_counter(&self, delta: i64) -> Result<i64, Error> {
        self.conn.execute(
            "UPDATE state SET value = value + ? WHERE key = 'counter'",
            [delta],
        )?;

        let value: i64 = self.conn.query_row(
            "SELECT value FROM state WHERE key = 'counter'",
            [],
            |row| row.get(0),
        )?;

        Ok(value)
    }
}
```

**Migration from M0 file storage:**

M0's CLI uses simple file-based persistence for local state. M4 migrates to SQLite:

| M0 (CLI) | M4 (Server) |
|----------|-------------|
| JSON file per variable | SQLite database |
| Read on startup | Connection pool |
| Write on change | Transaction per update |
| Local only | Shared across clients |

The `PersistenceBackend` trait allows swapping implementations for different milestones.

---

## Key Features

| Feature | Description |
|---------|-------------|
| FPGA button | Physical input on iCESugar board |
| Pi backend | Moon server with database |
| Reactive sync | All clients update via streams |
| Multi-platform | Web, CLI, and hardware unified |
| Persistence | Counter survives restarts |
| Basic boon-console | Watch events flow across platforms |

---

## Architecture

```
                    ┌─────────────────────┐
                    │   Raspberry Pi      │
                    │   (Moon Server)     │
                    │   + Database        │
                    └─────────┬───────────┘
                              │
          ┌───────────────────┼───────────────────┐
          │                   │                   │
    ┌─────┴─────┐      ┌──────┴──────┐     ┌──────┴──────┐
    │  Web App  │      │  CLI Tool   │     │   iCESugar  │
    │ (Browser) │      │  (Native)   │     │    (FPGA)   │
    └───────────┘      └─────────────┘     └─────────────┘
          │                   │                   │
          └───────────────────┼───────────────────┘
                              │
                    ┌─────────┴─────────┐
                    │   boon-console    │
                    │  (Event Viewer)   │
                    └───────────────────┘
```

---

## Basic boon-console (M4 Scope)

The super-counter needs visibility into what's happening across all platforms. Basic boon-console provides:

| Feature | Description |
|---------|-------------|
| Event log | Text stream of events from all clients |
| Connection status | Which clients are connected |
| Message flow | See button press → server → all clients |
| Simple UI | Terminal-based or basic web panel |

**Not in M4 scope** (deferred to M10):
- 3D graph visualization
- Time-travel debugging
- State inspection
- Breakpoints

---

## Debug Protocol (Foundation for M10)

Each client exposes a debug endpoint:

```json
// Event: Button pressed on FPGA
{"type": "event", "source": "fpga", "name": "button_press", "time": 1234567890}

// Event: Server received
{"type": "event", "source": "server", "name": "increment", "count": 42}

// Event: Client updated
{"type": "event", "source": "web", "name": "state_update", "count": 42}
```

This protocol becomes the foundation for M10's full boon-console.

---

## Testing Strategy

- Hardware-in-the-loop tests with actual FPGA
- Network latency and reliability tests
- Database persistence tests
- Multi-client synchronization tests
- boon-console event verification (all events visible)

---

## Related Documentation

- README.md - super-counter project vision
- §3.3 Cross-Platform - platform abstraction
- §6.8 Protocols - UART, WebSocket, and debug protocol specs
- M0 - Provides CLI runtime foundation
- M10 - Full boon-console builds on this foundation

---

## boon serve (Implemented in M4)

`boon serve` is implemented as part of M4, not M0. It requires:
- WebSocket infrastructure for client sync
- Database integration for persistence
- HTTP API for web app

M0 provides the CLI foundation (`boon run`, `boon eval`, `boon test`) which M4 builds upon.
