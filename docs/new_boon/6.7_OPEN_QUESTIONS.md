# Open Questions & Architectural Gaps

These are design questions identified during analysis. This file serves as a **consolidated decision log** - showing what was considered and why. Implementation details are embedded in the relevant main docs (e.g., FLUSH isolation in §2.6, FIFO ordering in §2.7).

---

## Memory Management

### Q1: Arena Garbage Collection Strategy

The arena grows but there's no defined strategy for:
- When to compact the arena
- How to handle fragmentation
- Memory limits on mobile devices
- What happens when arena exceeds available memory

**Decision: DEFER** - Start simple with no GC. Add garbage collection later when real memory issues arise in practice. This keeps initial implementation simple.

### Q2: Mobile Memory Pressure

iOS Safari has aggressive memory limits. Should there be:
- Memory budgets per app?
- Warning callbacks before memory exhaustion?
- Eviction strategies for least-used nodes?

**Decision: DEFER** - Focus on WASM Browser (Boon playground) first. Tackle mobile memory constraints later when targeting mobile platforms.

---

## Error Handling

### Q3: FLUSH in List Operations

What happens when:
- One item in List/map flushes but others don't?
- FLUSH occurs in List/retain predicate?
- Can FLUSH be caught and recovered from?

**Decision: ITEM-LEVEL ISOLATION** - When one item in List/map flushes, only that item fails. Other items continue processing normally. This provides fault isolation within collections.

```rust
impl ListMapNode {
    fn process_item(&mut self, key: ItemKey, value: Payload) -> ItemResult {
        match self.transform(value) {
            Ok(result) => ItemResult::Ok(result),
            Err(Flushed(error_value)) => {
                // Item carries error value (e.g., ItemError[value: original])
                ItemResult::ItemFlushed { key, error: error_value }
            }
        }
    }
}

pub enum ItemResult {
    Ok(Payload),
    ItemFlushed { key: ItemKey, error: Payload },  // Error payload preserved
}
```

### Q4: Error Recovery Pattern

FLUSH is fail-fast. What's the pattern for:
- Retrying failed network requests?
- Showing error UI while allowing retry?
- Recovering from transient failures?

**Decision: DEFER** - Focus on happy path now. Add error recovery patterns (Result types, retry primitives) later when real-world usage reveals common patterns.

---

## Effect Ordering

### Q5: Effect Execution Order

Effects are collected during tick and "executed at tick end." But:
- In what order? (FIFO? Priority? Deterministic?)
- What if Effect A depends on Effect B completing?
- What if network effects take multiple ticks?

**Decision: FIFO** - Effects execute in the order they were queued during the tick. This provides:
- **Determinism** - Same input produces same effect order (consistent with node propagation ordering)
- **Intuition** - Effects happen in code/trigger order
- **Performance** - Vec push/drain is O(1)/O(n), cache-friendly, no heap overhead

```rust
impl EventLoop {
    pending_effects: Vec<NodeEffect>,  // FIFO queue

    fn queue_effect(&mut self, effect: NodeEffect) {
        self.pending_effects.push(effect);  // O(1)
    }

    fn execute_pending_effects(&mut self) {
        for effect in self.pending_effects.drain(..) {  // Linear, in order
            self.execute_effect(effect);
        }
    }
}
```

**Note:** If Effect A depends on Effect B completing (e.g., network request), that's a multi-tick dependency handled via callbacks/responses, not same-tick ordering.

### Q6: Animation System

Elements have styles but no animation system:
- Transitions?
- Keyframe animations?
- Spring physics?
- Gesture-driven animations?

**Decision: DEFER** - No animation support initially. Add animation system later when needed. CSS transitions can be used via style properties in the meantime.

---

## Cross-Domain

### Q7: Message Ordering Guarantees

TransportEdge has sequence numbers but:
- Are messages from same source guaranteed in order?
- What about messages from different sources to same target?
- How does this interact with "deterministic execution"?

**Decision: SAME-SOURCE FIFO** - Messages from the same source are guaranteed to arrive in order. Messages from different sources may interleave. This matches common network semantics and TCP ordering guarantees.

```rust
impl TransportEdge {
    // Sequence numbers ensure same-source ordering
    fn send(&mut self, msg: Message) {
        let seq = self.next_seq;
        self.next_seq += 1;
        self.pending_acks.push_back((seq, msg));
    }

    // Receiver processes in sequence order
    fn receive(&mut self, seq: u64, msg: Message) {
        if seq == self.expected_seq {
            self.deliver(msg);
            self.expected_seq += 1;
        } else {
            self.buffer(seq, msg);  // Out of order, buffer for later
        }
    }
}
```

---

## Platform-Specific

### Q8: Accessibility (a11y)

Element functions create DOM elements but no mention of:
- ARIA attributes
- Keyboard navigation
- Screen reader support
- Focus management

**Decision: DEFER** - Focus on functionality first. Add accessibility support as a separate pass later. Zoon may already handle some a11y concerns.

### Q9: Internationalization (i18n)

TEXT interpolation exists but no discussion of:
- Translation key lookup
- Pluralization rules
- RTL support
- Date/number formatting

**Decision: DEFER** - No i18n support initially. Add i18n capabilities later when internationalization becomes a requirement.

---

## Design Rationale

### Q10: Why Arena Over Alternatives?

The docs don't explain:
- Why arena instead of generational indices with indirection?
- Why message passing instead of direct reads?
- Why custom serialization approach?

**Decision: ADD RATIONALE SECTION** - Document why arena was chosen. Key reasons:
1. **Snapshot-ability** - Full graph can be serialized for persistence/debugging
2. **Simplicity** - Direct SlotId indexing, no indirection complexity
3. **Hardware model** - Maps naturally to register/wire mental model
4. **Locality** - Nodes in contiguous memory for cache efficiency

### Q11: Hardware Model Clarity

The "hardware-inspired" design uses Vec/HashMap. Clarify:
- What aspects ARE hardware-like? (dataflow, determinism, node identity)
- What aspects are runtime-specific? (dynamic allocation, HashMap lookup)
- How will FPGA subset differ?

**Decision: ALREADY CLARIFIED** - This was addressed in Issue 3, now merged into 1.1_GETTING_STARTED.md. The "Hardware-Inspired Design Clarification" section explains the distinction.

---

## Implementation Questions

### Q12: TypedStream Integration

CLAUDE.md mentions TypedStream<S, Infinite/Finite>. How does this relate to new engine? Is it:
- Carried forward to new engine?
- Replaced by something else?
- Only for old engine?

**Decision: OLD ENGINE ONLY** - TypedStream is specific to the old actor-based engine. The new arena-based engine doesn't use this pattern. CLAUDE.md should mark this as old-engine-specific.

### Q13: Build Time Performance

What are acceptable build times for:
- Small files (<100 LOC)?
- Medium files (100-500 LOC)?
- Large files (500+ LOC)?

**Decision: NO TARGETS** - Don't set specific build time targets. Optimize when performance becomes a problem in practice. This avoids premature optimization.

### Q14: Hot Reload Limits

When hot reload can't preserve state, what's the fallback?
- Show warning and reset?
- Partial preservation?
- User confirmation required?

**Decision: WARNING + RESET** - Initially, show a console warning and reset to initial state when preservation isn't possible. Later, need more robust solution for business data that may be stored in state (partial preservation, user confirmation, etc.).

```rust
impl HotReloadOrchestrator {
    fn handle_incompatible_change(&self, node: SourceId) -> ReloadAction {
        console_warn!("Hot reload: Cannot preserve state for {:?}, resetting", node);
        ReloadAction::Reset
    }
}
```

---

## Summary

| Question | Category | Decision |
|----------|----------|----------|
| Q1 | Memory | Defer - add GC when needed |
| Q2 | Memory | Defer - focus on desktop |
| Q3 | Error | Item-level FLUSH isolation |
| Q4 | Error | Defer - happy path first |
| Q5 | Effects | FIFO order |
| Q6 | Effects | Defer - no animation initially |
| Q7 | Cross-Domain | Same-source FIFO |
| Q8 | Platform | Defer - functionality first |
| Q9 | Platform | Defer - no i18n initially |
| Q10 | Rationale | Add documentation section |
| Q11 | Rationale | Already clarified |
| Q12 | Impl | Old engine only |
| Q13 | Impl | No targets |
| Q14 | Impl | Warning + reset |
| Q15 | Tooling | Defer - design when enough Boon code exists |
| Q16 | Type System | Defer - generic variance |
| Q17 | Type System | Defer - recursive types |
| Q18 | Type System | Defer - type aliases |
| Q19 | Type System | Defer - type matching in WHEN/WHILE |
| Q20 | Diagnostics | Defer - GUI visualization (CLI first) |
| Q21 | Diagnostics | Defer - protobuf upgrade (JSON first) |
| Q22 | Diagnostics | Defer - FPGA transport (after transpiler) |
| Q23 | Diagnostics | Defer - authentication (localhost first) |
| Q24 | State Evolution | Defer - drained key GC |
| Q25 | State Evolution | Defer - cross-domain timeout |
| Q26 | State Evolution | Defer - list item key format |
| Q27 | State Evolution | Defer - cross-module versions |
| Q28 | Hot-Reload | **Documented** - see §3.7 |

---

## Tooling

### Q15: Boon Formatter

Should Boon have an opinionated formatter (like `gofmt`, `rustfmt`)? Design questions:
- How opinionated? (single style vs configurable)
- Indentation style (spaces/tabs, width)
- Line length limits
- Expression breaking rules
- Comment formatting

**Decision: DEFER** - Design the formatter once we have a sufficient amount of Boon code to inform the decisions. Real-world usage patterns will reveal what formatting choices make sense.

---

## Type System (§2.9)

### Q16: Generic Variance

Should `List<T>` be covariant, contravariant, or invariant in T?
- Covariant: `List<Dog>` is subtype of `List<Animal>`
- Invariant: No subtyping relationship

**Decision: DEFER** - Currently using exact matching (no width subtyping for objects). When we add variance, need to consider implications for type safety with mutable collections.

### Q17: Recursive Types

Should Boon support self-referential types like linked lists?

```boon
// Hypothetical recursive type
node: [value: Number, next: Node | Null]
```

**Decision: DEFER** - Most Boon dataflow uses flat structures. Recursive types rare in reactive UI code. Add when needed for specific use cases.

### Q18: Type Aliases

Should Boon support named type abbreviations?

```boon
// Hypothetical type alias
type TodoItem = [id: Number, text: Text, completed: Bool]
```

**Decision: DEFER** - Structural typing means types are already "named" by their structure. Aliases would be documentation/convenience feature, not essential for type checking.

### Q19: Type Matching in WHEN/WHILE

Should WHEN/WHILE support matching by primitive types for unions like `Number | Text`?

```boon
// Hypothetical - match by type
value |> WHEN {
    <Text> text => TEXT { String: {text} }
    <Number> n => TEXT { Number: {n} }
}
```

**Syntax options considered:**

| Option | Syntax | Example | Pros | Cons |
|--------|--------|---------|------|------|
| A | `<Type> binding` | `<Text> text =>` | Clear type annotation | New syntax, `<` conflicts |
| B | `binding<Type>` | `text<Text> =>` | Matches inline display | Looks like comparison |
| C | `Type binding` | `Text text =>` | No new syntax | Ambiguous with tags |

**Decision: DEFER** - Multiple reasons:

1. **Rare use case** - Boon's typed dataflow rarely produces primitive unions like `Number | Text`
2. **TaggedObject alternative works today:**
   ```boon
   // Instead of Number | Text, use explicit wrappers:
   IntValue[value: Number] | TextValue[value: Text]

   data |> WHEN {
       IntValue v => v.value + 1
       TextValue v => Text/length(v.value)
   }
   ```
3. **Syntax complexity** - All options have significant trade-offs
4. **Wait for real usage** - Add when developers demonstrate actual need

If added later, Option B (`binding<Type>`) recommended for consistency with inline type display.

---

## Runtime Diagnostics (§3.5)

### Q20: GUI Visualization

Should boon-console have a graphical interface (TUI or web-based) for visualizing the reactive graph?

**Desired features:**
- Factorio-like visualization of data flow
- Interactive node inspection
- Live value updates with animations
- Zoom/pan through large graphs

**Decision: DEFER** - Start with CLI tool for AI/tool integration. Add TUI (using ratatui) later when CLI is stable. Web-based visualization is a separate future project.

### Q21: Protobuf Protocol Upgrade

Should we upgrade from JSON to Protocol Buffers for the diagnostics wire protocol?

**Considerations:**
- Protobuf: More efficient binary format, stronger typing, language-agnostic
- JSON: Simpler to debug, works natively in browser, AI-friendly

**Decision: DEFER** - Start with JSON over WebSocket for simplicity. Design JSON schema to be protobuf-compatible. Upgrade when performance becomes a concern (high-frequency streaming).

### Q22: FPGA Diagnostics Transport

How should diagnostics work for FPGA-synthesized Boon graphs?

**Options:**
- JTAG debug interface reading trace buffers
- Memory-mapped debug registers
- Hardware logic analyzer integration
- Side-channel output port

**Decision: DEFER** - FPGA synthesis (§5.1) is not yet implemented. Design FPGA diagnostics transport when the transpiler is ready.

### Q23: Diagnostics Security

Should the diagnostics server require authentication?

**Considerations:**
- Localhost-only by default (safe for development)
- Remote access needs authentication (production debugging)
- Potential for leaking sensitive data in value streams

**Decision: DEFER** - Start localhost-only. Add optional authentication (bearer tokens) when remote debugging becomes a requirement.

---

## State Evolution (§3.6)

### Q24: Drained Storage Key Garbage Collection

When should old storage keys (from drained variables) be garbage collected?

**Options:**
- Immediate: Remove after drain completes
- Delayed: Keep for rollback period (e.g., 7 days)
- Manual: User explicitly triggers cleanup

**Decision: DEFER** - Keep drained keys for now. Design GC strategy when storage limits become a concern.

### Q25: Cross-Domain Drain Timeout

What happens if cross-domain drain times out (network failure, slow transfer)?

**Options:**
- Retry with exponential backoff
- Fail and keep source active
- Partial transfer (what was received)

**Decision: DEFER** - Fail and keep source active for now. Design retry/recovery strategy when cross-domain is implemented.

### Q26: List Item Key Persistence Format

Should invisible list item keys use sequential integers or ULIDs?

**Considerations:**
- Sequential: Simpler, more compact, but may collide across restarts
- ULID: Unique across all time, but larger storage footprint

**Decision: DEFER** - Use sequential integers within AllocSite. ULID only if collision issues arise in practice.

### Q27: DRAIN Across Module Versions

When DRAINING across modules, what if modules have different code versions?

**Considerations:**
- Source at v1, destination expects v2
- Type mismatch handling
- Coordinated module updates

**Decision: DEFER** - Require same-version modules for DRAIN initially. Design version negotiation when needed.

### Q28: Hot-Reload Flexibility & Matching Strategies

Which code changes should preserve state automatically vs require explicit DRAIN migration?

**Considerations:**
- Name-based vs structural hash for identity matching
- LIST/LATEST position-based vs content-based matching
- WHEN/WHILE arm body matching
- Function argument matching
- Stateful function removal

**Decision: DOCUMENTED** - Comprehensive analysis in §3.7 Hot-Reload Flexibility. Key decisions:
- Use **name-based matching** (better than structural hash for config changes, reordering)
- Use **content-based matching** for LIST/LATEST items (with position tiebreaker for duplicates)
- Use **structural pattern matching** for WHEN/WHILE arms
- Use **name-based matching** for function arguments
- **Warn** when stateful functions removed, HOLD renamed, or type changes
- **No silent state loss** - either automatic preservation or warning shown

See §3.7 for complete gotcha list, edge cases, and implementation priorities.

---
