# Open Questions & Architectural Gaps

These are design questions identified during analysis. This file serves as a **consolidated decision log** - showing what was considered and why. Implementation details are embedded in the relevant main docs (e.g., FLUSH isolation in ยง2.6, FIFO ordering in ยง2.7).

---

## Memory Management

### Q1: Arena Garbage Collection Strategy

The arena grows but there's no defined strategy for:
- When to compact the arena
- How to handle fragmentation
- Memory limits on mobile devices
- What happens when arena exceeds available memory

**Decision: DEFER** - Start simple with no GC. Add garbage collection later when real memory issues arise in practice. This keeps initial implementation simple.

### Q2: Mobile Memory Pressure

iOS Safari has aggressive memory limits. Should there be:
- Memory budgets per app?
- Warning callbacks before memory exhaustion?
- Eviction strategies for least-used nodes?

**Decision: DEFER** - Focus on WASM Browser (Boon playground) first. Tackle mobile memory constraints later when targeting mobile platforms.

---

## Error Handling

### Q3: FLUSH in List Operations

What happens when:
- One item in List/map flushes but others don't?
- FLUSH occurs in List/retain predicate?
- Can FLUSH be caught and recovered from?

**Decision: ITEM-LEVEL ISOLATION** - When one item in List/map flushes, only that item fails. Other items continue processing normally. This provides fault isolation within collections.

```rust
impl ListMapNode {
    fn process_item(&mut self, key: ItemKey, value: Payload) -> ItemResult {
        match self.transform(value) {
            Ok(result) => ItemResult::Ok(result),
            Err(Flush) => ItemResult::ItemFlushed(key),  // Only this item fails
        }
    }
}
```

### Q4: Error Recovery Pattern

FLUSH is fail-fast. What's the pattern for:
- Retrying failed network requests?
- Showing error UI while allowing retry?
- Recovering from transient failures?

**Decision: DEFER** - Focus on happy path now. Add error recovery patterns (Result types, retry primitives) later when real-world usage reveals common patterns.

---

## Effect Ordering

### Q5: Effect Execution Order

Effects are collected during tick and "executed at tick end." But:
- In what order? (FIFO? Priority? Deterministic?)
- What if Effect A depends on Effect B completing?
- What if network effects take multiple ticks?

**Decision: UNSPECIFIED** - Effect execution order is not guaranteed. Users should not depend on order. This allows for simpler implementation and future optimization without breaking changes.

### Q6: Animation System

Elements have styles but no animation system:
- Transitions?
- Keyframe animations?
- Spring physics?
- Gesture-driven animations?

**Decision: DEFER** - No animation support initially. Add animation system later when needed. CSS transitions can be used via style properties in the meantime.

---

## Cross-Domain

### Q7: Message Ordering Guarantees

TransportEdge has sequence numbers but:
- Are messages from same source guaranteed in order?
- What about messages from different sources to same target?
- How does this interact with "deterministic execution"?

**Decision: SAME-SOURCE FIFO** - Messages from the same source are guaranteed to arrive in order. Messages from different sources may interleave. This matches common network semantics and TCP ordering guarantees.

```rust
impl TransportEdge {
    // Sequence numbers ensure same-source ordering
    fn send(&mut self, msg: Message) {
        let seq = self.next_seq;
        self.next_seq += 1;
        self.pending_acks.push_back((seq, msg));
    }

    // Receiver processes in sequence order
    fn receive(&mut self, seq: u64, msg: Message) {
        if seq == self.expected_seq {
            self.deliver(msg);
            self.expected_seq += 1;
        } else {
            self.buffer(seq, msg);  // Out of order, buffer for later
        }
    }
}
```

---

## Platform-Specific

### Q8: Accessibility (a11y)

Element functions create DOM elements but no mention of:
- ARIA attributes
- Keyboard navigation
- Screen reader support
- Focus management

**Decision: DEFER** - Focus on functionality first. Add accessibility support as a separate pass later. Zoon may already handle some a11y concerns.

### Q9: Internationalization (i18n)

TEXT interpolation exists but no discussion of:
- Translation key lookup
- Pluralization rules
- RTL support
- Date/number formatting

**Decision: DEFER** - No i18n support initially. Add i18n capabilities later when internationalization becomes a requirement.

---

## Design Rationale

### Q10: Why Arena Over Alternatives?

The docs don't explain:
- Why arena instead of generational indices with indirection?
- Why message passing instead of direct reads?
- Why custom serialization approach?

**Decision: ADD RATIONALE SECTION** - Document why arena was chosen. Key reasons:
1. **Snapshot-ability** - Full graph can be serialized for persistence/debugging
2. **Simplicity** - Direct SlotId indexing, no indirection complexity
3. **Hardware model** - Maps naturally to register/wire mental model
4. **Locality** - Nodes in contiguous memory for cache efficiency

### Q11: Hardware Model Clarity

The "hardware-inspired" design uses Vec/HashMap. Clarify:
- What aspects ARE hardware-like? (dataflow, determinism, node identity)
- What aspects are runtime-specific? (dynamic allocation, HashMap lookup)
- How will FPGA subset differ?

**Decision: ALREADY CLARIFIED** - This was addressed in Issue 3, now merged into 1.1_GETTING_STARTED.md. The "Hardware-Inspired Design Clarification" section explains the distinction.

---

## Implementation Questions

### Q12: TypedStream Integration

CLAUDE.md mentions TypedStream<S, Infinite/Finite>. How does this relate to new engine? Is it:
- Carried forward to new engine?
- Replaced by something else?
- Only for old engine?

**Decision: OLD ENGINE ONLY** - TypedStream is specific to the old actor-based engine. The new arena-based engine doesn't use this pattern. CLAUDE.md should mark this as old-engine-specific.

### Q13: Build Time Performance

What are acceptable build times for:
- Small files (<100 LOC)?
- Medium files (100-500 LOC)?
- Large files (500+ LOC)?

**Decision: NO TARGETS** - Don't set specific build time targets. Optimize when performance becomes a problem in practice. This avoids premature optimization.

### Q14: Hot Reload Limits

When hot reload can't preserve state, what's the fallback?
- Show warning and reset?
- Partial preservation?
- User confirmation required?

**Decision: WARNING + RESET** - Initially, show a console warning and reset to initial state when preservation isn't possible. Later, need more robust solution for business data that may be stored in state (partial preservation, user confirmation, etc.).

```rust
impl HotReloadOrchestrator {
    fn handle_incompatible_change(&self, node: SourceId) -> ReloadAction {
        console_warn!("Hot reload: Cannot preserve state for {:?}, resetting", node);
        ReloadAction::Reset
    }
}
```

---

## Summary

| Question | Category | Decision |
|----------|----------|----------|
| Q1 | Memory | Defer - add GC when needed |
| Q2 | Memory | Defer - focus on desktop |
| Q3 | Error | Item-level FLUSH isolation |
| Q4 | Error | Defer - happy path first |
| Q5 | Effects | Unspecified order |
| Q6 | Effects | Defer - no animation initially |
| Q7 | Cross-Domain | Same-source FIFO |
| Q8 | Platform | Defer - functionality first |
| Q9 | Platform | Defer - no i18n initially |
| Q10 | Rationale | Add documentation section |
| Q11 | Rationale | Already clarified |
| Q12 | Impl | Old engine only |
| Q13 | Impl | No targets |
| Q14 | Impl | Warning + reset |
| Q15 | Tooling | Defer - design when enough Boon code exists |

---

## Tooling

### Q15: Boon Formatter

Should Boon have an opinionated formatter (like `gofmt`, `rustfmt`)? Design questions:
- How opinionated? (single style vs configurable)
- Indentation style (spaces/tabs, width)
- Line length limits
- Expression breaking rules
- Comment formatting

**Decision: DEFER** - Design the formatter once we have a sufficient amount of Boon code to inform the decisions. Real-world usage patterns will reveal what formatting choices make sense.

---
