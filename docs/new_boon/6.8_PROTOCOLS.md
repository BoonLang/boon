# Chapter 6.8: Protocols

This document defines the communication protocols and data formats used across Boon platforms. All milestones reference this central specification.

---

## Value Serialization (JSON)

Boon values are serialized to JSON for persistence, debugging, and client-server communication.

### Two JSON Modes

| Mode | Purpose | Structure | When Used |
|------|---------|-----------|-----------|
| **Protocol JSON** | Round-trippable, type-preserving | `_type` wrapped | Snapshots, debugging, client-server sync |
| **Materialized JSON** | Human-readable, simple | Plain values | CLI output, golden tests |

**Protocol JSON** (this document): Preserves type information for faithful restoration.
**Materialized JSON** (see §CLI Semantics in plan): Converts to simplest possible JSON.

```
// Boon value
[name: "Alice", age: 30]

// Protocol JSON (for persistence/debugging)
{"_type": "object", "fields": {"name": "Alice", "age": 30}}

// Materialized JSON (for CLI output)
{"name": "Alice", "age": 30}
```

**Implementation note:** Protocol JSON uses **custom serialization**, NOT `#[derive(Serialize)]`.
```rust
// Protocol JSON requires explicit serialization to control format
impl Payload {
    pub fn to_protocol_json(&self) -> serde_json::Value {
        match self {
            Payload::Number(n) => json!(n),
            Payload::Text(s) => json!(s),
            Payload::Bool(b) => json!(b),
            Payload::Unit => json!(null),
            Payload::ObjectHandle(slot) => json!({
                "_type": "object",
                "fields": /* serialize fields */
            }),
            Payload::ListHandle(slot) => json!({
                "_type": "list",
                "items": /* serialize items */
            }),
            Payload::Tag(id) => json!({
                "_type": "tag",
                "name": INTERN_TABLE.get_name(*id)
            }),
            Payload::TaggedObject { tag, fields } => json!({
                "_type": "tagged_object",
                "tag": INTERN_TABLE.get_name(*tag),
                "fields": /* serialize fields from Router */
            }),
            // ...
        }
    }
}

// Materialized JSON is simpler - unwraps containers
impl Payload {
    pub fn to_materialized_json(&self) -> serde_json::Value {
        match self {
            Payload::ObjectHandle(slot) => {
                let obj = /* get object fields */;
                json!(obj)  // Plain JSON object, no "_type"
            }
            Payload::TaggedObject { tag, fields } => {
                // Materialized: {"Duration": {"seconds": 1}}
                let tag_name = INTERN_TABLE.get_name(*tag);
                let fields_obj = /* materialize fields */;
                json!({ tag_name: fields_obj })
            }
            // ...
        }
    }
}
```

**Rust struct serialization:** Internal types like `GraphSnapshot` and `NodeSnapshot`
use standard `#[derive(Serialize, Deserialize)]` - they're not exposed to users.

### Primitive Types

| Boon Type | JSON Representation | Example |
|-----------|---------------------|---------|
| Number | `number` | `42`, `3.14` |
| Text | `string` | `"hello"` |
| Bool | `boolean` | `true`, `false` |
| Unit | `null` | `null` (signal with no data, e.g., DOM events) |

**Notes:**
- `Bool` in Boon is written as `True`/`False` tags but runtime uses `Payload::Bool(bool)` for efficiency
- `Unit` in Boon is written as `[]` (unit literal, NOT empty object) and becomes `Payload::Unit` at runtime
- Empty object (rare): use `[:]` syntax if truly needed (see §2.9 for Unit vs Object distinction)

**Unit vs Nothing (important distinction):**

| Concept | Boon Syntax | Runtime | JSON | Meaning |
|---------|-------------|---------|------|---------|
| **Unit** | `[]` | `Payload::Unit` | `null` | A value exists (signal with no data, e.g., button press) |
| **Nothing** | N/A | Node doesn't emit | N/A | No value yet (node hasn't produced output) |

"Nothing" is NOT a `Payload` variant. It's the absence of emission from a reactive node. This distinction matters for:
- `HOLD`: Initial value is always present (never "nothing")
- `WHEN`: Matched arm emits a value, unmatched means "nothing" (no emission)
- Protocol: Snapshots only serialize nodes that have emitted (no "nothing" in JSON)

**Avoiding null collision in snapshots:**
Since `Option<SerializablePayload>` could serialize `None` as `null` (colliding with Unit), use:
```rust
#[serde(skip_serializing_if = "Option::is_none")]
pub current_value: Option<SerializablePayload>,
```
This omits the field entirely when there's no value (Nothing), while `Unit` still serializes as `null`.

### Compound Types

**Object:**
```json
{
  "_type": "object",
  "fields": {
    "name": "Alice",
    "age": 30
  }
}
```

**Tagged Object:**
```json
{
  "_type": "tagged_object",
  "tag": "Duration",
  "fields": {"milliseconds": 1000}
}
```

**List:**
```json
{
  "_type": "list",
  "items": [1, 2, 3]
}
```

**Function (reference only, not serializable):**
```json
{
  "_type": "function",
  "id": "fn_123",
  "name": "add"
}
```

### Node Identification

Protocol JSON uses **NodeAddress** for stable node references (not SlotId which is arena-local).

**Canonical format (matches §2.1):**
```json
{
  "domain": "Main",
  "source_id": {"stable_id": 42, "parse_order": 1},
  "scope_id": 123,
  "port": {"type": "output"}
}
```

**Port variants (see §2.1.3):**
```json
{"type": "output"}              // Default output
{"type": "input", "n": 0}       // First input
{"type": "field", "id": 42}     // Object field
```

**Simplified format for examples:** When `domain` is `Main` and `parse_order` is unimportant, examples may use shortened notation for readability:
```json
{"source_id": 42, "scope_id": 123, "port": {"type": "output"}}
```

**Shorthand format for debugging:** `"42:123:output"` (source:scope:port)

### Delta Types (ListDelta, ObjectDelta)

For efficient reactive updates, containers emit deltas instead of full values:

**ListDelta:**
```json
{
  "_type": "list_delta",
  "operation": "insert" | "remove" | "update" | "move",
  "key": "item_key_abc",           // ItemKey for item identity
  "index": 2,                       // Position (for insert/move)
  "value": { ... },                 // Payload (for insert/update)
  "from_index": 1,                  // For move operations
  "to_index": 3
}
```

**ObjectDelta:**
```json
{
  "_type": "object_delta",
  "operation": "set" | "remove",
  "field": "name",
  "value": "Alice"                  // Payload (for set)
}
```

### Reactive Types

**Stream reference:**
```json
{
  "_type": "stream",
  "address": {"source_id": 42, "scope_id": 123, "port": {"type": "output"}},
  "current_value": 5
}
```

---

## Debug Protocol

Used by boon-console (M4 basic, M10 full) to inspect running Boon applications.

**Node identification:** Uses same format as §3.5 Diagnostics - full NodeAddress with slot_id for arena location.

### Events (Runtime → Console)

**Node created:**
```json
{
  "type": "node_created",
  "address": {
    "source_id": {"stable_id": 42, "parse_order": 1},
    "scope_id": 123,
    "port": {"type": "output"}
  },
  "slot_id": {"index": 42, "generation": 1},
  "kind": "Register",
  "name": "counter",
  "source_location": {"line": 10, "column": 5}
}
```

**Message sent:**
```json
{
  "type": "message",
  "from": {"source_id": 12, "scope_id": 100, "port": {"type": "output"}},
  "to": {"source_id": 42, "scope_id": 123, "port": {"type": "input", "n": 0}},
  "payload": {"count": 5},
  "timestamp": 1703424000000
}
```

**State changed:**
```json
{
  "type": "state_changed",
  "address": {"source_id": 42, "scope_id": 123, "port": {"type": "output"}},
  "old": {"count": 4},
  "new": {"count": 5}
}
```

**Node destroyed:**
```json
{
  "type": "node_destroyed",
  "address": {"source_id": 42, "scope_id": 123, "port": {"type": "output"}}
}
```

### Commands (Console → Runtime)

**Inspect node:**
```json
{
  "cmd": "inspect",
  "address": {"source_id": 42, "scope_id": 123, "port": {"type": "output"}}
}
```

**Response:**
```json
{
  "type": "inspect_result",
  "address": {"source_id": 42, "scope_id": 123, "port": {"type": "output"}},
  "slot_id": {"index": 42, "generation": 1},
  "kind": "Register",
  "value": {"count": 5},
  "subscribers": [
    {"source_id": 43, "scope_id": 123, "port": {"type": "input", "n": 0}},
    {"source_id": 44, "scope_id": 123, "port": {"type": "input", "n": 0}}
  ]
}
```

**Pause/Resume:**
```json
{"cmd": "pause"}
{"cmd": "resume"}
```

**Set breakpoint:**
```json
{
  "cmd": "breakpoint",
  "action": "add",
  "address": {"source_id": 42, "scope_id": 123, "port": {"type": "output"}},
  "on": "state_change"
}
```

---

## Client-Server Protocol (WebSocket)

Used by super-counter (M4) for real-time synchronization.

### Connection

- Endpoint: `ws://host:port/boon`
- Subprotocol: `boon-sync-v1`

### Messages

**Subscribe to stream:**
```json
{
  "action": "subscribe",
  "stream": "counter",
  "request_id": "req_1"
}
```

**Subscription confirmed:**
```json
{
  "type": "subscribed",
  "stream": "counter",
  "request_id": "req_1",
  "current_value": 42
}
```

**Value update (server → client):**
```json
{
  "type": "update",
  "stream": "counter",
  "value": 43,
  "timestamp": 1703424000000
}
```

**Send event (client → server):**
```json
{
  "action": "send",
  "stream": "button_press",
  "value": {"source": "web"}
}
```

---

## FPGA Communication (UART)

Used by super-counter (M4) for FPGA ↔ Raspberry Pi communication.

### Physical Layer

- Baud rate: 115200
- Data bits: 8
- Stop bits: 1
- Parity: None
- Flow control: None

### Message Format

```
┌──────────┬──────────┬──────────────────┬──────────┐
│  START   │  LENGTH  │     PAYLOAD      │   CRC    │
│  0xAA    │  1 byte  │   N bytes        │  1 byte  │
└──────────┴──────────┴──────────────────┴──────────┘
```

### Message Types

| Type | Code | Direction | Description |
|------|------|-----------|-------------|
| BUTTON_PRESS | 0x01 | FPGA → Pi | Physical button pressed |
| COUNTER_UPDATE | 0x02 | Pi → FPGA | New counter value |
| LED_STATE | 0x03 | Pi → FPGA | Set LED on/off |
| HEARTBEAT | 0xFF | Both | Keep-alive |

### Examples

**Button press:**
```
AA 02 01 01 [CRC]  // Type=BUTTON_PRESS, button_id=1
```

**Counter update:**
```
AA 05 02 00 00 00 2A [CRC]  // Type=COUNTER_UPDATE, value=42 (little-endian u32)
```

---

## Persistence Format

Used for saving Boon application state (M1, M4, M7).

### File Format

```json
{
  "version": 1,
  "app_id": "super-counter",
  "timestamp": 1703424000000,
  "state": {
    "counter": 42,
    "last_update": "2024-12-24T12:00:00Z"
  },
  "node_states": {
    "42:123:output": {"count": 42},   // Key is NodeAddress shorthand (source:scope:port)
    "43:123:output": [1, 2, 3]
  }
}
// Note: Keys use NodeAddress shorthand format for stable persistence across arena rebuilds.
// SlotId (arena index) is NOT used as persistence key since it's not stable.
```

### Migration

When `version` changes, migration functions transform old state to new format. Details TBD as schema evolves.

---

## Related Documentation

- M4 - Super-Counter uses client-server and FPGA protocols
- M10 - boon-console uses debug protocol
- §2.5 Graph Snapshot - persistence internals
- §3.6 State Evolution - state migration
