## Chapter 2.7: Multi-Threading

### 2.7.1 Runtime Modes

Multi-threaded WASM requires COOP/COEP + SharedArrayBuffer. Many hosting setups don't support this.

```rust
pub enum RuntimeMode {
    SingleThreaded,                      // Default, works everywhere
    MultiThreaded { worker_count: u8 },  // Requires COOP/COEP headers
}

impl EventLoop {
    pub fn new(mode: RuntimeMode) -> Self {
        match mode {
            RuntimeMode::SingleThreaded => Self::new_single_threaded(),
            RuntimeMode::MultiThreaded { .. } => Self::new_multi_threaded(),
        }
    }
}
```

**Single-threaded mode** is the default. Multi-threading (Phase 9) is OPTIONAL and requires specific HTTP headers.

### 2.7.2 Worker Architecture

```
Main Thread (UI):
  - DOM event handling
  - UI rendering
  - Main arena (UI nodes)

Worker Thread(s):
  - CPU-heavy computation
  - Separate arena per worker
  - No DOM access
```

### 2.7.3 Lock-Free Constraint (CRITICAL)

**CRITICAL CONSTRAINT:** Browser will IMMEDIATELY KILL the page if main thread blocks.

**Frontend (Web Workers + SharedArrayBuffer):**
- Main thread: UI rendering, DOM events - CANNOT BLOCK
- Worker threads: Compute-heavy work
- Communication: Lock-free SPSC queues via SharedArrayBuffer atomics
- NO Mutex, NO RwLock, NO blocking channel operations

```rust
// FORBIDDEN on frontend - will cause browser to kill page:
mutex.lock();           // BLOCKS
rwlock.read();          // BLOCKS
channel.recv().await;   // BLOCKS (if no message)
thread::sleep();        // BLOCKS

// ALLOWED - lock-free operations only:
atomic.load(Ordering::Acquire);
atomic.store(value, Ordering::Release);
atomic.compare_exchange(...);
channel.try_recv();     // Non-blocking
channel.try_send();     // Non-blocking
```

**Lock-free message queue pattern:**
```rust
pub struct SPSCQueue<T> {
    buffer: SharedArrayBuffer,
    head: AtomicU32,  // Written by producer
    tail: AtomicU32,  // Written by consumer
}

impl<T> SPSCQueue<T> {
    // Non-blocking push - returns false if full
    fn try_push(&self, item: T) -> bool {
        let head = self.head.load(Ordering::Relaxed);
        let next_head = (head + 1) % self.capacity;
        if next_head == self.tail.load(Ordering::Acquire) {
            return false;  // Queue full
        }
        unsafe { self.write_slot(head, item); }
        self.head.store(next_head, Ordering::Release);
        true
    }

    // Non-blocking pop - returns None if empty
    fn try_pop(&self) -> Option<T> {
        let tail = self.tail.load(Ordering::Relaxed);
        if tail == self.head.load(Ordering::Acquire) {
            return None;  // Queue empty
        }
        let item = unsafe { self.read_slot(tail) };
        self.tail.store((tail + 1) % self.capacity, Ordering::Release);
        Some(item)
    }
}
```

**Backend (Server Cluster):**
- Multiple servers in cluster, each multi-threaded
- Can use blocking operations (Mutex, async channels)
- But prefer lock-free for performance
- Inter-server communication via network (WebSocket, gRPC)

**Design implication:** EventLoop must be 100% non-blocking:
- `run_tick()` processes available work and returns immediately
- Never waits for messages - uses `try_recv()`
- Browser schedules tick via `queueMicrotask` (reactive propagation) or `setTimeout` (timers)
- Note: `requestAnimationFrame` is NOT used for reactive scheduling (see ยง2.4.12)

### 2.7.4 SharedArrayBuffer for Zero-Copy Communication

Following MoonZoon's approach, use SharedArrayBuffer for efficient cross-worker communication:

**Required HTTP Headers (COOP/COEP):**
```rust
// In Moon server (backend)
response.headers.insert("Cross-Origin-Opener-Policy", "same-origin");
response.headers.insert("Cross-Origin-Embedder-Policy", "require-corp");
```

**Shared Memory Layout (see Issue 22 for full details):**
```rust
// IMPORTANT: Node state is NOT shared - only message queues!
pub struct SharedRegion {
    pub message_queues: [[AtomicU64; 1024]; MAX_WORKERS],  // SPSC queues
    pub dirty_bitmap: [AtomicU64; 1024],  // Cross-worker dirty notifications
    // NO nodes_region - nodes live in thread-local arenas
}
```

**Benefits:**
- Lock-free message passing between workers (Issue 28 requires NO locks on frontend)
- No serialization overhead for primitives via SharedArrayBuffer
- Node state stays thread-local (simpler, no complex atomic protocols)

### 2.7.5 Cross-Worker Message Protocol

For complex payloads (Text, Objects), fall back to postMessage:

```rust
#[derive(Serialize, Deserialize)]
pub struct WorkerMessage {
    pub source_worker: WorkerId,
    pub source_slot: SlotId,
    pub target_worker: WorkerId,
    pub target_slot: SlotId,
    pub payload: Payload,
}
```

**Routing:** Main thread routes cross-worker messages via `postMessage` for complex data, SharedArrayBuffer for primitives.

**Message Ordering Guarantee:**

Messages from the same source are guaranteed to arrive in order (FIFO). Messages from different sources may interleave. This matches common network semantics and TCP ordering guarantees.

```rust
impl TransportEdge {
    // Sequence numbers ensure same-source ordering
    fn send(&mut self, msg: Message) {
        let seq = self.next_seq;
        self.next_seq += 1;
        self.pending_acks.push_back((seq, msg));
    }

    // Receiver processes in sequence order
    fn receive(&mut self, seq: u64, msg: Message) {
        if seq == self.expected_seq {
            self.deliver(msg);
            self.expected_seq += 1;
        } else {
            self.buffer(seq, msg);  // Out of order, buffer for later
        }
    }
}
```

**Rationale:**
- Same-source FIFO is the minimum guarantee needed for correct reactive updates
- Multi-source ordering would require complex global sequencing (unnecessary overhead)
- Users should not depend on cross-source ordering - design for interleaving

### 2.7.6 Server Domain Constraints

`Domain::Server` exists but UI nodes have domain-specific constraints:

```rust
impl NodeKind {
    fn allowed_in_domain(&self, domain: Domain) -> bool {
        match (self, domain) {
            // UI nodes only on Main
            (NodeKind::Document | NodeKind::Element | NodeKind::IOPad, Domain::Server) => false,
            // Router/go_to has server-specific behavior
            (NodeKind::RouterGoTo, Domain::Server) => false,  // Or: HTTP redirect?
            _ => true,
        }
    }
}
```

**Compile-time check:** Reject UI nodes in server subgraphs.

### 2.7.7 Per-User/Session Isolation (Server)

Server domain requires session isolation - 500 users cannot collide:

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct SessionId(u64);  // From auth token or connection ID

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ServerNodeAddress {
    pub session_id: SessionId,   // Session isolation
    pub source_id: SourceId,
    pub scope_id: ScopeId,
    pub port: Port,
}

// For server domain, full address includes session
pub enum FullNodeAddress {
    Browser(NodeAddress),                    // Single user
    Server(ServerNodeAddress),               // Multi-user with session isolation
}
```

**Runtime per session:** Each session gets isolated scope tree rooted at `ScopeId::ROOT.child(session_id)`.

**Files to modify:**
- `crates/boon/src/platform/browser/engine.rs` - Multi-threading support

---

