# 2.11 Context Passing (PASS/PASSED)

## Overview

PASS/PASSED provides **implicit context threading** through function calls, similar to React Context or Scala implicit parameters. It allows data to flow through nested function calls without explicit parameter passing at each level.

**Key characteristics:**
- `PASS: value` - Sets context at call site
- `PASSED` - Accesses context inside functions
- Context **automatically propagates** through nested calls
- Enables clean separation between "what to render" (parameters) and "where to wire events" (context)

---

## Syntax

### Setting Context (PASS)

```boon
// At call site - provide implicit context
Document/new(root: root_element(PASS: [store: store]))

// Can pass any value type
outer_function(PASS: store)
render_ui(PASS: [theme: dark_theme, store: app_store])
```

### Accessing Context (PASSED)

```boon
FUNCTION root_element() {
    // Access entire context
    PASSED

    // Access nested fields
    PASSED.store
    PASSED.store.items
    PASSED.store.elements.item_input
}
```

### Forwarding Context

```boon
FUNCTION outer() {
    // Forward same context to nested call
    inner(PASS: PASSED)
}
```

#### Object Spread with PASSED (Future/Optional - Post-M1)

> **Note:** Object spread syntax `[..PASSED, ...]` is not used by any of the 23 validation examples (counter, todo_mvc, shopping_list, etc.). This feature is **optional for M1** and can be deferred to a later milestone. For M1, context replacement (not merging) is sufficient.

```boon
// FUTURE: Not required for M1
FUNCTION outer() {
    // Augment context (requires object-spread implementation)
    inner(PASS: [..PASSED, extra_data: value])
}
```

**M1 workaround:** Explicitly rebuild the context:
```boon
FUNCTION outer() {
    // Explicit context reconstruction (works in M1)
    inner(PASS: [store: PASSED.store, extra_data: value])
}
```

---

## Compilation Model

### CompileContext Extension

The compiler maintains a `pass_stack` in the compilation context:

```rust
pub struct CompileContext {
    // Existing fields...
    pub scope_id: ScopeId,
    pub parameters: HashMap<String, SlotId>,

    // Context passing support
    pub pass_stack: Vec<SlotId>,  // Stack of PASSED context slots
}
```

### Call-Arg Local Bindings (Compile-Time)

When compiling function calls, **named arguments become compile-time local bindings** in CompileContext:

```rust
fn compile_function_call(call: &FunctionCall, ctx: &mut CompileContext) -> SlotId {
    // Named arguments (element:, style:, label:) become local bindings
    for arg in &call.arguments {
        if arg.name != "PASS" {
            let arg_slot = ctx.compile_expr(&arg.value);
            // Add to LOCAL bindings (compile-time only, not a runtime variable)
            ctx.local_bindings.insert(arg.name.clone(), arg_slot);
        }
    }

    // Now compile function body - it can reference `element.event.change.text`
    // because `element` is a local binding pointing to the compiled arg slot
    let result = inline_function_body(&call.function, ctx);

    // Clean up local bindings after function body compiled
    for arg in &call.arguments {
        if arg.name != "PASS" {
            ctx.local_bindings.remove(&arg.name);
        }
    }

    result
}
```

**Example:**
```boon
// Call site:
Element/text_input(element: my_input, style: [...], label: TEXT { Name })

// Inside Element/text_input body, `element`, `style`, `label` are local bindings
// `element.event.change.text` compiles to field access chain from element's SlotId
```

**Key insight:** This is NOT runtime storage. Named arguments are compile-time bindings that:
- Map argument names to SlotIds during body compilation
- Enable `element.event.change.text` expressions in function bodies
- Are removed after function body is compiled (scoped to that call)

### PASS Argument Compilation

When the compiler encounters `PASS: value` in a function call:

```rust
fn compile_function_call(call: &FunctionCall, ctx: &mut CompileContext) -> SlotId {
    let mut arg_slots = HashMap::new();

    for arg in &call.arguments {
        if arg.name == "PASS" {
            // Compile the PASS value and push to compile-time stack
            let pass_value_slot = compile_expression(&arg.value, ctx);
            ctx.pass_stack.push(pass_value_slot);
            // Don't add PASS to positional arguments
            continue;
        }

        let arg_slot = compile_expression(&arg.value, ctx);
        arg_slots.insert(arg.name.clone(), arg_slot);
    }

    // Inline the function body (no FunctionCall node emitted)
    let result = inline_function_body(&call.function, &arg_slots, ctx);

    // Pop context if we pushed one
    if call.has_pass_argument() {
        ctx.pass_stack.pop();
    }

    result
}
```

### PASSED Resolution Compilation

When the compiler encounters `PASSED` keyword:

```rust
fn compile_passed(parts: &[String], ctx: &CompileContext) -> Result<SlotId, Error> {
    // Get current context from stack
    let pass_slot = ctx.pass_stack.last()
        .ok_or("PASSED not available in this scope")?;

    if parts.is_empty() {
        // Just `PASSED` - return the entire context
        return Ok(*pass_slot);
    }

    // `PASSED.store.items` - emit field access chain
    let mut current = *pass_slot;
    for field in parts {
        current = ctx.emit_node(NodeKind::FieldAccess {
            source: current,
            field: field.clone(),
        });
    }

    Ok(current)
}
```

---

## Runtime Semantics

### Compile-Time Resolution (No Runtime Stack)

> **Important:** PASS/PASSED is a **purely compile-time mechanism**. There is no runtime `pass_stack` or `resolve_passed()` function. PASSED field access compiles to normal FieldAccess nodes (Router field projections).

**Why no runtime resolution?**
- PASSED values are known at compile time (the SlotId of the passed context)
- Field access like `PASSED.store` compiles to `FieldAccess { source: passed_slot, field: "store" }`
- This emits a Router projection node - no special runtime handling needed
- Matches the "functions compile to subgraphs" design (no special NodeKind::FunctionCall)

### How It Works at Runtime

At runtime, PASSED field access is just regular Router field projection:

```rust
// Compile time: PASSED.store.items compiles to:
// 1. FieldAccess { source: passed_context_slot, field: "store" } → store_slot
// 2. FieldAccess { source: store_slot, field: "items" } → items_slot

// Runtime: These are just Router nodes that emit field values when dirty
// No "walking Payload::Object" - Router projects from ObjectHandle(SlotId)
```

### Function Inlining

When a function is called with `PASS: value`, the compiler:

1. Compiles the PASS value expression → `pass_slot`
2. Pushes `pass_slot` onto `CompileContext.pass_stack`
3. Compiles the function body (PASSED references resolve to `pass_slot`)
4. Pops `pass_stack` after function body compiled
5. **No runtime stack manipulation** - the SlotIds are baked into the compiled graph

```rust
// Compile-time only - no TickContext.pass_stack
impl Compiler {
    fn compile_function_call(&mut self, call: &FunctionCall, ctx: &mut CompileContext) {
        if let Some(pass_expr) = call.pass_argument() {
            let pass_slot = self.compile_expr(pass_expr, ctx);
            ctx.pass_stack.push(pass_slot);  // Compile-time only

            self.inline_function_body(call.function, ctx);

            ctx.pass_stack.pop();  // Compile-time only
        } else {
            // Inherit current pass context (if any)
            self.inline_function_body(call.function, ctx);
        }
    }
}
```

---

## Scope Interactions

### PASS Propagation Rules

| Context | PASSED Available? | Notes |
|---------|-------------------|-------|
| Top-level variables | No | No function call, no PASS |
| Inside function body | Yes (if PASS provided) | Directly accessible |
| Nested function calls | Yes | Inherits from caller |
| THEN/WHEN/WHILE body | Yes | Inherits from surrounding |
| HOLD body | Yes | Inherits from surrounding |
| List/map closure | Yes | Inherits from surrounding |
| BLOCK | Yes | Inherits from surrounding |

### Context Inheritance

PASSED context automatically flows through:

```boon
// store passed at root
document: Document/new(root: root_element(PASS: [store: store]))

FUNCTION root_element() {
    Element/stripe(
        items: LIST {
            header()           // PASSED.store available
            content()          // PASSED.store available
        }
    )
}

FUNCTION header() {
    // PASSED.store still available - inherited from caller
    Element/label(label: PASSED.store.title)
}

FUNCTION content() {
    // Chain continues
    items_list()  // PASSED flows through
}

FUNCTION items_list() {
    // Still available
    PASSED.store.items |> List/map(item, new: item_element(item: item))
}
```

### Context Replacement

PASS at any call site **replaces** the context (not merges):

```boon
FUNCTION outer() {
    // PASSED = [store: main_store]

    // This replaces entirely - PASSED.store no longer exists inside
    inner(PASS: [theme: dark])
}

FUNCTION inner() {
    PASSED.theme   // Works
    PASSED.store   // ERROR - not in new context
}
```

To preserve fields while adding new ones, explicitly rebuild the context:

```boon
// M1: Explicit context reconstruction
inner(PASS: [store: PASSED.store, theme: dark])

// Future (Post-M1): Object spread syntax
// inner(PASS: [..PASSED, theme: dark])
```

### LINK Binding Pattern

PASS is commonly used to wire element events:

```boon
store: [
    elements: [
        item_input: LINK
        clear_button: LINK
    ]
    // ... state that reacts to elements...
]

document: Document/new(root: root_element(PASS: [store: store]))

FUNCTION root_element() {
    Element/stripe(
        items: LIST {
            // Wire elements to store.elements via PASSED
            item_input() |> LINK { PASSED.store.elements.item_input }
            clear_button() |> LINK { PASSED.store.elements.clear_button }
        }
    )
}
```

---

## Implementation Notes

### Old Engine (ActorContext)

The current actor-based engine stores PASSED in `ActorContext`:

```rust
pub struct ActorContext {
    pub piped: Option<Arc<ValueActor>>,
    pub passed: Option<Arc<ValueActor>>,  // PASSED context
    pub parameters: HashMap<String, Arc<ValueActor>>,
}
```

### New Engine (Arena-Based) - Compile-Time Only

The new arena-based engine resolves PASS/PASSED **purely at compile time**:

```rust
pub struct CompileContext {
    pub pass_stack: Vec<SlotId>,  // Compile-time only
}

// NO TickContext.pass_stack - runtime has no knowledge of PASS/PASSED
// PASSED field access compiles to FieldAccess nodes (Router projections)
```

**Why compile-time only?**
- Functions compile to subgraphs (no special FunctionCall node kind)
- PASSED.field compiles to FieldAccess nodes like any other field access
- No runtime overhead - SlotIds baked into compiled graph
- Consistent with "functions are inlined" model

**Why stack at compile time?**
- Functions can call functions with different PASS values
- Stack tracks current context during compilation
- Popped after function body compiled - not needed at runtime

### Message Storage Interaction

PASSED values follow the **Last-Value Cache** model (§2.3.6):
- Context is read from source node's cached value
- Changes to context source propagate to all PASSED readers
- No special message handling needed - just FieldAccess (Router) nodes

---

## Common Patterns

### Store Pattern (TodoMVC, Shopping List)

```boon
store: [
    elements: [/* LINK declarations */]
    // Computed state reacting to element events
    // Note: submit is done via key_down event filtered for Enter key
    new_item: elements.item_input.event.key_down |> WHEN { Enter => elements.item_input.text }
    items: LIST {} |> List/append(item: new_item)
]

document: Document/new(root: app(PASS: [store: store]))

FUNCTION app() {
    Element/stripe(items: LIST {
        input_element() |> LINK { PASSED.store.elements.item_input }
        list_element()
    })
}

FUNCTION list_element() {
    PASSED.store.items |> List/map(item, new: /* render item */)
}
```

### Theme Pattern

```boon
theme: [
    colors: [primary: Blue, secondary: Gray]
    spacing: [small: 4, medium: 8, large: 16]
]

document: Document/new(root: app(PASS: [theme: theme]))

FUNCTION styled_button(label) {
    Element/button(
        style: [
            padding: PASSED.theme.spacing.medium
            background: [color: PASSED.theme.colors.primary]
        ]
        label: label
    )
}
```

### Multiple Contexts

```boon
app: [
    store: [/* state */]
    theme: [/* styling */]
    i18n: [/* translations */]
]

document: Document/new(root: root(PASS: app))

FUNCTION root() {
    Element/stripe(items: LIST {
        // All contexts available via PASSED
        PASSED.theme.colors.background  // Styling
        PASSED.store.user              // State
        PASSED.i18n.greeting           // Translations
    })
}
```

---

## Error Conditions

| Error | Cause | Resolution |
|-------|-------|------------|
| "PASSED not available" | Using PASSED outside function scope | Only use in function bodies |
| "Field 'x' not found in PASSED" | Accessing nonexistent field | Check PASS value structure |
| "Cannot access field on non-object" | PASSED is not an object | Pass object, not scalar |

---

## See Also

- `docs/language/FUNCTION_ARGUMENTS.md` - Piping vs PASS comparison
- `docs/language/LINK_PATTERN.md` - LINK with PASSED for event wiring
- §2.3 Message Passing - How values flow between nodes
- §2.4 Event Loop - Tick processing and context propagation
