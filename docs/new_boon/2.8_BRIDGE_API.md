## Chapter 2.8: Bridge & API

This section details the redesign of the Bridge (Boon→Zoon rendering) and API (standard library functions) for the **new arena-based engine** (no backward compatibility with Arc<ValueActor>).

### Current Problems (to eliminate)

- 170+ `expect_*()` calls that panic without context
- Event handler boilerplate duplicated 6+ times
- No path for users to add custom Rust functions
- `chain(stream::pending())` workaround everywhere
- Arc/stream complexity makes debugging hard

### Design Principles

1. **Trait-based extension** - Users implement `BoonFunction` trait
2. **Fast-fail with context** - Panics include function path, argument index, expected vs actual type
3. **Debuggability first** - Clear data flow, traceable errors
4. **Arena-native** - Uses SlotId, Message, Payload directly (no Arc<ValueActor>)

---

### 2.8.1 Trait-Based Function API (Arena-Native)

Functions operate on arena nodes via `SlotId`, returning outputs through the message system.

#### Core Trait

```rust
/// Context passed to all function implementations
pub struct FunctionContext<'a> {
    pub arena: &'a mut Arena,
    pub event_loop: &'a mut EventLoop,
    pub source_id: SourceId,
    pub scope_id: ScopeId,
    pub path: &'static str,  // "Element/button" - for error messages
}

/// Core trait for Boon standard library functions
pub trait BoonFunction: Send + Sync + 'static {
    fn path(&self) -> &'static [&'static str];  // ["Element", "button"]
    fn min_args(&self) -> usize { 0 }
    fn max_args(&self) -> Option<usize> { None }

    /// Process function call, returning output slot
    fn call(
        &self,
        args: Arguments,
        ctx: FunctionContext,
    ) -> SlotId;
}
```

#### Arguments Wrapper (SlotId-based)

```rust
/// Wrapper for type-safe argument extraction
pub struct Arguments<'a> {
    slots: &'a [SlotId],
    arena: &'a Arena,
    function_path: &'static str,
}

impl<'a> Arguments<'a> {
    /// Panics with: "Element/button(..) missing required argument 'label' at position 2"
    pub fn require(&self, index: usize, name: &str) -> SlotId {
        self.slots.get(index).copied().unwrap_or_else(|| {
            panic!(
                "{}(..) missing required argument '{}' at position {} (got {} arguments)",
                self.function_path, name, index, self.slots.len()
            )
        })
    }

    /// Panics with: "Element/button(..) expects 3 arguments, got 5"
    pub fn expect_exact<const N: usize>(&self) -> [SlotId; N] {
        if self.slots.len() != N {
            panic!(
                "{}(..) expects {} arguments, got {}",
                self.function_path, N, self.slots.len()
            );
        }
        std::array::from_fn(|i| self.slots[i])
    }

    /// Get current value from slot with context
    pub fn value(&self, slot: SlotId) -> &Payload {
        self.arena.get_value(slot)
    }
}
```

#### Payload Extraction with Context

```rust
impl Payload {
    /// Panics with: "Element/button: settings.style.font.size expected Number, got Text"
    pub fn expect_number(&self, ctx: &str) -> f64 {
        match self {
            Payload::Number(n) => *n,
            other => panic!("{}: expected Number, got {}", ctx, other.type_name()),
        }
    }

    pub fn expect_text(&self, ctx: &str) -> &Arc<str> {
        match self {
            Payload::Text(t) => t,
            other => panic!("{}: expected Text, got {}", ctx, other.type_name()),
        }
    }

    pub fn expect_object_handle(&self, ctx: &str) -> SlotId {
        match self {
            Payload::ObjectHandle(slot) => *slot,
            other => panic!("{}: expected Object, got {}", ctx, other.type_name()),
        }
    }

    pub fn expect_list_handle(&self, ctx: &str) -> SlotId {
        match self {
            Payload::ListHandle(slot) => *slot,
            other => panic!("{}: expected List, got {}", ctx, other.type_name()),
        }
    }
}
```

#### Function Registry

```rust
pub struct FunctionRegistry {
    functions: HashMap<&'static str, Box<dyn BoonFunction>>,
}

impl FunctionRegistry {
    pub fn with_stdlib() -> Self {
        let mut r = Self::new();
        r.register(text::TextTrim);
        r.register(math::MathSum);
        r.register(element::ElementButton);
        // ... all 40+ functions
        r
    }

    pub fn get(&self, path: &str) -> Option<&dyn BoonFunction> {
        self.functions.get(path).map(|b| b.as_ref())
    }
}
```

#### Example: Text/trim (pure Transformer)

> **Note on closures:** The examples below use Rust closures for clarity, but the real implementation uses `NodeKind` enum dispatch with serializable opcodes. This ensures snapshots contain only data, not opaque closures (per §1.1 "no opaque closures" constraint).

```rust
pub struct TextTrim;

impl BoonFunction for TextTrim {
    fn path(&self) -> &'static [&'static str] { &["Text", "trim"] }
    fn min_args(&self) -> usize { 1 }
    fn max_args(&self) -> Option<usize> { Some(1) }

    fn call(&self, args: Arguments, ctx: FunctionContext) -> SlotId {
        let input_slot = args.expect_exact::<1>()[0];

        // Create a Transformer node that trims text
        let output_slot = ctx.arena.alloc_transformer(
            ctx.source_id,
            ctx.scope_id,
            vec![input_slot],
            |inputs| {
                let text = inputs[0].expect_text("Text/trim(..) argument 0");
                Payload::Text(text.trim().into())
            },
        );

        // Wire input to output
        ctx.arena.connect(input_slot, output_slot);

        output_slot
    }
}
```

#### Example: Math/sum (stateful Register)

```rust
pub struct MathSum;

impl BoonFunction for MathSum {
    fn path(&self) -> &'static [&'static str] { &["Math", "sum"] }
    fn min_args(&self) -> usize { 1 }
    fn max_args(&self) -> Option<usize> { Some(1) }

    fn call(&self, args: Arguments, ctx: FunctionContext) -> SlotId {
        let increment_slot = args.expect_exact::<1>()[0];

        // Create a Register node that accumulates
        let sum_slot = ctx.arena.alloc_register(
            ctx.source_id,
            ctx.scope_id,
            Payload::Number(0.0),  // Initial value
        );

        // Create Transformer that adds increment to current sum
        let adder_slot = ctx.arena.alloc_transformer(
            ctx.source_id.child(1),
            ctx.scope_id,
            vec![increment_slot, sum_slot],
            |inputs| {
                let increment = inputs[0].expect_number("Math/sum(..) increment");
                let current = inputs[1].expect_number("Math/sum(..) state");
                Payload::Number(current + increment)
            },
        );

        // Wire: increment + current_sum -> adder -> sum_register
        ctx.arena.connect(adder_slot, sum_slot);

        sum_slot
    }
}
```

---

### 2.8.2 Element Nodes & Property Binding

Elements are Router nodes (object with fields) that connect to Zoon UI via a Bridge component.

#### Element Node Structure

```rust
/// Element nodes are Routers with standard fields
pub struct ElementNode {
    pub kind: ElementKind,           // Button, Stripe, Container, etc.
    pub settings_slot: SlotId,       // Router with style, label, etc.
    pub element_slot: Option<SlotId>, // element arg (for LINK binding)
    pub event_slots: Vec<(EventKind, SlotId)>,  // IOPad nodes for events
}

pub enum ElementKind {
    Button, Stripe, Container, Stack, TextInput, Checkbox, Label, Paragraph, Link
}
```

#### Style Property Binding

Properties are extracted from the settings Router and converted to CSS:

```rust
/// Declarative style property definition
pub struct StyleProperty {
    css_name: &'static str,
    field_path: &'static [&'static str],  // ["style", "font", "size"]
    converter: fn(&Payload, &str) -> String,  // (value, error_context) -> css_value
}

impl ElementNode {
    /// Standard properties for most elements
    fn standard_style_properties() -> &'static [StyleProperty] {
        &[
            StyleProperty { css_name: "font-size", field_path: &["style", "font", "size"], converter: number_to_px },
            StyleProperty { css_name: "color", field_path: &["style", "font", "color"], converter: oklch_to_css },
            StyleProperty { css_name: "font-weight", field_path: &["style", "font", "weight"], converter: weight_tag_to_css },
            StyleProperty { css_name: "padding", field_path: &["style", "padding"], converter: directional_to_css },
            StyleProperty { css_name: "background-color", field_path: &["style", "background", "color"], converter: oklch_to_css },
            StyleProperty { css_name: "border-radius", field_path: &["style", "rounded_corners"], converter: number_to_px },
            StyleProperty { css_name: "width", field_path: &["style", "width"], converter: dimension_to_css },
            StyleProperty { css_name: "height", field_path: &["style", "height"], converter: dimension_to_css },
        ]
    }
}
```

#### Property Navigation via Arena (see Issue 14 for field-path semantics)

Field paths like `store.filter_buttons.all.event.press` resolve through Router chains:
1. Each segment returns a SlotId (not a cloned value)
2. Paths are chains of Router field projections
3. Event streams are accessed via nested Routers within element nodes

```rust
impl Arena {
    /// Navigate a field path through nested Routers
    pub fn navigate_field_path(
        &self,
        root: SlotId,
        path: &[&str],
        error_ctx: &str,
    ) -> Option<SlotId> {
        let mut current = root;
        for segment in path {
            let router = self.get_router(current);
            current = router.get_field(segment).unwrap_or_else(|| {
                panic!("{}: field '{}' not found in path {:?}", error_ctx, segment, path)
            });
        }
        Some(current)
    }
}
```

---

### 2.8.3 Event Handling via IOPad Nodes

Events use IOPad nodes that receive DOM events and forward to LINK targets.

#### IOPad Node for Events

```rust
/// IOPad node handles DOM events
pub struct IOPadNode {
    pub direction: IODirection,
    pub event_kind: EventKind,
    pub link_target: Option<SlotId>,  // Where to send events (LINK destination)
    pub pending_buffer: VecDeque<Payload>,  // Events before LINK is bound
    pub buffer_capacity: usize,
}

pub enum IODirection { Input, Output }

pub enum EventKind {
    Press, Click, DoubleClick, Hovered, Change, KeyDown, Blur
}
```

#### Element State Streams

Examples use `element.hovered`, `element.focused`, and reactive style bindings. Elements expose continuous state signals in addition to discrete events:

```rust
pub struct ElementState {
    pub hovered: SlotId,   // Bool producer, updates on mouseenter/mouseleave
    pub focused: SlotId,   // Bool producer, updates on focus/blur
    pub bounds: SlotId,    // Rect producer, updates on resize observer
}

// LINK includes both events AND state
pub struct LinkNode {
    pub events: HashMap<String, SlotId>,   // press, click, key_down
    pub state: ElementState,                // hovered, focused, bounds
}
```

**Usage in Boon:**
```boon
button: Element/button(element, style, label) |> LINK { link }
-- link.hovered is a Bool stream (continuous)
-- link.event.press is an event stream (discrete)
highlighted: link.hovered |> THEN { highlight_style }
```

#### Event Flow

```
DOM Event (click)
    ↓
Bridge.on_click()
    ↓
EventLoop.inject_dom_event(element_id, EventKind::Press, Payload::Unit)
    ↓
Arena.get_iopad(element_slot) → IOPadNode
    ↓
if link_target.is_some():
    EventLoop.send_message(link_target, payload)
else:
    pending_buffer.push(payload)  // Buffer until LINK binds
```

#### LINK Binding/Unbinding Protocol

When `element |> LINK { target }` evaluates:

```rust
pub struct LinkBinding {
    pub element_id: ElementId,     // DOM element being bound
    pub link_slot: SlotId,         // LINK node receiving events
    pub event_listeners: Vec<EventListenerHandle>,
}

impl LinkNode {
    // Called when element is created/attached
    fn bind(&mut self, element_id: ElementId, event_loop: &mut EventLoop) {
        // 1. Register DOM event listeners
        // 2. Connect listeners to this LinkNode's event streams
        // 3. Store handles for cleanup
        self.bindings.push(LinkBinding { ... });
    }

    // Called when scope is finalizing (WHILE switch, List/remove)
    fn unbind(&mut self, element_id: ElementId, event_loop: &mut EventLoop) {
        // 1. Remove DOM event listeners
        // 2. Don't emit any more events
        // 3. Clean up handles
        self.bindings.retain(|b| b.element_id != element_id);
    }
}

impl Arena {
    /// Bind LINK from element's IOPad to target
    pub fn bind_link(
        &mut self,
        element_slot: SlotId,
        event_kind: EventKind,
        target_slot: SlotId,
    ) {
        let iopad = self.get_iopad_mut(element_slot, event_kind);
        iopad.link_target = Some(target_slot);

        // Flush buffered events
        for payload in iopad.pending_buffer.drain(..) {
            self.event_loop.enqueue_message(Message {
                source: NodeAddress::new(element_slot, Port::Output),
                target: NodeAddress::new(target_slot, Port::Input(0)),
                payload,
            });
        }
    }
}
```

**Scope safety:** When WHILE switches arms:
1. Old arm's LINK bindings are unbound via scope finalization
2. New arm creates fresh LINK bindings
3. No event leakage between arms

#### Element Function with Events

```rust
pub struct ElementButton;

impl BoonFunction for ElementButton {
    fn path(&self) -> &'static [&'static str] { &["Element", "button"] }
    fn min_args(&self) -> usize { 3 }

    fn call(&self, args: Arguments, ctx: FunctionContext) -> SlotId {
        let [element_slot, style_slot, label_slot] = args.expect_exact::<3>();

        // Create settings Router
        let settings = ctx.arena.alloc_router(ctx.source_id, ctx.scope_id, vec![
            ("style", style_slot),
            ("label", label_slot),
        ]);

        // Create IOPad nodes for events
        let press_iopad = ctx.arena.alloc_iopad(
            ctx.source_id.child(1),
            ctx.scope_id,
            EventKind::Press,
            0,  // No buffering
        );
        let hovered_iopad = ctx.arena.alloc_iopad(
            ctx.source_id.child(2),
            ctx.scope_id,
            EventKind::Hovered,
            0,
        );

        // Create event Router
        let event_router = ctx.arena.alloc_router(ctx.source_id.child(3), ctx.scope_id, vec![
            ("press", press_iopad),
        ]);

        // Create element Router (the output)
        let element_node = ctx.arena.alloc_element_node(
            ctx.source_id,
            ctx.scope_id,
            ElementKind::Button,
            settings,
            Some(element_slot),
            vec![(EventKind::Press, press_iopad), (EventKind::Hovered, hovered_iopad)],
        );

        // Extract event from element argument if present
        if let Some(event_slot) = ctx.arena.try_get_field(element_slot, "event") {
            // Wire element.event.press to our press_iopad (derived event)
            if let Some(press_slot) = ctx.arena.try_get_field(event_slot, "press") {
                ctx.arena.connect(press_iopad, press_slot);
            }
        }

        element_node
    }
}

---

### 2.8.4 Bridge: Arena to Zoon Rendering

The Bridge connects the arena-based runtime to Zoon UI elements.

#### Bridge Architecture

```rust
/// Bridge manages DOM rendering from arena state
pub struct Bridge {
    arena: Arc<Arena>,
    event_loop: Arc<EventLoop>,
    /// Map element SlotIds to Zoon element handles
    rendered_elements: HashMap<SlotId, ZoonElementHandle>,
    /// Style property converters
    converters: StyleConverters,
}

impl Bridge {
    /// Called each tick to sync arena state to DOM
    pub fn render(&mut self) {
        // Get document root from arena
        let doc_slot = self.arena.get_document_root();
        let root_element = self.arena.navigate_field(doc_slot, "root_element");

        // Render recursively
        self.render_element(root_element);
    }

    fn render_element(&mut self, slot: SlotId) {
        let node = self.arena.get_element_node(slot);

        match node.kind {
            ElementKind::Button => self.render_button(slot, node),
            ElementKind::Stripe => self.render_stripe(slot, node),
            // ...
        }
    }

    fn render_button(&mut self, slot: SlotId, node: &ElementNode) {
        // Extract style properties
        let font_size = self.extract_style(node.settings_slot, &["style", "font", "size"]);
        let label = self.extract_text(node.settings_slot, &["label"]);

        // Create or update Zoon button
        let btn = Button::new()
            .label(label)
            .style("font-size", font_size);

        // Wire DOM events to IOPads
        let press_iopad = node.event_slots.get(&EventKind::Press);
        btn.on_press(move || {
            self.event_loop.inject_dom_event(press_iopad, Payload::Unit);
        });

        self.rendered_elements.insert(slot, btn.into());
    }
}
```

#### Style Converters

```rust
pub struct StyleConverters;

impl StyleConverters {
    pub fn number_to_px(payload: &Payload, ctx: &str) -> String {
        format!("{}px", payload.expect_number(ctx))
    }

    pub fn oklch_to_css(payload: &Payload, ctx: &str) -> String {
        let obj = payload.expect_object_handle(ctx);
        // Extract l, c, h, alpha from object
        format!("oklch({} {} {} / {})", l, c, h, alpha)
    }

    pub fn directional_to_css(payload: &Payload, ctx: &str) -> String {
        match payload {
            Payload::Number(n) => format!("{}px", n),
            Payload::ObjectHandle(slot) => {
                // Extract top/right/bottom/left with row/column fallbacks
                format!("{}px {}px {}px {}px", top, right, bottom, left)
            }
            _ => panic!("{}: expected Number or Object for padding", ctx),
        }
    }
}
```

---

### 2.8.5 Missing API Functions

Functions used in examples but not yet mapped to nodes:

| Function | Node Mapping |
|----------|--------------|
| `List/is_empty` | Reducer: emits Bool when list count changes |
| `List/is_not_empty` | Reducer: emits Bool |
| `List/any(if:)` | Reducer: emits Bool when any predicate true |
| `List/every(if:)` | Reducer: emits Bool when all predicates true |
| `List/latest` | Combiner: emits last item's value |
| `List/sort_by(key:)` | Transformer: reorders items, emits ListDelta::Move |
| `List/get(index:)` | Selector: emits value at index |
| `List/zip(with:)` | Combiner: pairs two lists |
| `List/chain(...)` | Combiner: sequential processing |
| `List/to_u_bits` | Converter: List<Bool> to integer |
| `Bits/*` | Hardware operations (for hw_examples/) |
| `Memory/*` | RAM/ROM operations (for hw_examples/) |
| `tick`, `impulse` | Timer: single-tick pulse |
| `delta`, `sum` | Accumulator: change detection, running sum |
| `increment`, `decrement` | Math: +1/-1 operations |

---

### 2.8.6 Module Structure (New Engine)

> **Canonical location:** See `plans/M0_CLI__M1_NEW_ENGINE_IN_PLAYGROUND.md` for authoritative file structure.

```
crates/boon/src/
├── engine_v2/                  # Platform-agnostic core
│   ├── mod.rs                  # Re-exports
│   ├── arena.rs                # Arena, SlotId, ReactiveNode
│   ├── node.rs                 # Node kinds (Router, Register, Transformer, Bus, IOPad)
│   ├── message.rs              # Message, Payload
│   ├── event_loop.rs           # EventLoop, timer queue
│   └── routing.rs              # RoutingTable
├── evaluator_v2/               # AST → arena compilation
│   ├── mod.rs                  # Compile functions
│   └── api.rs                  # API function bindings (stdlib)
└── platform/browser/
    └── bridge_v2.rs            # Arena → Zoon rendering
```

Note: API functions are in `evaluator_v2/api.rs`, not a separate `functions/` tree.

---

### 2.8.7 Implementation Phases

**Note:** Bridge/API is built as part of the new engine, not migrated from old.

#### Part of Phase 7: Bridge & UI
1. Implement `BoonFunction` trait and `FunctionRegistry`
2. Implement core functions: `Text/*`, `Math/*`, `Bool/*`
3. Implement element functions: `Element/*`, `Document/*`
4. Implement `Bridge` for arena→Zoon rendering
5. Implement style converters
6. Implement IOPad event handling
7. **Milestone:** `counter.bn` with button works

#### Part of Phase 7 (continued):
8. Implement list functions: `List/*`
9. Implement timer: `Timer/interval`
10. Implement side-effects: `Log/*`
11. **Milestone:** `todo_mvc.bn` works

---

### 2.8.8 Critical Files (New Engine)

| File | Purpose |
|------|---------|
| `src/engine_v2/node.rs` | Node kinds including IOPadNode |
| `src/evaluator_v2/api.rs` | API function bindings (Element/*, Document/*, etc.) |
| `src/platform/browser/bridge_v2.rs` | Arena → Zoon rendering, style converters |

---

### 2.8.9 Benefits Summary

| Aspect | Old Engine | New Engine |
|--------|------------|------------|
| Function definition | Closure in match arm | Implement `BoonFunction` trait |
| Argument access | `Arc<ValueActor>` streams | `SlotId` direct arena access |
| Error messages | "expected Object" | "Element/button: settings.style.font expected Object, got Number" |
| Event handling | ActorLoop + select! | IOPadNode in arena |
| Style extraction | 5-7 flat_map chains | `Arena.navigate_field_path()` |
| Stream lifecycle | Manual `chain(pending())` | Not needed (arena manages lifecycle) |
| User extensibility | None | Implement `BoonFunction` trait, register |
| Debugging | Scattered async streams | Single arena state, deterministic ticks |

---

