## Chapter 2.8: Bridge & API

This section details the redesign of the Bridge (Boon→Zoon rendering) and API (standard library functions) for the **new arena-based engine** (no backward compatibility with Arc<ValueActor>).

### Current Problems (to eliminate)

- 170+ `expect_*()` calls that panic without context
- Event handler boilerplate duplicated 6+ times
- No path for users to add custom Rust functions
- `chain(stream::pending())` workaround everywhere
- Arc/stream complexity makes debugging hard

### Design Principles

1. **Trait-based extension** - Users implement `BoonFunction` trait
2. **Fast-fail with context** - Panics include function path, argument index, expected vs actual type
3. **Debuggability first** - Clear data flow, traceable errors
4. **Arena-native** - Uses SlotId, Message, Payload directly (no Arc<ValueActor>)

---

### 2.8.1 Trait-Based Function API (Arena-Native)

Functions operate on arena nodes via `SlotId`, returning outputs through the message system.

#### Core Trait

```rust
/// Context passed to all function implementations
pub struct FunctionContext<'a> {
    pub arena: &'a mut Arena,
    pub event_loop: &'a mut EventLoop,
    pub source_id: SourceId,
    pub scope_id: ScopeId,
    pub path: &'static str,  // "Element/button" - for error messages
}

/// Core trait for Boon standard library functions
pub trait BoonFunction: Send + Sync + 'static {
    fn path(&self) -> &'static [&'static str];  // ["Element", "button"]
    fn min_args(&self) -> usize { 0 }
    fn max_args(&self) -> Option<usize> { None }

    /// Process function call, returning output slot
    fn call(
        &self,
        args: Arguments,
        ctx: FunctionContext,
    ) -> SlotId;
}
```

#### Arguments Wrapper (SlotId-based)

```rust
/// Wrapper for type-safe argument extraction
pub struct Arguments<'a> {
    slots: &'a [SlotId],
    arena: &'a Arena,
    function_path: &'static str,
}

impl<'a> Arguments<'a> {
    /// Panics with: "Element/button(..) missing required argument 'label' at position 2"
    pub fn require(&self, index: usize, name: &str) -> SlotId {
        self.slots.get(index).copied().unwrap_or_else(|| {
            panic!(
                "{}(..) missing required argument '{}' at position {} (got {} arguments)",
                self.function_path, name, index, self.slots.len()
            )
        })
    }

    /// Panics with: "Element/button(..) expects 3 arguments, got 5"
    pub fn expect_exact<const N: usize>(&self) -> [SlotId; N] {
        if self.slots.len() != N {
            panic!(
                "{}(..) expects {} arguments, got {}",
                self.function_path, N, self.slots.len()
            );
        }
        std::array::from_fn(|i| self.slots[i])
    }

    /// Get current value from slot with context
    pub fn value(&self, slot: SlotId) -> &Payload {
        self.arena.get_value(slot)
    }
}
```

#### Payload Extraction with Context

```rust
impl Payload {
    /// Panics with: "Element/button: settings.style.font.size expected Number, got Text"
    pub fn expect_number(&self, ctx: &str) -> f64 {
        match self {
            Payload::Number(n) => *n,
            other => panic!("{}: expected Number, got {}", ctx, other.type_name()),
        }
    }

    pub fn expect_text(&self, ctx: &str) -> &Arc<str> {
        match self {
            Payload::Text(t) => t,
            other => panic!("{}: expected Text, got {}", ctx, other.type_name()),
        }
    }

    pub fn expect_object_handle(&self, ctx: &str) -> SlotId {
        match self {
            Payload::ObjectHandle(slot) => *slot,
            other => panic!("{}: expected Object, got {}", ctx, other.type_name()),
        }
    }

    pub fn expect_list_handle(&self, ctx: &str) -> SlotId {
        match self {
            Payload::ListHandle(slot) => *slot,
            other => panic!("{}: expected List, got {}", ctx, other.type_name()),
        }
    }
}
```

#### Function Registry

```rust
pub struct FunctionRegistry {
    functions: HashMap<&'static str, Box<dyn BoonFunction>>,
}

impl FunctionRegistry {
    pub fn with_stdlib() -> Self {
        let mut r = Self::new();
        r.register(text::TextTrim);
        r.register(math::MathSum);
        r.register(element::ElementButton);
        // ... all 40+ functions
        r
    }

    pub fn get(&self, path: &str) -> Option<&dyn BoonFunction> {
        self.functions.get(path).map(|b| b.as_ref())
    }
}
```

#### Example: Text/trim (pure Transformer)

> **Note on closures:** The examples below use Rust closures for clarity, but the real implementation uses `NodeKind` enum dispatch with serializable opcodes. This ensures snapshots contain only data, not opaque closures (per §1.1 "no opaque closures" constraint).

```rust
pub struct TextTrim;

impl BoonFunction for TextTrim {
    fn path(&self) -> &'static [&'static str] { &["Text", "trim"] }
    fn min_args(&self) -> usize { 1 }
    fn max_args(&self) -> Option<usize> { Some(1) }

    fn call(&self, args: Arguments, ctx: FunctionContext) -> SlotId {
        let input_slot = args.expect_exact::<1>()[0];

        // Create a Transformer node that trims text
        let output_slot = ctx.arena.alloc_transformer(
            ctx.source_id,
            ctx.scope_id,
            vec![input_slot],
            |inputs| {
                let text = inputs[0].expect_text("Text/trim(..) argument 0");
                Payload::Text(text.trim().into())
            },
        );

        // Wire input to output
        ctx.arena.connect(input_slot, output_slot);

        output_slot
    }
}
```

#### Example: Math/sum (stateful Register)

```rust
pub struct MathSum;

impl BoonFunction for MathSum {
    fn path(&self) -> &'static [&'static str] { &["Math", "sum"] }
    fn min_args(&self) -> usize { 1 }
    fn max_args(&self) -> Option<usize> { Some(1) }

    fn call(&self, args: Arguments, ctx: FunctionContext) -> SlotId {
        let increment_slot = args.expect_exact::<1>()[0];

        // Create a Register node that accumulates
        let sum_slot = ctx.arena.alloc_register(
            ctx.source_id,
            ctx.scope_id,
            Payload::Number(0.0),  // Initial value
        );

        // Create Transformer that adds increment to current sum
        let adder_slot = ctx.arena.alloc_transformer(
            ctx.source_id.child(1),
            ctx.scope_id,
            vec![increment_slot, sum_slot],
            |inputs| {
                let increment = inputs[0].expect_number("Math/sum(..) increment");
                let current = inputs[1].expect_number("Math/sum(..) state");
                Payload::Number(current + increment)
            },
        );

        // Wire: increment + current_sum -> adder -> sum_register
        ctx.arena.connect(adder_slot, sum_slot);

        sum_slot
    }
}
```

---

### 2.8.2 Element Nodes & Property Binding

Elements are Router nodes (object with fields) that connect to Zoon UI via a Bridge component.

#### Element Node Structure

```rust
/// Element nodes are Routers with standard fields
pub struct ElementNode {
    pub kind: ElementKind,           // Button, Stripe, Container, etc.
    pub settings_slot: SlotId,       // Router with style, label, etc.
    pub element_slot: Option<SlotId>, // element arg (for LINK binding)
    pub event_slots: Vec<(EventKind, SlotId)>,  // IOPad nodes for events
}

pub enum ElementKind {
    Button, Stripe, Container, Stack, TextInput, Checkbox, Label, Paragraph, Link
}
```

#### Style Property Binding

Properties are extracted from the settings Router and converted to CSS:

```rust
/// Declarative style property definition
pub struct StyleProperty {
    css_name: &'static str,
    field_path: &'static [&'static str],  // ["style", "font", "size"]
    converter: fn(&Payload, &str) -> String,  // (value, error_context) -> css_value
}

impl ElementNode {
    /// Standard properties for most elements
    fn standard_style_properties() -> &'static [StyleProperty] {
        &[
            StyleProperty { css_name: "font-size", field_path: &["style", "font", "size"], converter: number_to_px },
            StyleProperty { css_name: "color", field_path: &["style", "font", "color"], converter: oklch_to_css },
            StyleProperty { css_name: "font-weight", field_path: &["style", "font", "weight"], converter: weight_tag_to_css },
            StyleProperty { css_name: "padding", field_path: &["style", "padding"], converter: directional_to_css },
            StyleProperty { css_name: "background-color", field_path: &["style", "background", "color"], converter: oklch_to_css },
            StyleProperty { css_name: "border-radius", field_path: &["style", "rounded_corners"], converter: number_to_px },
            StyleProperty { css_name: "width", field_path: &["style", "width"], converter: dimension_to_css },
            StyleProperty { css_name: "height", field_path: &["style", "height"], converter: dimension_to_css },
        ]
    }
}
```

#### Property Navigation via Arena (see Issue 14 for field-path semantics)

Field paths like `store.filter_buttons.all.event.press` resolve through Router chains:
1. Each segment returns a SlotId (not a cloned value)
2. Paths are chains of Router field projections
3. Event streams are accessed via nested Routers within element nodes

```rust
impl Arena {
    /// Navigate a field path through nested Routers
    pub fn navigate_field_path(
        &self,
        root: SlotId,
        path: &[&str],
        error_ctx: &str,
    ) -> Option<SlotId> {
        let mut current = root;
        for segment in path {
            let router = self.get_router(current);
            current = router.get_field(segment).unwrap_or_else(|| {
                panic!("{}: field '{}' not found in path {:?}", error_ctx, segment, path)
            });
        }
        Some(current)
    }
}
```

---

### 2.8.3 Event Handling via IOPad Nodes

Events use IOPad nodes that receive DOM events and forward to LINK targets.

#### IOPad Node for Events

```rust
/// IOPad node handles DOM events
pub struct IOPadNode {
    pub direction: IODirection,
    pub event_kind: EventKind,
    pub link_target: Option<SlotId>,  // Where to send events (LINK destination)
    pub pending_buffer: VecDeque<Payload>,  // Events before LINK is bound
    pub buffer_capacity: usize,
}

pub enum IODirection { Input, Output }

pub enum EventKind {
    Press, Click, DoubleClick, Hovered, Change, KeyDown, Blur
}
```

#### Element State Streams

Examples use `element.hovered`, `element.focused`, and reactive style bindings. Elements expose continuous state signals in addition to discrete events:

```rust
pub struct ElementState {
    pub hovered: SlotId,   // Bool producer, updates on mouseenter/mouseleave
    pub focused: SlotId,   // Bool producer, updates on focus/blur
    pub bounds: SlotId,    // Rect producer, updates on resize observer
}

// LINK includes both events AND state
pub struct LinkNode {
    pub events: HashMap<String, SlotId>,   // press, click, key_down
    pub state: ElementState,                // hovered, focused, bounds
}
```

**Usage in Boon:**
```boon
button: Element/button(element, style, label) |> LINK { link }
-- link.hovered is a Bool stream (continuous)
-- link.event.press is an event stream (discrete)
highlighted: link.hovered |> THEN { highlight_style }
```

#### Event Payloads (M1 Reference)

| Event | Payload Type | Fields | Used In |
|-------|--------------|--------|---------|
| `press` | `Unit` | (none) | buttons, checkboxes |
| `click` | `Unit` | (none) | general click handlers |
| `double_click` | `Unit` | (none) | todo_mvc edit mode |
| `blur` | `Unit` | (none) | text_input focus loss |
| `change` | Object | `text: Text` | text_input content changed |
| `key_down` | Object | `key: Tag` | keyboard events (Enter, Escape, etc.) |
| `hovered` | `Bool` | (continuous state, not event) | hover detection |

**Note:** `hovered`, `focused`, `bounds` are continuous state streams (always have a value), not discrete events.

#### Element State Fields (via LINK)

| Element Kind | Readable State | Type | Example |
|--------------|----------------|------|---------|
| `Element/text_input` | `.text` | Text | Current input value |
| `Element/checkbox` | `.checked` | Bool | Check state |
| Any element | `.hovered` | Bool | Mouse hover state |
| Any element | `.focused` | Bool | Focus state |
| Any element | `.bounds` | Rect | Position/size |

**Examples from M1 validation:**
```boon
-- todo_mvc.bn: Reading text from input
new_title: elements.new_todo_title_text_input.text |> Text/trim()

-- todo_mvc.bn: Key events
edit_el.event.key_down.key |> WHEN {
    Enter => confirm_title
    Escape => False
    __ => SKIP
}

-- shopping_list.bn: Button press
add_button.event.press |> THEN { new_item }
```

#### Event Flow

```
DOM Event (click)
    ↓
Bridge.on_click()
    ↓
EventLoop.inject_dom_event(element_id, EventKind::Press, Payload::Unit)
    ↓
Arena.get_iopad(element_slot) → IOPadNode
    ↓
if link_target.is_some():
    EventLoop.send_message(link_target, payload)
else:
    pending_buffer.push(payload)  // Buffer until LINK binds
```

#### LINK Binding/Unbinding Protocol

When `element |> LINK { target }` evaluates:

```rust
pub struct LinkBinding {
    pub element_id: ElementId,     // DOM element being bound
    pub link_slot: SlotId,         // LINK node receiving events
    pub event_listeners: Vec<EventListenerHandle>,
}

impl LinkNode {
    // Called when element is created/attached
    fn bind(&mut self, element_id: ElementId, event_loop: &mut EventLoop) {
        // 1. Register DOM event listeners
        // 2. Connect listeners to this LinkNode's event streams
        // 3. Store handles for cleanup
        self.bindings.push(LinkBinding { ... });
    }

    // Called when scope is finalizing (WHILE switch, List/remove)
    fn unbind(&mut self, element_id: ElementId, event_loop: &mut EventLoop) {
        // 1. Remove DOM event listeners
        // 2. Don't emit any more events
        // 3. Clean up handles
        self.bindings.retain(|b| b.element_id != element_id);
    }
}

impl Arena {
    /// Bind LINK from element's IOPad to target
    pub fn bind_link(
        &mut self,
        element_slot: SlotId,
        event_kind: EventKind,
        target_slot: SlotId,
    ) {
        let iopad = self.get_iopad_mut(element_slot, event_kind);
        iopad.link_target = Some(target_slot);

        // Flush buffered events
        for payload in iopad.pending_buffer.drain(..) {
            self.event_loop.enqueue_message(Message {
                source: NodeAddress::new(element_slot, Port::Output),
                target: NodeAddress::new(target_slot, Port::Input(0)),
                payload,
            });
        }
    }
}
```

**Scope safety:** When WHILE switches arms:
1. Old arm's LINK bindings are unbound via scope finalization
2. New arm creates fresh LINK bindings
3. No event leakage between arms

#### Element Function with Events

```rust
pub struct ElementButton;

impl BoonFunction for ElementButton {
    fn path(&self) -> &'static [&'static str] { &["Element", "button"] }
    fn min_args(&self) -> usize { 3 }

    fn call(&self, args: Arguments, ctx: FunctionContext) -> SlotId {
        let [element_slot, style_slot, label_slot] = args.expect_exact::<3>();

        // Create settings Router
        let settings = ctx.arena.alloc_router(ctx.source_id, ctx.scope_id, vec![
            ("style", style_slot),
            ("label", label_slot),
        ]);

        // Create IOPad nodes for events
        let press_iopad = ctx.arena.alloc_iopad(
            ctx.source_id.child(1),
            ctx.scope_id,
            EventKind::Press,
            0,  // No buffering
        );
        let hovered_iopad = ctx.arena.alloc_iopad(
            ctx.source_id.child(2),
            ctx.scope_id,
            EventKind::Hovered,
            0,
        );

        // Create event Router
        let event_router = ctx.arena.alloc_router(ctx.source_id.child(3), ctx.scope_id, vec![
            ("press", press_iopad),
        ]);

        // Create element Router (the output)
        let element_node = ctx.arena.alloc_element_node(
            ctx.source_id,
            ctx.scope_id,
            ElementKind::Button,
            settings,
            Some(element_slot),
            vec![(EventKind::Press, press_iopad), (EventKind::Hovered, hovered_iopad)],
        );

        // Extract event from element argument if present
        if let Some(event_slot) = ctx.arena.try_get_field(element_slot, "event") {
            // Wire element.event.press to our press_iopad (derived event)
            if let Some(press_slot) = ctx.arena.try_get_field(event_slot, "press") {
                ctx.arena.connect(press_iopad, press_slot);
            }
        }

        element_node
    }
}

---

### 2.8.4 Bridge: Arena to Zoon Rendering

The Bridge connects the arena-based runtime to Zoon UI elements.

#### Bridge Architecture

**Document/new rendering mechanism:**
- `Document/new` creates a document binding in the arena (a Router node with `root` field)
- **Browser:** Bridge observes this binding and calls `render()` after each tick
- **CLI:** No Bridge - evaluator materializes document value directly to JSON
- `Document/new` does NOT call a renderer - that's the platform's responsibility

```rust
/// Bridge manages DOM rendering from arena state (browser only)
pub struct Bridge {
    arena: Arc<Arena>,
    event_loop: Arc<EventLoop>,
    /// Map element SlotIds to Zoon element handles
    rendered_elements: HashMap<SlotId, ZoonElementHandle>,
    /// Style property converters
    converters: StyleConverters,
}

impl Bridge {
    /// Called each tick to sync arena state to DOM
    pub fn render(&mut self) {
        // Get document root from arena (created by Document/new)
        let doc_slot = self.arena.get_document_root();
        let root_slot = self.arena.navigate_field(doc_slot, "root");

        // Handle scalar vs element roots
        self.render_root(root_slot);
    }

    /// Render document root - handles both scalar and element types
    fn render_root(&mut self, slot: SlotId) {
        let payload = self.arena.get_value(slot);

        match payload {
            // Scalar roots: render as text content (examples: minimal, interval, fibonacci)
            Payload::Number(n) => self.render_text_content(&n.to_string()),
            Payload::Text(t) => self.render_text_content(t),
            Payload::Bool(b) => self.render_text_content(if *b { "True" } else { "False" }),
            Payload::Unit => self.render_text_content(""),
            Payload::Tag(id) => self.render_text_content(&self.arena.tag_name(*id)),

            // Element root: delegate to element renderer
            Payload::ObjectHandle(element_slot) => {
                if self.arena.is_element_node(*element_slot) {
                    self.render_element(*element_slot);
                } else {
                    // Plain object - materialize as JSON text
                    let json = self.arena.materialize_to_json(*element_slot);
                    self.render_text_content(&json);
                }
            }

            // TaggedObject: check if it's an element wrapper or materialize
            Payload::TaggedObject { tag, fields } => {
                let tag_name = self.arena.tag_name(*tag);
                if tag_name == "NoElement" {
                    // Render nothing
                    self.clear_root();
                } else if self.arena.is_element_node(*fields) {
                    self.render_element(*fields);
                } else {
                    let json = self.arena.materialize_tagged_to_json(*tag, *fields);
                    self.render_text_content(&json);
                }
            }

            _ => self.render_text_content("[unsupported root type]"),
        }
    }

    fn render_text_content(&mut self, text: &str) {
        // Render scalar as simple text node in DOM
        // Implementation: create/update a Text element at document root
    }

    fn clear_root(&mut self) {
        // Remove any rendered content (for NoElement)
    }

    fn render_element(&mut self, slot: SlotId) {
        let node = self.arena.get_element_node(slot);

        match node.kind {
            ElementKind::Button => self.render_button(slot, node),
            ElementKind::Stripe => self.render_stripe(slot, node),
            // ...
        }
    }

    fn render_button(&mut self, slot: SlotId, node: &ElementNode) {
        // Extract style properties
        let font_size = self.extract_style(node.settings_slot, &["style", "font", "size"]);
        let label = self.extract_text(node.settings_slot, &["label"]);

        // Create or update Zoon button
        let btn = Button::new()
            .label(label)
            .style("font-size", font_size);

        // Wire DOM events to IOPads
        let press_iopad = node.event_slots.get(&EventKind::Press);
        btn.on_press(move || {
            self.event_loop.inject_dom_event(press_iopad, Payload::Unit);
        });

        self.rendered_elements.insert(slot, btn.into());
    }
}
```

#### Style Converters

TaggedObjects (Oklch, Duration, etc.) are common in style properties. Converters must handle both the tag and fields:

```rust
pub struct StyleConverters;

impl StyleConverters {
    pub fn number_to_px(payload: &Payload, ctx: &str) -> String {
        format!("{}px", payload.expect_number(ctx))
    }

    /// Handles Oklch[lightness: ..., chroma: ..., hue: ..., alpha: ...]
    /// Fields are optional with defaults: lightness=0.5, chroma=0, hue=0, alpha=1
    pub fn oklch_to_css(payload: &Payload, arena: &Arena, ctx: &str) -> String {
        match payload {
            Payload::TaggedObject { tag, fields } => {
                let tag_name = arena.tag_name(*tag);
                if tag_name != "Oklch" {
                    panic!("{}: expected Oklch, got {}", ctx, tag_name);
                }
                let router = arena.get(*fields);
                // Full field names as used in playground examples (e.g., Oklch[lightness: 0.5])
                let l = router.get_field_or("lightness", Payload::Number(0.5)).expect_number(ctx);
                let c = router.get_field_or("chroma", Payload::Number(0.0)).expect_number(ctx);
                let h = router.get_field_or("hue", Payload::Number(0.0)).expect_number(ctx);
                let alpha = router.get_field_or("alpha", Payload::Number(1.0)).expect_number(ctx);
                format!("oklch({} {} {} / {})", l, c, h, alpha)
            }
            _ => panic!("{}: expected Oklch TaggedObject, got {:?}", ctx, payload),
        }
    }

    /// Handles Duration[milliseconds: ...] for animation properties
    pub fn duration_to_css(payload: &Payload, arena: &Arena, ctx: &str) -> String {
        match payload {
            Payload::TaggedObject { tag, fields } => {
                let tag_name = arena.tag_name(*tag);
                if tag_name != "Duration" {
                    panic!("{}: expected Duration, got {}", ctx, tag_name);
                }
                let router = arena.get(*fields);
                let ms = router.get_field("milliseconds").expect_number(ctx);
                format!("{}ms", ms)
            }
            _ => panic!("{}: expected Duration TaggedObject, got {:?}", ctx, payload),
        }
    }

    pub fn directional_to_css(payload: &Payload, arena: &Arena, ctx: &str) -> String {
        match payload {
            Payload::Number(n) => format!("{}px", n),
            Payload::ObjectHandle(slot) => {
                let router = arena.get(*slot);
                // Extract with row/column fallbacks: [row: 10, column: 5] → "10px 5px 10px 5px"
                let top = router.get_field_or("top",
                    router.get_field_or("row", Payload::Number(0.0))).expect_number(ctx);
                let right = router.get_field_or("right",
                    router.get_field_or("column", Payload::Number(0.0))).expect_number(ctx);
                let bottom = router.get_field_or("bottom",
                    router.get_field_or("row", Payload::Number(0.0))).expect_number(ctx);
                let left = router.get_field_or("left",
                    router.get_field_or("column", Payload::Number(0.0))).expect_number(ctx);
                format!("{}px {}px {}px {}px", top, right, bottom, left)
            }
            _ => panic!("{}: expected Number or Object for padding", ctx),
        }
    }
}
```

---

### 2.8.4.1 Special Tagged Objects for Elements

The 23 validation examples use specific tagged objects for Element configuration:

| TaggedObject | Shape | Meaning | Used By |
|--------------|-------|---------|---------|
| `NoElement` | (tag only) | Empty element / no content | WHILE arms returning "nothing" |
| `Hidden[element]` | `{ element: Element }` | Visually hidden but in DOM | Accessibility, SSR |
| `Reference[element]` | `{ element: Element }` | Reference without ownership | Element sharing |

**NoElement semantics:**
```boon
-- WHILE arm returns NoElement when condition is false
my_element |> WHILE {
    True => Element/container([child: ...])
    False => NoElement  -- Renders as nothing (DOM node removed)
}
```
- Bridge treats `NoElement` as "remove any existing element for this slot"
- CLI JSON materialization outputs `null` for NoElement
- Different from `[]` (Unit) which is a signal, not an element

**Hidden/Reference semantics:**
```boon
-- Hidden preserves element in DOM but not visible
Hidden[element: my_form]

-- Reference for shared element access
Reference[element: shared_element]
```
- `Hidden`: Maps to CSS `visibility: hidden` or similar
- `Reference`: Used for element-based coordination without ownership transfer

---

### 2.8.5 Minimum Stdlib for M1 Validation

The 23 validation examples require these functions to be implemented by the end of M1:

**API Functions (30 total):**

| Category | Functions | Count |
|----------|-----------|-------|
| **Document** | `Document/new` | 1 |
| **Element** | `Element/button`, `Element/checkbox`, `Element/container`, `Element/label`, `Element/link`, `Element/paragraph`, `Element/stack`, `Element/stripe`, `Element/text_input` | 9 |
| **List** | `List/append`, `List/clear`, `List/count`, `List/is_empty`, `List/map`, `List/remove`, `List/retain` | 7 |
| **Router** | `Router/go_to`, `Router/route` | 2 |
| **Timer/Stream** | `Timer/interval`, `Stream/pulses`, `Stream/skip` | 3 |
| **Text** | `Text/empty`, `Text/is_not_empty`, `Text/space`, `Text/trim` | 4 |
| **Math/Bool/Log** | `Math/sum`, `Bool/not`, `Bool/or`, `Log/info` | 4 |

**Tagged Objects (4 total):**

| Tag | Shape | Usage |
|-----|-------|-------|
| `Duration` | `Duration[seconds: Number]` | Timer intervals (runtime normalizes to ms) |
| `Oklch` | `Oklch[lightness:, chroma:, hue:, alpha:]` | Color styling |
| `Hidden` | `Hidden[text: Text]` | Hidden label text (accessibility) |
| `Reference` | `Reference[element: Element]` | Element sharing |

**Duration normalization:** Examples use `Duration[seconds: 1]` for readability. The runtime converts to milliseconds internally (`1000ms`). Both `seconds:` and `milliseconds:` fields are accepted.

**Special Tags:**

| Tag | Shape | Usage |
|-----|-------|-------|
| `NoElement` | (tag only) | Empty element / conditional hide |

**Events (via LINK):**

| Event | Payload | Used By |
|-------|---------|---------|
| `press` | `Unit` | Buttons, checkboxes |
| `click` | `Unit` | General click |
| `double_click` | `Unit` | todo_mvc edit mode |
| `blur` | `Unit` | Input focus loss |
| `change` | `{ text: Text }` | Text input changes |
| `key_down` | `{ key: Tag }` | Keyboard events |

**Syntax Features:**
- `|>.field` - Pipe with immediate field access
- Pattern matching in WHEN (including `__` wildcard)
- SKIP in WHEN arms

**Per-Example Breakdown:**

| Example | Stdlib Functions | Tagged Objects | Events | State Fields |
|---------|------------------|----------------|--------|--------------|
| minimal | Document/new | - | - | - |
| hello_world | Document/new | - | - | - |
| interval | Document/new, Math/sum, Timer/interval | Duration | - | - |
| interval_hold | Document/new, Stream/skip, Timer/interval | Duration | - | - |
| counter | Document/new, Element/button, Element/stripe, Math/sum | - | press | - |
| counter_hold | Document/new, Element/button, Element/stripe | - | press | - |
| fibonacci | Document/new, Log/info, Stream/pulses, Stream/skip | - | - | - |
| layers | Document/new, Element/container, Element/stack | Oklch | - | - |
| shopping_list | Document/new, Element/button, Element/label, Element/stripe, Element/text_input, List/append, List/clear, List/count, List/map, Text/empty, Text/is_not_empty, Text/trim | Hidden, Oklch | change, key_down, press | text |
| pages | Document/new, Element/button, Element/container, Element/label, Element/stripe, Router/go_to, Router/route | Oklch | press | - |
| todo_mvc | Bool/not, Bool/or, Document/new, Element/*, List/*, Router/*, Text/* (full set) | Hidden, Oklch, Reference | blur, change, click, double_click, key_down, press | hovered, text |
| list_retain_count | Document/new, Element/label, Element/stripe, Element/text_input, List/append, List/count, List/map, List/retain, Text/empty | Hidden | change, key_down | text |
| list_map_block | Bool/or, Document/new, Element/label, Element/stripe, List/map | - | - | - |
| list_object_state | Document/new, Element/button, Element/label, Element/stripe, List/map | - | press | - |
| list_retain_reactive | Bool/not, Bool/or, Document/new, Element/button, Element/label, Element/stripe, List/count, List/map, List/retain | - | press | - |
| list_retain_remove | Document/new, Element/label, Element/stripe, Element/text_input, List/append, List/count, List/map, Text/empty, Text/is_not_empty, Text/trim | Hidden | change, key_down | text |
| while_function_call | Bool/not, Document/new, Element/button, Element/label, Element/stripe | - | press | - |
| list_map_external_dep | Bool/not, Document/new, Element/button, Element/label, Element/stripe, List/map | - | press | - |
| text_interpolation_update | Bool/not, Document/new, Element/button, Element/label, Element/stripe | - | press | - |
| button_hover_test | Document/new, Element/button, Element/label, Element/stripe | Oklch | - | hovered |
| switch_hold_test | Bool/not, Document/new, Element/button, Element/label, Element/stripe | Oklch | press | - |
| filter_checkbox_bug | Bool/not, Document/new, Element/button, Element/checkbox, Element/label, Element/stripe, List/map, List/retain | Hidden, Oklch | click, press | checked |
| chained_list_remove_bug | Bool/not, Document/new, Element/button, Element/checkbox, Element/label, Element/stripe, List/append, List/count, List/is_empty, List/map, List/remove, List/retain | Hidden, Oklch | click, press | hovered |

**Coverage Hotspots (single-example features):**

| Feature | Only In | Notes |
|---------|---------|-------|
| `Element/link` | todo_mvc | Navigation links |
| `Element/paragraph` | todo_mvc | Text paragraphs |
| `Text/space` | todo_mvc | Space character constant |
| `Reference[...]` | todo_mvc | Element sharing |
| `double_click` event | todo_mvc | Edit mode trigger |
| `blur` event | todo_mvc | Input focus loss |
| `Element/stack` | layers | Z-axis stacking |
| `Stream/pulses` | fibonacci | Iteration over count |
| `Log/info` | fibonacci | Debug logging |
| `Timer/interval` + `Duration` | interval, interval_hold | Time-based reactivity |

**Implementation priority:** Start with simpler examples (minimal, hello_world, counter) before tackling todo_mvc which exercises the full stdlib.

---

### 2.8.6 Deferred API Functions

Functions used in some examples but deferred beyond M1:

| Function | Node Mapping | Notes |
|----------|--------------|-------|
| `List/any(if:)` | Reducer: emits Bool when any predicate true | |
| `List/every(if:)` | Reducer: emits Bool when all predicates true | |
| `List/latest` | Combiner: emits last item's value | |
| `List/sort_by(key:)` | Transformer: reorders items, emits ListDelta::Move | |
| `List/get(index:)` | Selector: emits value at index | |
| `List/zip(with:)` | Combiner: pairs two lists | |
| `List/chain(...)` | Combiner: sequential processing | |
| `List/to_u_bits` | Converter: List<Bool> to integer | hw_examples |
| `Bits/*` (except not/or/and) | Hardware operations | hw_examples |
| `Memory/*` | RAM/ROM operations | hw_examples |
| `tick`, `impulse` | Timer: single-tick pulse | |
| `delta`, `sum` | Accumulator: change detection, running sum | |
| `increment`, `decrement` | Math: +1/-1 operations | |

---

### 2.8.7 Module Structure (New Engine)

> **Canonical location:** See `plans/M0_CLI__M1_NEW_ENGINE_IN_PLAYGROUND.md` for authoritative file structure.

```
crates/boon/src/
├── engine_v2/                  # Platform-agnostic core
│   ├── mod.rs                  # Re-exports
│   ├── arena.rs                # Arena, SlotId, ReactiveNode
│   ├── node.rs                 # Node kinds (Router, Register, Transformer, Bus, IOPad)
│   ├── message.rs              # Message, Payload
│   ├── event_loop.rs           # EventLoop, timer queue
│   └── routing.rs              # RoutingTable
├── evaluator_v2/               # AST → arena compilation
│   ├── mod.rs                  # Compile functions
│   └── api.rs                  # API function bindings (stdlib)
└── platform/browser/
    └── bridge_v2.rs            # Arena → Zoon rendering
```

Note: API functions are in `evaluator_v2/api.rs`, not a separate `functions/` tree.

---

### 2.8.8 Implementation Phases

**Note:** Bridge/API is built as part of the new engine, not migrated from old.

#### Part of Phase 6: Timer & Events
1. Implement `Timer/interval` API function
2. Implement `Stream/pulses`, `Stream/skip`
3. Implement timer queue integration
4. **Milestone:** `interval.bn`, `fibonacci.bn` work

#### Part of Phase 7: Bridge & UI
1. Implement `BoonFunction` trait and `FunctionRegistry`
2. Implement core functions: `Text/*`, `Math/*`, `Bool/*`
3. Implement element functions: `Element/*`, `Document/*`
4. Implement `Bridge` for arena→Zoon rendering
5. Implement style converters
6. Implement IOPad event handling
7. Implement list functions: `List/*`
8. Implement side-effects: `Log/*`
9. **Milestone:** `counter.bn` with button works, `todo_mvc.bn` works

---

### 2.8.9 Critical Files (New Engine)

| File | Purpose |
|------|---------|
| `src/engine_v2/node.rs` | Node kinds including IOPadNode |
| `src/evaluator_v2/api.rs` | API function bindings (Element/*, Document/*, etc.) |
| `src/platform/browser/bridge_v2.rs` | Arena → Zoon rendering, style converters |

---

### 2.8.10 Benefits Summary

| Aspect | Old Engine | New Engine |
|--------|------------|------------|
| Function definition | Closure in match arm | Implement `BoonFunction` trait |
| Argument access | `Arc<ValueActor>` streams | `SlotId` direct arena access |
| Error messages | "expected Object" | "Element/button: settings.style.font expected Object, got Number" |
| Event handling | ActorLoop + select! | IOPadNode in arena |
| Style extraction | 5-7 flat_map chains | `Arena.navigate_field_path()` |
| Stream lifecycle | Manual `chain(pending())` | Not needed (arena manages lifecycle) |
| User extensibility | None | Implement `BoonFunction` trait, register |
| Debugging | Scattered async streams | Single arena state, deterministic ticks |

---

