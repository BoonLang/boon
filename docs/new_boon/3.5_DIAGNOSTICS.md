## Chapter 3.5: Runtime Diagnostics (boon-console)

Enable observing the reactive graph while it's running - query nodes, subscribe to value changes, and visualize data flow. CLI-first design for AI/tool integration, with future Factorio-like GUI visualization.

**Inspiration**: [tokio-console](https://github.com/tokio-rs/console) - gRPC streaming, instrumentation layer, TUI client

---

### 3.5.1 Architecture Overview

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ Browser Runtime │     │ Server Runtime  │     │  FPGA Runtime   │
│   (WASM)        │     │   (Native)      │     │  (Hardware)     │
└────────┬────────┘     └────────┬────────┘     └────────┬────────┘
         │                       │                       │
         │ WebSocket OUT         │ WebSocket Server      │ JTAG/Debug
         │                       │                       │
         └───────────────┬───────┴───────────────────────┘
                         │
              ┌──────────▼──────────┐
              │  Diagnostics Server │  ← Federation Coordinator
              │  (Relay/Aggregator) │
              └──────────┬──────────┘
                         │
         ┌───────────────┼───────────────┐
         │               │               │
    ┌────▼────┐    ┌─────▼─────┐   ┌─────▼─────┐
    │boon-    │    │ GUI (TUI) │   │ AI/Claude │
    │console  │    │  (Future) │   │   (MCP)   │
    └─────────┘    └───────────┘   └───────────┘
```

**Key design decisions:**

| Aspect | Decision | Rationale |
|--------|----------|-----------|
| Protocol | JSON over WebSocket | Simple, AI-friendly, upgradeable to protobuf |
| Browser transport | Connects OUT to server | Browsers cannot create server sockets |
| Server transport | Embedded WebSocket server | Self-contained, no sidecar needed |
| Federation | Vector clocks | Causal ordering across runtimes |

---

### 3.5.2 Wire Protocol

JSON-RPC 2.0 style over WebSocket. All messages share a common envelope:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "graph.list_nodes",
  "params": { ... },
  "timestamp_ms": 1703345600000
}
```

#### Connection Handshake

```json
// Client → Server
{
  "method": "connect",
  "params": {
    "protocol_version": "1.0",
    "client_id": "boon-console-v0.1",
    "capabilities": { "streaming": true, "batch_updates": true }
  }
}

// Server → Client
{
  "result": {
    "protocol_version": "1.0",
    "runtimes": [{
      "runtime_id": "browser-main",
      "runtime_type": "browser",
      "domain": "Main",
      "current_tick": 12345,
      "node_count": 847
    }],
    "session_id": "sess_abc123"
  }
}
```

#### Node Identification

Nodes are identified by address (stable) and slot (arena location):

```json
{
  "address": {
    "domain": "Main",
    "source_id": { "stable_id": "a1b2c3d4", "parse_order": 42 },
    "scope_id": "e5f6g7h8",
    "port": { "type": "output" }
  },
  "slot_id": { "index": 42, "generation": 3 }
}
```

- **source_id**: Structural hash, survives whitespace changes
- **scope_id**: Runtime instantiation (list items, function calls)
- **port**: Which input/output/field of the node (see Port types in §2.1)
- **slot_id**: Arena location, may change across hot reloads

---

### 3.5.3 Query Methods

#### List Nodes

```json
// Request
{
  "method": "graph.list_nodes",
  "params": {
    "runtime_id": "browser-main",
    "filter": {
      "kinds": ["Register", "Bus", "Router"],
      "dirty_only": false,
      "name_pattern": "todo*"
    },
    "pagination": { "offset": 0, "limit": 100 }
  }
}

// Response
{
  "result": {
    "nodes": [{
      "slot_id": { "index": 42, "generation": 3 },
      "kind": "Register",
      "name": "counter",
      "source_location": { "file": "counter.bn", "line": 5 },
      "is_dirty": false,
      "version": 156
    }],
    "total_count": 847,
    "has_more": true
  }
}
```

#### Get Node Details

```json
// Request
{
  "method": "graph.get_node",
  "params": {
    "runtime_id": "browser-main",
    "node_ref": { "slot_id": { "index": 42, "generation": 3 } },
    "include": ["value", "inputs", "subscribers", "history"]
  }
}

// Response
{
  "result": {
    "node": {
      "slot_id": { "index": 42, "generation": 3 },
      "kind": "Register",
      "name": "counter",
      "current_value": { "type": "Number", "value": 42 },
      "version": 156,
      "last_update_tick": 12340,
      "inputs": [{ "slot_id": { "index": 10 }, "port": "Output" }],
      "subscribers": [{ "slot_id": { "index": 50 } }],
      "history": [
        { "tick": 12340, "value": { "type": "Number", "value": 42 } },
        { "tick": 12335, "value": { "type": "Number", "value": 41 } }
      ]
    }
  }
}
```

---

### 3.5.4 Subscription Methods

#### Subscribe to Value Changes

```json
// Request
{
  "method": "subscribe.node_values",
  "params": {
    "runtime_id": "browser-main",
    "nodes": [{ "slot_id": { "index": 42, "generation": 3 } }],
    "options": {
      "include_initial": true,
      "throttle_ms": 100,
      "batch_window_ms": 16
    }
  }
}

// Initial Response
{
  "result": {
    "subscription_id": "sub_xyz789",
    "initial_values": [{
      "slot_id": { "index": 42, "generation": 3 },
      "value": { "type": "Number", "value": 42 },
      "version": 156
    }]
  }
}

// Streaming Updates
{
  "id": "sub_xyz789",
  "method": "subscription.update",
  "params": {
    "type": "node_values",
    "updates": [{
      "slot_id": { "index": 42, "generation": 3 },
      "old_value": { "type": "Number", "value": 42 },
      "new_value": { "type": "Number", "value": 43 },
      "version": 157,
      "tick": 12341,
      "triggered_by": [{ "slot_id": { "index": 10 } }]
    }]
  },
  "sequence": 1
}
```

#### Subscribe to Tick Events

```json
// Request
{
  "method": "subscribe.ticks",
  "params": {
    "runtime_id": "browser-main",
    "options": {
      "include_dirty_nodes": true,
      "include_effects": true,
      "include_propagation_waves": true
    }
  }
}

// Streaming Updates
{
  "method": "subscription.update",
  "params": {
    "type": "tick",
    "tick_number": 12342,
    "duration_us": 234,
    "trigger": { "type": "dom_event", "event_type": "click" },
    "propagation_waves": [
      { "wave": 0, "nodes": [{ "slot_id": { "index": 10 }, "name": "click_event" }] },
      { "wave": 1, "nodes": [{ "slot_id": { "index": 42 }, "name": "counter" }] }
    ],
    "effects_queued": [{ "type": "ConsoleLog", "message": "Counter is now 43" }]
  }
}
```

#### Subscribe to Graph Structure Changes

```json
// Request
{
  "method": "subscribe.graph_structure",
  "params": {
    "runtime_id": "browser-main",
    "watch": ["node_created", "node_destroyed", "edge_added", "hot_reload"]
  }
}

// Streaming Updates
{
  "method": "subscription.update",
  "params": {
    "type": "graph_structure",
    "changes": [{
      "change_type": "node_created",
      "node": { "slot_id": { "index": 100 }, "kind": "Wire", "name": "new_todo" },
      "tick": 12343
    }]
  }
}
```

---

### 3.5.5 Control Methods

```json
// Pause execution
{ "method": "control.pause", "params": { "runtime_id": "browser-main" } }

// Resume execution
{ "method": "control.resume", "params": { "runtime_id": "browser-main" } }

// Single step (tick, wave, or node)
{ "method": "control.step", "params": { "runtime_id": "browser-main", "step_type": "tick" } }
```

---

### 3.5.6 Value Encoding

```json
{ "type": "Number", "value": 42.5 }
{ "type": "Text", "value": "Hello, World!" }
{ "type": "Tag", "tag_name": "Active" }
{ "type": "Bool", "value": true }
{ "type": "ListHandle", "slot_id": { "index": 100 }, "item_count": 5 }
{ "type": "ObjectHandle", "slot_id": { "index": 101 }, "fields": ["name", "age"] }
```

Large values are truncated with indicator:
```json
{
  "type": "Text",
  "value": "First 1000 chars...",
  "truncated": true,
  "full_length": 50000
}
```

---

### 3.5.7 Instrumentation Layer

#### DiagnosticsHooks Trait

```rust
/// Trait for receiving diagnostic events from the EventLoop.
/// All methods have default no-op implementations for zero-cost when disabled.
pub trait DiagnosticsHooks: Send + Sync {
    // Lifecycle
    fn on_node_created(&self, slot: SlotId, node: &ReactiveNode, tick: u64) {}
    fn on_node_destroyed(&self, slot: SlotId, tick: u64) {}

    // Value flow
    fn on_value_changed(&self, slot: SlotId, old: Option<&Payload>, new: &Payload, tick: u64) {}
    fn on_node_marked_dirty(&self, slot: SlotId, source: Option<SlotId>, tick: u64) {}
    fn on_node_processed(&self, slot: SlotId, result: &ProcessResult, tick: u64) {}

    // Tick lifecycle
    fn on_tick_start(&self, tick: u64, timestamp_ms: f64) {}
    fn on_tick_quiescence(&self, tick: u64, propagation_waves: u32) {}
    fn on_tick_end(&self, tick: u64, duration_ms: f64) {}

    // Effects
    fn on_effect_queued(&self, effect: &NodeEffect, slot: SlotId, tick: u64) {}
    fn on_effect_executed(&self, effect: &NodeEffect, result: &EffectResult, tick: u64) {}
}
```

#### EventLoop Integration

```rust
pub struct EventLoop {
    // Existing fields...
    arena: Arena,
    dirty_nodes: Vec<SlotId>,
    pending_effects: Vec<NodeEffect>,
    current_tick: u64,

    // Diagnostics hook - None when diagnostics disabled
    #[cfg(feature = "diagnostics")]
    hooks: Option<Arc<dyn DiagnosticsHooks>>,
}

impl EventLoop {
    #[cfg(feature = "diagnostics")]
    pub fn attach_diagnostics(&mut self, hooks: Arc<dyn DiagnosticsHooks>) {
        self.hooks = Some(hooks);
    }

    fn notify<F: FnOnce(&dyn DiagnosticsHooks)>(&self, f: F) {
        #[cfg(feature = "diagnostics")]
        if let Some(ref hooks) = self.hooks {
            f(hooks.as_ref());
        }
    }
}
```

---

### 3.5.8 Performance Strategy

| Strategy | Implementation |
|----------|----------------|
| Conditional compilation | `#[cfg(feature = "diagnostics")]` - zero cost when disabled |
| Sampling | Configurable `sample_rate` (0.0-1.0) |
| Throttling | `max_deltas_per_tick`, `max_deltas_per_second` |
| Batching | Updates within same tick batched together |
| History buffer | Ring buffer per node (default 100 entries) |
| Lazy serialization | `OnceCell` for cached JSON |

```rust
pub struct DiagnosticsConfig {
    pub sample_rate: f32,              // 1.0 = every event
    pub max_deltas_per_tick: u32,      // Drop oldest if exceeded
    pub max_deltas_per_second: u32,    // Throttle streaming
    pub history_size_per_node: usize,  // Ring buffer size
    pub excluded_scopes: Vec<ScopeId>, // Skip monitoring
}
```

---

### 3.5.9 Transport Layer

#### Browser Transport (WebSocket Client)

Browsers cannot create server sockets, so runtime connects OUT:

```rust
pub struct BrowserDiagnosticsClient {
    ws: WebSocket,                    // web-sys WebSocket
    runtime_id: RuntimeId,
    reconnect_delay_ms: u32,
}

impl BrowserDiagnosticsClient {
    /// Connect to external diagnostics server
    pub fn connect(url: &str, runtime_id: RuntimeId) -> Self {
        // ws://localhost:9222/boon-diagnostics
    }
}
```

#### Server Transport (Embedded WebSocket Server)

```rust
pub struct ServerDiagnosticsTransport {
    server: Arc<WebSocketServer>,
    clients: Arc<RwLock<Vec<ClientSession>>>,
    delta_tx: broadcast::Sender<DiagnosticsDelta>,
}

impl ServerDiagnosticsTransport {
    /// Start embedded diagnostics server
    pub async fn start(port: u16) -> Result<Self, TransportError> {
        // Bind 0.0.0.0:9222, broadcast deltas to all clients
    }
}
```

---

### 3.5.10 Federation

#### Runtime Identity

```rust
pub struct RuntimeId {
    pub id: u128,        // UUID for this runtime instance
    pub name_hash: u32,  // CRC32 of human-readable name
}

pub enum RuntimeType {
    Browser { user_agent: String },
    Server { hostname: String },
    Worker { parent_runtime: RuntimeId },
    FPGA { device_id: String },
}
```

#### Cross-Runtime Edges

```rust
pub struct FederatedEdge {
    pub source: RemoteNodeRef,  // { runtime_id, slot_id, address }
    pub target: RemoteNodeRef,
    pub transport: EdgeTransport,  // WebSocket, SharedMemory, MessageChannel
    pub latency_stats: LatencyStats,
}
```

#### Vector Clocks for Ordering

```rust
pub struct VectorClock {
    clocks: HashMap<RuntimeId, u64>,
}

impl VectorClock {
    pub fn tick(&mut self, runtime_id: RuntimeId);
    pub fn merge(&mut self, other: &VectorClock, local_id: RuntimeId);
    pub fn happened_before(&self, other: &VectorClock) -> bool;
}
```

---

### 3.5.11 CLI Tool (boon-console)

```bash
# Check connected runtimes
boon-console status

# Query all nodes
boon-console query nodes --filter "kind=Register"

# Get specific node details
boon-console query node --slot 42 --include-history

# Subscribe to value changes (streaming JSON)
boon-console subscribe values --nodes 42,43,44

# Subscribe to all ticks
boon-console subscribe ticks --include-propagation

# Get full snapshot
boon-console snapshot --output graph.json

# Pause/resume execution
boon-console control pause
boon-console control step tick
boon-console control resume
```

**Output format**: JSON by default for AI/tool consumption:
```bash
boon-console query nodes --format json   # Default
boon-console query nodes --format table  # Human-readable
```

---

### 3.5.12 MCP Integration

New MCP tools for Claude Code integration:

```typescript
// Get diagnostics snapshot
boon_diagnostics_snapshot: {
  include_history: boolean,
  include_metrics: boolean
}

// Start streaming deltas
boon_diagnostics_stream: {
  sample_rate: number,
  node_filter: object
}

// Query specific node
boon_query_node: {
  slot_index: number,
  include_subscriptions: boolean,
  history_limit: number
}
```

---

### 3.5.13 Implementation Phases

#### Phase 1: Protocol & Documentation
- Create this document with full protocol spec
- Define JSON schema for all message types

#### Phase 2: Core Instrumentation
- Implement `DiagnosticsHooks` trait
- Add hooks to EventLoop (guarded by feature flag)
- Implement snapshot and delta exports
- Add ring buffer for value history

#### Phase 3: Transport Layer
- Implement `DiagnosticsTransport` trait
- Server transport: embedded WebSocket server
- Browser transport: WebSocket client

#### Phase 4: CLI Tool (boon-console)
- Create new crate for CLI
- Commands: `status`, `query`, `subscribe`, `snapshot`, `control`
- JSON output for AI/tool consumption

#### Phase 5: MCP Integration
- Add diagnostics tools to MCP server
- Integration with Claude Code

#### Phase 6: Federation (Future)
- Implement `FederationCoordinator`
- Vector clocks for causal ordering
- Unified graph view across runtimes

---

### 3.5.14 Critical Files

| File | Purpose |
|------|---------|
| `crates/boon/src/engine_v2/diagnostics/mod.rs` | **NEW:** Public API |
| `crates/boon/src/engine_v2/diagnostics/hooks.rs` | **NEW:** DiagnosticsHooks trait |
| `crates/boon/src/engine_v2/diagnostics/snapshot.rs` | **NEW:** Full graph export |
| `crates/boon/src/engine_v2/diagnostics/delta.rs` | **NEW:** Streaming deltas |
| `crates/boon/src/engine_v2/diagnostics/transport.rs` | **NEW:** Transport abstraction |
| `crates/boon/src/platform/browser/diagnostics_transport.rs` | **NEW:** Browser WS client |
| `crates/boon/src/platform/server/diagnostics_transport.rs` | **NEW:** Server WS server |
| `boon-console/src/main.rs` | **NEW:** CLI entry point |
| `tools/src/mcp/mod.rs` | EXTEND: Add diagnostics tools |
