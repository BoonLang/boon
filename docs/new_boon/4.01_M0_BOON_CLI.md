# Milestone 0: Boon CLI

**Status**: Not Started

## Overview

Create a standalone Boon CLI runtime before integrating the new engine into the playground. This enables faster development iteration, easier unit testing, and provides the foundation for super-counter's CLI and server components.

---

## Success Criteria

- [ ] `boon` CLI binary exists
- [ ] Can execute `.bn` files from command line
- [ ] `boon test` runs Boon test files
- [ ] Unit tests run via standard `cargo test`
- [ ] Basic REPL or eval mode works
- [ ] Platform abstraction traits defined
- [ ] Foundation ready for server runtime (super-counter)

---

## Dependencies

- **Requires**: Parser (already exists in `crates/boon/src/parser/`)
- **Enables**: M1 (New Engine) - faster engine development with unit tests

---

## Rationale

The current development workflow requires:
1. Start mzoon playground server
2. Wait for WASM compilation
3. Open browser
4. Test via MCP tools or manual interaction

With a CLI:
1. Write unit test
2. Run `cargo test`
3. Iterate in seconds

This is especially valuable for developing the new arena-based engine where many small tests are needed.

---

## Key Features

| Feature | Description |
|---------|-------------|
| CLI binary | `boon run file.bn` or `boon eval "code"` |
| Unit testing | Standard Rust tests for engine components |
| Server mode | `boon serve` for HTTP/WebSocket (super-counter backend) |
| No browser deps | Runs without Zoon/WASM |
| Same engine | Shares engine code with playground |

---

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      crates/boon/                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   src/parser/          ← Shared: lexer, parser, AST        │
│                                                             │
│   src/engine/          ← NEW: Platform-agnostic engine     │
│                                                             │
│   src/platform/                                             │
│   ├── browser/         ← Browser-specific (Zoon bridge)    │
│   └── cli/             ← NEW: CLI-specific runtime         │
│                                                             │
│   src/bin/boon.rs      ← NEW: CLI entry point              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Implementation Approach

### Step 1: Extract Platform-Agnostic Engine
- Move core engine logic from `platform/browser/engine.rs` to `engine/`
- Keep browser-specific code (Zoon, DOM) in `platform/browser/`
- Define traits for platform abstraction

### Step 2: Create CLI Runtime
- Implement `platform/cli/` with stdout/stdin for I/O
- No reactive UI - just evaluate and print result
- Support `Log/info` and `Document/new` (renders as text)

### Step 3: Add Binary
- Create `src/bin/boon.rs` entry point
- Parse args: `boon run`, `boon eval`, `boon serve`
- Run `.bn` files and output results

### Step 4: Add Unit Tests
- Test arena allocation
- Test message passing
- Test node behaviors
- Test API functions

---

## CLI Commands

| Command | Description |
|---------|-------------|
| `boon run file.bn` | Execute a Boon file |
| `boon eval "code"` | Evaluate inline code |
| `boon test [files]` | Run Boon test files (CLI testing) |
| `boon serve` | Start server mode (for super-counter) |
| `boon repl` | Interactive REPL (optional) |
| `boon check file.bn` | Type check without running (M2 integration) |

---

## Platform Abstraction

The engine is built with platform abstraction from day one. Core traits define platform-independent interfaces:

```rust
/// Platform-specific timer implementation
pub trait TimerProvider {
    fn set_timeout(&self, duration: Duration) -> TimerId;
    fn set_interval(&self, duration: Duration) -> TimerId;
    fn clear(&self, id: TimerId);
}

/// Platform-specific I/O
pub trait IoProvider {
    fn log(&self, message: &str);
    fn read_file(&self, path: &str) -> Result<String>;
}

/// Platform-specific rendering (optional)
pub trait RenderProvider {
    fn create_element(&self, tag: &str) -> ElementId;
    fn set_attribute(&self, id: ElementId, name: &str, value: &str);
    // ... etc
}
```

**Platform implementations:**

| Platform | Timer | I/O | Render |
|----------|-------|-----|--------|
| CLI | tokio | stdout/files | Text output |
| Browser | Task::microtick (Zoon) | console/fetch | Zoon DOM |
| Server | tokio | files/network | None |

---

## Testing Strategy

- Unit tests for each engine component
- Integration tests with `.bn` example files
- Compare CLI output with playground output
- CI runs tests on every commit

---

## Timing

This milestone can run in **parallel with M1** or even slightly before:
- Start M0 to establish CLI infrastructure
- Use CLI for rapid engine development during M1
- CLI becomes production runtime for M4 (super-counter server)

---

## Related Documentation

- §2.1-2.8 Core Engine - architecture being implemented
- §3.3 Cross-Platform - platform abstraction design
- §6.8 Protocols - serialization and communication formats
- M1 - New Engine uses CLI for testing
- M4 - Super-Counter uses CLI for server component
- M9 - Cross-platform testing extends CLI testing
