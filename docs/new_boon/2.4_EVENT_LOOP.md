## Chapter 2.4: Event Loop

### 2.4.1 Central Scheduler

Replace `Task::start_droppable` with explicit event loop. **Canonical EventLoop definition** (combines all fields):

```rust
pub struct EventLoop {
    // Core state
    arena: Arena,
    timer_queue: BinaryHeap<TimerEvent>,
    dirty_nodes: Vec<SlotId>,
    dom_events: VecDeque<DomEvent>,

    // Tick tracking
    current_tick: u64,
    tick_seq: u64,           // Sequence within tick for ordering

    // Wall-clock integration (see Issue 6)
    tick_start_ms: f64,      // Performance.now() when tick started
    ms_per_tick: f64,        // Default: 16.67 (60 fps)

    // Scope cleanup (see Section 4.4)
    pending_finalizations: Vec<ScopeId>,

    // Effects (see Issue 18)
    pending_effects: Vec<NodeEffect>,
}
```

**NOTE:** No `run_until_idle()` - browser kills page if main thread blocks (see Issue 28). Use `run_tick()` instead.

### 2.4.2 Logical Ticks (Deterministic Ordering)

See **Issue 20** for full tick processing algorithm with quiescence loop.

```rust
impl EventLoop {
    pub fn run_tick(&mut self) {
        self.current_tick += 1;
        self.tick_seq = 0;

        // 1. Collect external inputs
        self.process_timers();
        self.process_dom_events();

        // 2. Propagate until quiescence (see Issue 20 for full algorithm)
        while !self.dirty_nodes.is_empty() {
            // Sort for determinism, process, may add new dirty nodes
            // ...
        }

        // 3. Finalize scopes at tick end
        self.finalize_pending_scopes();

        // 4. Execute effects (after all nodes settled)
        self.execute_pending_effects();
    }
}
```

**Determinism guarantees:**
- Same input events → same output sequence
- Tie-breaking by `{source_id, scope_id, port, tick_seq}`
- Glitch-free: within tick, use last-value semantics

### 2.4.3 Backpressure (Deadlock Prevention)

**Rule:** No node ever blocks. If output queue full, return "not ready".

```rust
pub enum ProcessResult {
    Emitted(Message),
    NotReady,  // Output queue full, retry later
    NoOutput,  // Node consumed input but produced nothing
}

impl EventLoop {
    fn process_node(&mut self, node: SlotId) -> ProcessResult {
        let node = self.arena.get_mut(node);

        // Check if output channel has capacity
        if !node.output_has_capacity() {
            return ProcessResult::NotReady;  // Will retry next tick
        }

        // Process normally
        node.process()
    }
}
```

**Backpressure policies by source type:**
| Source | Policy |
|--------|--------|
| Timer | Drop if full (timer keeps ticking) |
| Mouse move | Coalesce (keep latest position) |
| Click/keypress | Buffer (don't drop user input) |
| Network | Buffer with timeout |

### 2.4.4 Explicit Scope Finalization

**Problem:** Implicit drops cause "receiver is gone" errors.

**Solution:** Scopes are explicitly finalized, not implicitly dropped.

```rust
pub enum ScopeState {
    Active,
    Finalizing,  // Cleanup in progress
    Finalized,   // Ready for deallocation
}

impl Bus {
    fn remove_item(&mut self, key: ItemKey) {
        let scope = self.item_scopes.get_mut(key);

        // 1. Mark as finalizing (no new messages accepted)
        scope.state = ScopeState::Finalizing;

        // 2. Emit cleanup event (subscribers can react)
        self.emit(ListDelta::Remove { key });

        // 3. Schedule finalization for next epoch
        self.event_loop.schedule_finalization(scope.id);
    }
}
```

**Epoch-based deallocation:**
```rust
impl EventLoop {
    fn end_tick(&mut self) {
        // After tick completes, finalize scheduled scopes
        for scope_id in self.pending_finalizations.drain(..) {
            self.finalize_scope(scope_id);
        }
    }

    fn finalize_scope(&mut self, scope_id: ScopeId) {
        // All nodes in scope can now be safely freed
        for slot in self.arena.nodes_in_scope(scope_id) {
            self.arena.free(slot);
        }
    }
}
```

**Benefits:**
- No "receiver is gone" errors mid-processing
- Cleanup is deterministic and debuggable
- Items can emit final events before deallocation
- Safe for multi-threaded execution

### 2.4.5 Timer Implementation

No `async Timer::sleep()`. See **Issue 6** for wall-clock integration and **Issue 30** for backgrounded tab handling.

```rust
// Canonical TimerEvent (from Issue 6) - uses BOTH tick and wall-clock
struct TimerEvent {
    deadline_tick: u64,    // For deterministic ordering
    deadline_ms: f64,      // For precise wall-clock timing
    node_id: SlotId,
}
```

**WASM integration:** Use microtasks for reactive propagation (see §2.4.12).

### 2.4.6 Full Tick Processing (Quiescence Loop)

Complete propagation algorithm:

```rust
impl EventLoop {
    pub fn run_tick(&mut self) {
        self.current_tick += 1;
        self.tick_seq = 0;

        // 1. Collect external inputs
        self.process_timers();
        self.process_dom_events();

        // 2. Propagate until quiescence (no more dirty nodes)
        while !self.dirty_nodes.is_empty() {
            // Sort for determinism
            self.dirty_nodes.sort_by_key(|s| {
                let node = self.arena.get(*s);
                (node.source_id, node.scope_id)
            });

            // Process all dirty nodes for this "wave"
            let to_process: Vec<_> = self.dirty_nodes.drain(..).collect();

            for slot in to_process {
                self.tick_seq += 1;
                let new_dirty = self.process_node(slot);
                self.dirty_nodes.extend(new_dirty);  // May add subscribers
            }
        }

        // 3. Finalize scopes at tick end
        self.finalize_pending_scopes();

        // 4. Execute effects (after all nodes settled)
        self.execute_pending_effects();
    }
}
```

**Glitch-freedom:** Within a tick, nodes see latest values because we iterate until quiescence.

### 2.4.7 Effect Node Model

Side effects (console.log, navigation, localStorage) are handled via effect nodes:

```rust
pub enum NodeEffect {
    None,
    ConsoleLog { level: LogLevel, message: String },
    RouterNavigate { url: String },
    LocalStorageSet { key: String, value: String },
    // ... other effects
}

pub struct EffectNode {
    pub effect_kind: EffectKind,
    pub trigger_input: SlotId,
    pub last_execution_tick: u64,  // Prevent double-run on restore
}

impl EffectNode {
    fn process(&mut self, msg: Message, current_tick: u64) -> Option<NodeEffect> {
        // Idempotency: don't re-run effects for same tick
        if current_tick <= self.last_execution_tick {
            return None;
        }
        self.last_execution_tick = current_tick;

        // Generate effect (executed by EventLoop after tick)
        Some(self.create_effect(&msg))
    }
}
```

**Restore safety:** On snapshot restore, set `last_execution_tick` to restored tick to prevent re-running effects.

### 2.4.8 Effect Restore Validation

What if external state changed during session (user logged out, network unavailable)?

```rust
impl EffectNode {
    fn process_on_restore(&mut self, current_tick: u64) -> EffectResult {
        if current_tick <= self.last_execution_tick {
            return EffectResult::Skip;
        }

        if self.requires_validation {
            match self.validate_preconditions() {
                Ok(()) => {}
                Err(ValidationError::UserLoggedOut) => {
                    return EffectResult::SkipWithWarning("User logged out during session");
                }
                Err(ValidationError::NetworkUnavailable) => {
                    return EffectResult::QueueForRetry;
                }
            }
        }

        self.last_execution_tick = current_tick;
        EffectResult::Execute(self.create_effect())
    }
}

pub enum EffectResult {
    Execute(NodeEffect),
    Skip,
    SkipWithWarning(&'static str),
    QueueForRetry,
}
```

**Effect categories:**
| Effect Type | On Restore | Validation |
|-------------|------------|------------|
| ConsoleLog | Skip (already logged) | None |
| RouterNavigate | Re-execute (URL may differ) | Check if route exists |
| LocalStorageSet | Skip (already set) | None |
| NetworkRequest | Skip or retry | Check network available |
| DOMManipulation | Re-execute (DOM rebuilt) | Check element exists |

### 2.4.9 Stream/pulses Sequential Semantics

`Stream/pulses(n)` emits N values across N ticks (matches FPGA clock semantics):

```rust
pub struct PulsesNode {
    remaining: u32,
    total: u32,
}

impl PulsesNode {
    fn on_input(&mut self, count: u32, event_loop: &mut EventLoop) {
        self.total = count;
        self.remaining = count;
        if self.remaining > 0 {
            event_loop.schedule_next_tick(self.slot_id);
        }
    }

    fn on_tick(&mut self, event_loop: &mut EventLoop) -> Option<Message> {
        if self.remaining > 0 {
            let pulse_index = self.total - self.remaining;
            self.remaining -= 1;

            if self.remaining > 0 {
                event_loop.schedule_next_tick(self.slot_id);
            }

            Some(Message::new(pulse_index))
        } else {
            None
        }
    }
}
```

**Why sequential (not batched):**
- Matches FPGA clock behavior (one value per clock cycle)
- HOLD body sees updated state between each pulse (critical for fibonacci)
- Maps directly to hardware synthesis mental model

### 2.4.10 Async Integration Boundary (Server)

EventLoop is sync internally; async lives at boundary:

```rust
impl EventLoop {
    pub fn handle_network_event(&mut self, event: NetworkEvent) {
        match event {
            NetworkEvent::MessageReceived(msg) => {
                self.enqueue_external_message(msg);
            }
            NetworkEvent::ConnectionClosed(session) => {
                self.schedule_session_cleanup(session);
            }
        }
    }

    pub fn drain_network_effects(&mut self) -> Vec<NetworkEffect> {
        std::mem::take(&mut self.pending_network_effects)
    }
}

// Async wrapper (runs in tokio/async-std)
pub async fn run_server_event_loop(mut event_loop: EventLoop, mut network: NetworkAdapter) {
    loop {
        tokio::select! {
            event = network.recv() => {
                event_loop.handle_network_event(event);
                event_loop.run_tick();

                for effect in event_loop.drain_network_effects() {
                    network.send(effect).await;
                }
            }
            _ = tokio::time::sleep(TICK_INTERVAL) => {
                event_loop.run_tick();
            }
        }
    }
}
```

### 2.4.11 Timer in Backgrounded Tabs

Browser throttles timers when tab is backgrounded:
- `requestAnimationFrame`: Stops completely
- `setTimeout`: Throttled to 1 call/second minimum

**Timer strategy with optional catch-up:**

```rust
pub struct TimerConfig {
    pub max_catchup_ticks: u32,  // 0 = no catchup, 10 = max 10 missed ticks
}

impl EventLoop {
    fn process_timers_with_catchup(&mut self, config: &TimerConfig) {
        let now = performance_now();
        while let Some(event) = self.timer_queue.peek() {
            if event.deadline_ms <= now {
                let event = self.timer_queue.pop().unwrap();
                self.mark_dirty(event.node_id);

                if let Some(interval_ms) = self.get_interval(event.node_id) {
                    let mut next_deadline = event.deadline_ms + interval_ms;
                    let mut catchup_count = 0;

                    // Optional catch-up for missed ticks
                    while next_deadline <= now && catchup_count < config.max_catchup_ticks {
                        self.mark_dirty(event.node_id);
                        next_deadline += interval_ms;
                        catchup_count += 1;
                    }
                    self.schedule_timer_at(event.node_id, next_deadline);
                }
            } else {
                break;
            }
        }
    }
}
```

**Defaults:**
- Animations: `max_catchup_ticks = 0` (just resume from current state)
- Counters/progress: `max_catchup_ticks = 100` (limited catch-up)

**Browser integration:** See §2.4.12 for microtask-based scheduling.

### 2.4.12 Microtask-Based Event Loop (Browser)

**Key insight:** Reactive propagation should use microtasks, not RAF or setTimeout.

| API | Timing | Use Case |
|-----|--------|----------|
| `queueMicrotask()` | After current task, before rendering | **Reactive propagation** |
| `requestAnimationFrame` | Before next repaint (~16ms) | Animation coordination |
| `setTimeout(fn, 0)` | Next event loop turn (4ms+ delay) | Timer scheduling |

**Why microtasks for propagation:**
- **No delay** - setTimeout has minimum 4ms, RAF waits for frame
- **Batching** - Multiple reactive updates complete before repaint
- **Consistency** - Same behavior whether triggered by sync or async code

**Architecture:**

```
┌─────────────────────────────────────────────────────────────┐
│  1. Event Source (DOM event, timer fire, network response) │
└─────────────────────────────────────────────────────────────┘
                              ↓
                     mark_dirty(node_id)
                              ↓
              queueMicrotask(|| run_tick())  ← schedules propagation
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  2. Microtask: run_tick() until quiescence                  │
│     - Process all dirty nodes                               │
│     - Collect DOM updates                                   │
│     - Execute effects                                       │
└─────────────────────────────────────────────────────────────┘
                              ↓
                    Browser renders on next paint
```

**Implementation (inspired by MoonZoon Task::next_micro_tick):**

```rust
// Direct queueMicrotask binding
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_name = queueMicrotask)]
    fn queue_microtask(callback: &js_sys::Function);
}

impl EventLoop {
    /// Schedule propagation as microtask (runs before next render)
    pub fn schedule_tick(&self) {
        if self.tick_scheduled.swap(true, Ordering::SeqCst) {
            return;  // Already scheduled
        }

        let event_loop = self.clone();  // Rc or similar
        let closure = Closure::once(move || {
            event_loop.tick_scheduled.store(false, Ordering::SeqCst);
            event_loop.run_tick();
        });

        queue_microtask(closure.as_ref().unchecked_ref());
        closure.forget();  // Or store handle to prevent drop
    }

    /// Called when any event marks a node dirty
    pub fn mark_dirty(&mut self, node: SlotId) {
        self.dirty_nodes.push(node);
        self.schedule_tick();  // Ensure propagation will run
    }
}
```

**Timer scheduling still uses setTimeout:**
```rust
impl EventLoop {
    pub fn schedule_timer(&mut self, node: SlotId, delay_ms: u32) {
        let event_loop = self.clone();
        set_timeout(
            move || {
                event_loop.mark_dirty(node);  // This schedules microtask
            },
            delay_ms,
        );
    }
}
```

**Execution order example:**
```javascript
console.log('1. sync');
button.click();  // → mark_dirty → queueMicrotask(run_tick)
console.log('2. sync end');
// Microtask: run_tick() executes here
// → '3. propagation complete'
// Browser renders
```

**Benefits:**
- Reactive updates complete before browser paints (no flicker)
- Multiple events in same task batch into single propagation
- No artificial delays from setTimeout/RAF

**Files to modify:**
- `crates/boon/src/platform/browser/engine.rs` - EventLoop replacing ActorLoop
- `crates/boon/src/platform/browser/api.rs` - Timer/interval using EventLoop

---

