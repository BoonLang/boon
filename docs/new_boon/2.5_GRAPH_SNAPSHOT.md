## Chapter 2.5: Graph Snapshot

### 2.5.1 Purpose & Use Cases

GraphSnapshot enables serialization of the complete reactive graph state. Primary use cases:

| Use Case | Description | Timeline |
|----------|-------------|----------|
| **Persistence** | HOLD state survives page reload (localStorage) | M1 |
| **Hot Reload** | Code changes preserve state during development | M1 |
| **Server Sync** | Client/server state synchronization | M4 |
| **Time-Travel Debug** | Step backwards/forwards through state history | Future |
| **Deterministic Replay** | Reproduce bugs from recorded state + events | Future |

**M0/M1 Scope:** Persistence only. State is saved to localStorage on each tick, restored on page load. Time-travel debugging requires recording event history, which is deferred.

**What gets persisted (M1):**
- **Register (HOLD) values** - scalar state
- **Bus (LIST) contents** - item addresses and order
- **AllocSite counters** - for deterministic item identity on restore
- **Nested HOLDs in list items** - e.g., todo_mvc stores `completed` state per item
- **Router fields** - object structure

This is sufficient for todo_mvc: the list of todos (Bus), each todo's completion state (nested HOLDs), and item identity (AllocSite) all persist across page reload.

### 2.5.2 Serializable State

All runtime state must be serializable.

### 2.5.3 GraphSnapshot (Full Definition)

```rust
#[derive(Serialize, Deserialize)]
pub struct GraphSnapshot {
    pub tick: u64,
    pub nodes: Vec<NodeSnapshot>,
    pub timers: Vec<TimerSnapshot>,  // Full timer state for deterministic restore
    pub routing: SerializedRoutingTable,

    // In-flight state for restore
    pub pending_messages: Vec<SerializedMessage>,  // Uses SerializablePayload
    pub pending_dom_events: Vec<DomEvent>,         // Buffered UI events
    pub transport_state: Vec<TransportEdgeSnapshot>,  // For reconnection
}

/// Timer snapshot captures both tick and wall-clock for deterministic restore
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TimerSnapshot {
    pub deadline_tick: u64,    // For deterministic ordering
    pub deadline_ms: f64,      // For precise wall-clock timing
    pub node_address: NodeAddress,
}
```

### 2.5.3 NodeSnapshot (Full Definition)

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NodeSnapshot {
    pub address: NodeAddress,
    pub kind: NodeKindSnapshot,
    pub current_value: Option<SerializablePayload>,  // Handles converted to addresses
    pub version: u64,
    pub dirty: bool,

    // Connections
    pub inputs: Vec<NodeAddress>,
    pub subscribers: Vec<NodeAddress>,

    // Kind-specific state
    pub state: NodeStateSnapshot,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum NodeStateSnapshot {
    Producer,
    Wire,
    Router { fields: HashMap<FieldId, NodeAddress> },  // NodeAddress, NOT SlotId
    Bus { items: Vec<(ItemKey, NodeAddress)>, alloc_site: AllocSite },  // NodeAddress
    Register { stored_value: SerializablePayload },  // Handles converted to addresses
    Combiner { last_input: Option<u8> },
    Transformer,
    SwitchedWire { current_arm: Option<usize> },
    LinkNode { bindings: Vec<LinkBindingSnapshot> },
    Timer { deadline_tick: u64, deadline_ms: f64 },  // Both for determinism
    TextTemplate { template: String, cached: Option<String> },
    Effect { last_execution_tick: u64 },
}

// NOTE: SlotId vs NodeAddress in snapshots:
// - SlotId = local arena reference (index + generation), NOT serialized
// - NodeAddress = stable identifier (source_id + scope_id), used in snapshots
// - Payload with handles → SerializablePayload (converts SlotId to NodeAddress)
// Restore maps NodeAddress → SlotId after arena reconstruction.
```

### 2.5.3.0 SerializablePayload (Handle Conversion)

**Problem:** `Payload::ListHandle(SlotId)` and `Payload::ObjectHandle(SlotId)` contain arena-local references that can't be serialized directly.

**Solution:** Convert handles to `NodeAddress` during serialization:

```rust
/// Payload variant used in snapshots - handles converted to addresses
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum SerializablePayload {
    Number(f64),
    Text(Arc<str>),
    Tag(String),         // Tag NAME, not numeric ID (re-interned on restore)
    Bool(bool),
    Unit,
    ListHandle(NodeAddress),    // NOT SlotId - stable address
    ObjectHandle(NodeAddress),  // NOT SlotId - stable address
    TaggedObject {              // e.g., Duration[seconds: 1]
        tag: String,            // Tag NAME (re-interned on restore)
        fields: NodeAddress,    // NOT SlotId - stable address
    },
    Flushed(Box<SerializablePayload>),
    ListDelta(SerializableListDelta),
    ObjectDelta(ObjectDelta),
}

/// Message variant for snapshots
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SerializedMessage {
    pub source: NodeAddress,
    pub payload: SerializablePayload,
    pub version: u64,
    pub idempotency_key: u64,
}

// Conversion during snapshot (requires arena access, so NOT using From trait)
impl SerializablePayload {
    pub fn from_payload(p: &Payload, arena: &Arena) -> SerializablePayload {
        match p {
            Payload::Number(n) => SerializablePayload::Number(*n),
            Payload::Text(s) => SerializablePayload::Text(s.clone()),
            Payload::Bool(b) => SerializablePayload::Bool(*b),
            Payload::Unit => SerializablePayload::Unit,
            Payload::ListHandle(slot_id) => {
                let addr = arena.get_address(*slot_id).expect("valid slot");
                SerializablePayload::ListHandle(addr.clone())
            }
            Payload::ObjectHandle(slot_id) => {
                let addr = arena.get_address(*slot_id).expect("valid slot");
                SerializablePayload::ObjectHandle(addr.clone())
            }
            Payload::TaggedObject { tag, fields } => {
                let tag_name = INTERN_TABLE.get_name(*tag);
                let addr = arena.get_address(*fields).expect("valid slot");
                SerializablePayload::TaggedObject { tag: tag_name, fields: addr.clone() }
            }
            Payload::Tag(id) => SerializablePayload::Tag(INTERN_TABLE.get_name(*id)),
            Payload::Flushed(inner) => {
                SerializablePayload::Flushed(Box::new(Self::from_payload(inner, arena)))
            }
            // Deltas: convert any embedded handles
            Payload::ListDelta(d) => SerializablePayload::ListDelta(d.serialize(arena)),
            Payload::ObjectDelta(d) => SerializablePayload::ObjectDelta(d.clone()),
        }
    }
}
```

**Restore:** After arena is reconstructed, use address→slot mapping to convert back.

### 2.5.3.1 Tag Interning and Persistence

**Problem:** `Payload::Tag(u32)` uses numeric IDs that are assigned at runtime. Different sessions may assign different IDs to the same tag name.

**Solution:** Snapshots serialize tag **names**, not numeric IDs:

```rust
// Serialization: convert Tag(id) → tag name string
impl Serialize for Payload {
    fn serialize(&self, s: &mut S) -> Result<()> {
        match self {
            Payload::Tag(id) => {
                s.serialize_str(&INTERN_TABLE.get_name(*id))
            }
            // ...
        }
    }
}

// Deserialization: convert tag name → Tag(id)
impl Deserialize for Payload {
    fn deserialize(d: &mut D) -> Result<Self> {
        // For tags, deserialize string and re-intern
        let name = d.deserialize_str()?;
        Ok(Payload::Tag(INTERN_TABLE.intern(&name)))
    }
}
```

**Intern table contract:**
- `intern(name)` returns consistent ID for same name within a session
- Snapshot contains names, restored session re-interns to local IDs
- No cross-session ID stability required

### 2.5.4 Storage Strategy (Large Snapshots)

Full graph snapshot + localStorage will hit 5-10MB limit quickly.

```rust
pub enum StorageBackend {
    LocalStorage,      // Small snapshots only (<1MB)
    IndexedDB,         // Large snapshots (up to 100MB+)
    Custom(Box<dyn SnapshotStore>),
}

pub struct SnapshotConfig {
    pub backend: StorageBackend,
    pub chunking: bool,           // Split large snapshots
    pub compression: bool,        // LZ4/zstd for size reduction
    pub incremental: bool,        // Delta from last snapshot
    pub max_size_bytes: usize,    // Warn/fail if exceeded
}

impl EventLoop {
    pub fn snapshot_with_config(&self, config: &SnapshotConfig) -> Result<SnapshotId, SnapshotError> {
        let snapshot = self.snapshot();
        let serialized = if config.compression {
            compress(serialize(&snapshot))
        } else {
            serialize(&snapshot)
        };

        if serialized.len() > config.max_size_bytes {
            return Err(SnapshotError::TooLarge);
        }

        match config.backend {
            StorageBackend::LocalStorage => store_localstorage(&serialized),
            StorageBackend::IndexedDB => store_indexeddb(&serialized),
            StorageBackend::Custom(store) => store.save(&serialized),
        }
    }
}
```

### 2.5.5 Snapshot/Restore API

```rust
impl EventLoop {
    pub fn snapshot(&self) -> GraphSnapshot { ... }
    pub fn restore(&mut self, snapshot: GraphSnapshot) { ... }
}
```

**Files to modify:**
- `crates/boon/src/engine_v2/snapshot.rs` - GraphSnapshot, NodeSnapshot, serialization

---

