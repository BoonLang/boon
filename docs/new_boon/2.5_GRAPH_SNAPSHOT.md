## Chapter 2.5: Graph Snapshot

### 2.5.1 Serializable State

All runtime state must be serializable.

### 2.5.2 GraphSnapshot (Full Definition)

```rust
#[derive(Serialize, Deserialize)]
pub struct GraphSnapshot {
    pub tick: u64,
    pub nodes: Vec<NodeSnapshot>,
    pub timers: Vec<(u64, NodeAddress)>,
    pub routing: SerializedRoutingTable,

    // In-flight state for restore
    pub pending_messages: Vec<Message>,           // In event queue
    pub pending_dom_events: Vec<DomEvent>,        // Buffered UI events
    pub transport_state: Vec<TransportEdgeSnapshot>,  // For reconnection
}
```

### 2.5.3 NodeSnapshot (Full Definition)

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NodeSnapshot {
    pub address: NodeAddress,
    pub kind: NodeKindSnapshot,
    pub current_value: Option<Payload>,
    pub version: u64,
    pub dirty: bool,

    // Connections
    pub inputs: Vec<NodeAddress>,
    pub subscribers: Vec<NodeAddress>,

    // Kind-specific state
    pub state: NodeStateSnapshot,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum NodeStateSnapshot {
    Producer,
    Wire,
    Router { fields: HashMap<FieldId, NodeAddress> },  // NodeAddress, NOT SlotId
    Bus { items: Vec<(ItemKey, NodeAddress)>, alloc_site: AllocSite },  // NodeAddress
    Register { stored_value: Payload },
    Combiner { last_input: Option<u8> },
    Transformer,
    SwitchedWire { current_arm: Option<usize> },
    LinkNode { bindings: Vec<LinkBindingSnapshot> },
    Timer { next_fire_ms: f64 },
    TextTemplate { template: String, cached: Option<String> },
    Effect { last_execution_tick: u64 },
}

// NOTE: SlotId vs NodeAddress in snapshots:
// - SlotId = local arena reference (index + generation), NOT serialized
// - NodeAddress = stable identifier (source_id + scope_id), used in snapshots
// Restore maps NodeAddress → SlotId after arena reconstruction.
```

### 2.5.3.1 Tag Interning and Persistence

**Problem:** `Payload::Tag(u32)` uses numeric IDs that are assigned at runtime. Different sessions may assign different IDs to the same tag name.

**Solution:** Snapshots serialize tag **names**, not numeric IDs:

```rust
// Serialization: convert Tag(id) → tag name string
impl Serialize for Payload {
    fn serialize(&self, s: &mut S) -> Result<()> {
        match self {
            Payload::Tag(id) => {
                s.serialize_str(&INTERN_TABLE.get_name(*id))
            }
            // ...
        }
    }
}

// Deserialization: convert tag name → Tag(id)
impl Deserialize for Payload {
    fn deserialize(d: &mut D) -> Result<Self> {
        // For tags, deserialize string and re-intern
        let name = d.deserialize_str()?;
        Ok(Payload::Tag(INTERN_TABLE.intern(&name)))
    }
}
```

**Intern table contract:**
- `intern(name)` returns consistent ID for same name within a session
- Snapshot contains names, restored session re-interns to local IDs
- No cross-session ID stability required

### 2.5.4 Storage Strategy (Large Snapshots)

Full graph snapshot + localStorage will hit 5-10MB limit quickly.

```rust
pub enum StorageBackend {
    LocalStorage,      // Small snapshots only (<1MB)
    IndexedDB,         // Large snapshots (up to 100MB+)
    Custom(Box<dyn SnapshotStore>),
}

pub struct SnapshotConfig {
    pub backend: StorageBackend,
    pub chunking: bool,           // Split large snapshots
    pub compression: bool,        // LZ4/zstd for size reduction
    pub incremental: bool,        // Delta from last snapshot
    pub max_size_bytes: usize,    // Warn/fail if exceeded
}

impl EventLoop {
    pub fn snapshot_with_config(&self, config: &SnapshotConfig) -> Result<SnapshotId, SnapshotError> {
        let snapshot = self.snapshot();
        let serialized = if config.compression {
            compress(serialize(&snapshot))
        } else {
            serialize(&snapshot)
        };

        if serialized.len() > config.max_size_bytes {
            return Err(SnapshotError::TooLarge);
        }

        match config.backend {
            StorageBackend::LocalStorage => store_localstorage(&serialized),
            StorageBackend::IndexedDB => store_indexeddb(&serialized),
            StorageBackend::Custom(store) => store.save(&serialized),
        }
    }
}
```

### 2.5.5 Snapshot/Restore API

```rust
impl EventLoop {
    pub fn snapshot(&self) -> GraphSnapshot { ... }
    pub fn restore(&mut self, snapshot: GraphSnapshot) { ... }
}
```

**Files to modify:**
- `crates/boon/src/platform/browser/engine.rs` - Snapshot types and methods

---

