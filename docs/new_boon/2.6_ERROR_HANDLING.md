## Chapter 2.6: Error Handling (FLUSH)

### 2.6.1 FLUSH in Message Payload

FLUSH creates a `Flushed` wrapper that propagates through pipelines.

**See §2.3.1 for canonical Payload definition** - includes `Flushed(Box<Payload>)` variant.

### 2.6.2 FLUSH Semantics

When `FLUSH { ErrorTag[field: value] }` executes:
1. **Local Exit** - Exits current pipeline expression immediately
2. **Wrapper Creation** - Creates `Flushed(ErrorTag[field: value])` payload
3. **Transparent Propagation** - Bypasses all downstream nodes until boundary

**Note:** Error values should use tagged objects with named fields (e.g., `TooLarge[value: input]`) for structured error handling.

### 2.6.3 Node Handling of Flushed

Every node checks for Flushed wrapper:

```rust
impl ReactiveNode {
    fn process_message(&mut self, msg: Message) -> Option<Message> {
        // Check for Flushed - bypass if present
        if let Payload::Flushed(_) = &msg.payload {
            return Some(msg);  // Pass through unchanged
        }
        // Normal processing...
        self.process_normal(msg)
    }
}
```

### 2.6.3.1 Flushed Propagation by Node Kind

**Rule:** `Payload::Flushed` propagates **unchanged** through most node kinds. Only specific boundary nodes unwrap or handle errors specially.

| Node Kind | Flushed Behavior | Notes |
|-----------|------------------|-------|
| **Producer** | N/A | Never receives Flushed (creates values) |
| **Wire** | Pass through unchanged | Transparent propagation |
| **Transformer** | Pass through unchanged | Math ops, Text ops bypass on Flushed |
| **Router** (field access) | Pass through unchanged | `error.field` propagates error |
| **Combiner (LATEST)** | Pass through unchanged | Error from any input propagates |
| **SwitchedWire (WHEN/WHILE)** | Pass through unchanged | Error bypasses pattern matching |
| **Timer** | Pass through unchanged | Error propagates to subscribers |
| **TextTemplate** | Pass through unchanged | `TEXT { {error} }` propagates error |
| **Register (HOLD)** | Special handling | See §2.6.5 - error emits but doesn't store |
| **Bus (List/map)** | Item-level isolation | See §2.6.6 - item fails, list continues |
| **LinkNode** | Unwraps at binding | Error becomes matchable value |
| **Effect (Log, etc.)** | Suppress execution | Logs nothing, propagates error |

**Implementation pattern:**

```rust
fn process_message(&mut self, msg: Message) -> Option<Message> {
    // Early return for Flushed - most nodes do this
    if let Payload::Flushed(_) = &msg.payload {
        return Some(msg);  // Unchanged propagation
    }

    // Normal processing only for non-Flushed payloads
    match &self.kind {
        NodeKind::Transformer { op } => self.transform(msg, op),
        NodeKind::Router { .. } => self.route_field(msg),
        // ...
    }
}
```

**Key invariant:** Pipeline nodes never "swallow" errors. Errors flow to boundaries where they become visible to user code.

### 2.6.4 Boundary Unwrapping

`Flushed(value)` unwraps to `value` at:
- Variable bindings (assignment completes)
- Function returns
- BLOCK returns

### 2.6.5 FLUSH + HOLD Semantics

When HOLD body produces a `Flushed(error)` value, special handling applies:

**The principle: "Errors are transient, state is persistent."**

```boon
initial: 0 |> HOLD state {
    input |> THEN {
        input > 100 |> WHEN {
            True => FLUSH { TooLarge[value: input] }
            False => state + input
        }
    }
}
```

**Behavior when body emits Flushed:**

1. **HOLD does NOT store the error** - Flushed values are not valid state
2. **FLUSH propagates to output** - Subscribers see the Flushed error
3. **State remains at previous valid value** - Next body evaluation still has old state

```rust
impl HoldNode {
    fn process_body_output(&mut self, output: Payload) {
        match output {
            Payload::Flushed(error) => {
                // Do NOT update stored_value
                // Propagate error to subscribers
                self.emit_to_subscribers(Payload::Flushed(error));
            }
            value => {
                // Store new state
                self.stored_value = Some(value.clone());
                // Emit new state to subscribers
                self.emit_to_subscribers(value);
            }
        }
    }
}
```

**Rationale:**
- Errors should not corrupt application state
- Transient failures (network errors, validation errors) shouldn't lose accumulated state
- Subscribers can react to errors (show error UI) while state remains consistent
- Matches reactive principle: state is the "ground truth"

**Type implications:**

```boon
// HOLD produces: T | ErrorType
// Where T is the non-error body output type

count: 0 |> HOLD state {
    // Body can produce: Number | TooLarge
    input > 100 |> WHEN {
        True => FLUSH { TooLarge[value: input] }
        False => state + input
    }
}

// count has type: Number | TooLarge
// Subscribers should use WHEN to handle both cases
display: count |> WHEN {
    TooLarge err => TEXT { Error: {err.value} too large }
    n => TEXT { Count: {n} }
}
```

**Edge case - Initial value is error:**

If the initial value to HOLD is `Flushed(error)`:
- HOLD emits the error (no state stored yet)
- First non-error body output establishes initial state

This is an unusual pattern and typically indicates a design issue.

### 2.6.6 List/map Item-Level Isolation

When one item in List/map flushes, **only that item fails**. Other items continue processing normally. This provides fault isolation within collections.

```rust
pub enum ItemResult {
    Ok(Payload),
    ItemFlushed(ItemKey, Payload),  // This item failed with error
}

impl ListMapNode {
    fn process_item(&mut self, key: ItemKey, value: Payload) -> ItemResult {
        match self.transform(key, value) {
            Ok(result) => ItemResult::Ok(result),
            Err(Flushed(error)) => ItemResult::ItemFlushed(key, error),
        }
    }

    fn process_all(&mut self, items: Vec<(ItemKey, Payload)>) -> ListMapResult {
        let mut results = Vec::new();
        let mut flushed_items = Vec::new();

        for (key, value) in items {
            match self.process_item(key, value.clone()) {
                ItemResult::Ok(result) => results.push((key, result)),
                ItemResult::ItemFlushed(key, error) => {
                    flushed_items.push((key, error));
                    // Continue processing other items!
                }
            }
        }

        ListMapResult { results, flushed_items }
    }
}
```

**Rationale:**
- Fault isolation: One bad item shouldn't break the entire list
- Matches user expectation: If one todo fails to save, others should still work
- Enables error UI: Flushed items can be marked with error indicator

**List/retain with FLUSH:**
- If predicate flushes: Item is NOT retained (treated as false)
- Processing continues for remaining items

### 2.6.7 FLUSH Bridging Rule (Type System ↔ Runtime)

This section clarifies how type-level error unions relate to runtime `Payload::Flushed`.

**The two representations:**

| Level | Representation | Example |
|-------|----------------|---------|
| **Type system** | Union type `T \| ErrorType` | `Number \| ParseError` |
| **Runtime** | `Payload::Flushed(error_payload)` | `Flushed(Tag("ParseError"))` |

**When Flushed wraps/unwraps:**

```
FLUSH { ErrorTag[reason: value] }  → Creates Payload::Flushed(TaggedObject)
   ↓
[pipeline nodes]                    → Flushed passes through unchanged (transparent propagation)
   ↓
binding: expr                       → Flushed UNWRAPS: binding receives the inner error value
                                      (now a normal value that can be pattern-matched)
```

**User visibility rules:**

| Context | Flushed Behavior | User Sees |
|---------|------------------|-----------|
| Mid-pipeline | Transparent propagation | N/A (internal) |
| Variable binding | Unwraps to inner value | Error value (matchable) |
| List/map item | Becomes error item in list | `[ok, ok, Error[...], ok]` |
| CLI root output | Should not reach (unwrapped at binding) | If it does: `{"error": ...}` |
| Golden tests | Unwrapped error values | Normal JSON of error value |

**Key invariant:** By the time a value reaches a variable binding or function output, `Payload::Flushed` has unwrapped. The user sees error **values** (tagged objects like `ParseError[msg: "..."]`), not Flushed wrappers.

**Exception - List/map items:** Inside List/map, failed items become error values in the output list. The list itself is not Flushed; individual items may be error values.

---

