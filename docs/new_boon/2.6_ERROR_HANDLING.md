## Chapter 2.6: Error Handling (FLUSH)

### 2.6.1 FLUSH in Message Payload

FLUSH creates a `Flushed` wrapper that propagates through pipelines.

**See §2.3.1 for canonical Payload definition** - includes `Flushed(Box<Payload>)` variant.

### 2.6.2 FLUSH Semantics

When `FLUSH { error }` executes:
1. **Local Exit** - Exits current pipeline expression immediately
2. **Wrapper Creation** - Creates `Flushed(error)` payload
3. **Transparent Propagation** - Bypasses all downstream nodes until boundary

### 2.6.3 Node Handling of Flushed

Every node checks for Flushed wrapper:

```rust
impl ReactiveNode {
    fn process_message(&mut self, msg: Message) -> Option<Message> {
        // Check for Flushed - bypass if present
        if let Payload::Flushed(_) = &msg.payload {
            return Some(msg);  // Pass through unchanged
        }
        // Normal processing...
        self.process_normal(msg)
    }
}
```

### 2.6.4 Boundary Unwrapping

`Flushed(value)` unwraps to `value` at:
- Variable bindings (assignment completes)
- Function returns
- BLOCK returns

### 2.6.5 List/map Item-Level Isolation

When one item in List/map flushes, **only that item fails**. Other items continue processing normally. This provides fault isolation within collections.

```rust
pub enum ItemResult {
    Ok(Payload),
    ItemFlushed(ItemKey, Payload),  // This item failed with error
}

impl ListMapNode {
    fn process_item(&mut self, key: ItemKey, value: Payload) -> ItemResult {
        match self.transform(key, value) {
            Ok(result) => ItemResult::Ok(result),
            Err(Flushed(error)) => ItemResult::ItemFlushed(key, error),
        }
    }

    fn process_all(&mut self, items: Vec<(ItemKey, Payload)>) -> ListMapResult {
        let mut results = Vec::new();
        let mut flushed_items = Vec::new();

        for (key, value) in items {
            match self.process_item(key, value.clone()) {
                ItemResult::Ok(result) => results.push((key, result)),
                ItemResult::ItemFlushed(key, error) => {
                    flushed_items.push((key, error));
                    // Continue processing other items!
                }
            }
        }

        ListMapResult { results, flushed_items }
    }
}
```

**Rationale:**
- Fault isolation: One bad item shouldn't break the entire list
- Matches user expectation: If one todo fails to save, others should still work
- Enables error UI: Flushed items can be marked with error indicator

**List/retain with FLUSH:**
- If predicate flushes: Item is NOT retained (treated as false)
- Processing continues for remaining items

### 2.6.6 FLUSH Bridging Rule (Type System ↔ Runtime)

This section clarifies how type-level error unions relate to runtime `Payload::Flushed`.

**The two representations:**

| Level | Representation | Example |
|-------|----------------|---------|
| **Type system** | Union type `T \| ErrorType` | `Number \| ParseError` |
| **Runtime** | `Payload::Flushed(error_payload)` | `Flushed(Tag("ParseError"))` |

**When Flushed wraps/unwraps:**

```
FLUSH { error }     → Creates Payload::Flushed(error)
   ↓
[pipeline nodes]    → Flushed passes through unchanged (transparent propagation)
   ↓
binding: expr       → Flushed UNWRAPS: binding receives the inner error value
                      (now a normal value that can be pattern-matched)
```

**User visibility rules:**

| Context | Flushed Behavior | User Sees |
|---------|------------------|-----------|
| Mid-pipeline | Transparent propagation | N/A (internal) |
| Variable binding | Unwraps to inner value | Error value (matchable) |
| List/map item | Becomes error item in list | `[ok, ok, Error[...], ok]` |
| CLI root output | Should not reach (unwrapped at binding) | If it does: `{"error": ...}` |
| Golden tests | Unwrapped error values | Normal JSON of error value |

**Key invariant:** By the time a value reaches a variable binding or function output, `Payload::Flushed` has unwrapped. The user sees error **values** (tagged objects like `ParseError[msg: "..."]`), not Flushed wrappers.

**Exception - List/map items:** Inside List/map, failed items become error values in the output list. The list itself is not Flushed; individual items may be error values.

---

