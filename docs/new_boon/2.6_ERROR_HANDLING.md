## Chapter 2.6: Error Handling (FLUSH)

### 2.6.1 FLUSH in Message Payload

FLUSH creates a `Flushed` wrapper that propagates through pipelines.

**See ยง2.3.1 for canonical Payload definition** - includes `Flushed(Box<Payload>)` variant.

### 2.6.2 FLUSH Semantics

When `FLUSH { error }` executes:
1. **Local Exit** - Exits current pipeline expression immediately
2. **Wrapper Creation** - Creates `Flushed(error)` payload
3. **Transparent Propagation** - Bypasses all downstream nodes until boundary

### 2.6.3 Node Handling of Flushed

Every node checks for Flushed wrapper:

```rust
impl ReactiveNode {
    fn process_message(&mut self, msg: Message) -> Option<Message> {
        // Check for Flushed - bypass if present
        if let Payload::Flushed(_) = &msg.payload {
            return Some(msg);  // Pass through unchanged
        }
        // Normal processing...
        self.process_normal(msg)
    }
}
```

### 2.6.4 Boundary Unwrapping

`Flushed(value)` unwraps to `value` at:
- Variable bindings (assignment completes)
- Function returns
- BLOCK returns

### 2.6.5 List/map Item-Level Isolation

When one item in List/map flushes, **only that item fails**. Other items continue processing normally. This provides fault isolation within collections.

```rust
pub enum ItemResult {
    Ok(Payload),
    ItemFlushed(ItemKey, Payload),  // This item failed with error
}

impl ListMapNode {
    fn process_item(&mut self, key: ItemKey, value: Payload) -> ItemResult {
        match self.transform(key, value) {
            Ok(result) => ItemResult::Ok(result),
            Err(Flushed(error)) => ItemResult::ItemFlushed(key, error),
        }
    }

    fn process_all(&mut self, items: Vec<(ItemKey, Payload)>) -> ListMapResult {
        let mut results = Vec::new();
        let mut flushed_items = Vec::new();

        for (key, value) in items {
            match self.process_item(key, value.clone()) {
                ItemResult::Ok(result) => results.push((key, result)),
                ItemResult::ItemFlushed(key, error) => {
                    flushed_items.push((key, error));
                    // Continue processing other items!
                }
            }
        }

        ListMapResult { results, flushed_items }
    }
}
```

**Rationale:**
- Fault isolation: One bad item shouldn't break the entire list
- Matches user expectation: If one todo fails to save, others should still work
- Enables error UI: Flushed items can be marked with error indicator

**List/retain with FLUSH:**
- If predicate flushes: Item is NOT retained (treated as false)
- Processing continues for remaining items

---

