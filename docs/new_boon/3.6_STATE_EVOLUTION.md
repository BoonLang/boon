## Chapter 3.6: State Evolution

Boon provides **DRAIN + DRAINING** paired markers for state migration. This system handles hot reload, cold restart, refactoring, and cross-domain transfers while preserving all state.

---

### 3.6.1 Overview

**Problem**: State must survive:
- Hot reload (mzoon dev server)
- Cold restart (browser refresh)
- Code movement (refactoring)
- Type changes (add/remove fields)
- Large lists with nested reactive objects (1000+ items with HOLDs)
- Cross-domain transfers (server → frontend)

**Solution**: DRAIN + DRAINING paired markers with automatic invisible list item keys.

**Design principles:**

| Principle | Rationale |
|-----------|-----------|
| **Paired markers** | Can't forget either - compiler enforces both exist |
| **O(1) same-domain** | Arena pointer move, no deep copy |
| **Storage key = destination** | Removing DRAIN preserves state |
| **Invisible item keys** | User never sees or writes keys |
| **Cross-domain flush** | DRAINING triggers protocol before transfer |

---

### 3.6.2 DRAIN + DRAINING Semantics

Migration uses **paired markers** - both must exist together:

```boon
// Old variable marked DRAINING
counter: 0 |> HOLD state { ... } |> DRAINING

// New variable DRAINs from old
click_count: DRAIN { counter } |> HOLD state { ... }
```

#### What Each Marker Does

**DRAINING (on source):**
- Marks variable as "being migrated away"
- Runtime behavior:
  - Stop accepting new upstream triggers
  - Flush pending messages (critical for cross-domain)
  - Prepare state for transfer
- Compile-time: references to DRAINING variable are errors

**DRAIN { target } (on destination):**
- References a DRAINING variable/field inside the block
- Only allows: variable names, field paths (`app.users`), PASSED references
- Inherits state from the source
- Storage key = destination variable name

#### Mechanics

```boon
counter: 0 |> HOLD state { ... } |> DRAINING
click_count: DRAIN { counter } |> HOLD state { ... }
```

1. `counter` marked DRAINING → stops accepting triggers, flushes pending
2. `DRAIN { counter }` transfers ownership to `click_count`
3. `click_count` gets `counter`'s state, stored under key "click_count"
4. All internal state, subscriptions, nested HOLDs preserved
5. O(1) for same-domain (arena pointer move), coordinated for cross-domain

#### Storage Key Behavior

Storage key is based on **destination variable name**:

```boon
// Storage key: "click_count" (not "counter")
click_count: DRAIN { counter } |> HOLD state { ... }
```

**Why this matters**: When you later remove DRAIN, state persists because storage key was always "click_count".

#### Paired Removal

When migration complete, remove BOTH markers:

```boon
// Before: paired markers
counter: 0 |> HOLD state { ... } |> DRAINING
click_count: DRAIN { counter } |> HOLD state { ... }

// After: clean code, state preserved under "click_count"
click_count: 0 |> HOLD state { ... }
```

---

### 3.6.3 Compile-Time Restrictions

All restrictions are **compile-time verifiable**:

| Restriction | Compile-Time Check | Rationale |
|-------------|-------------------|-----------|
| **Paired markers** | Must have DRAIN ↔ DRAINING | Can't forget either |
| DRAINING without DRAIN | Error: orphaned DRAINING | Source has nowhere to drain to |
| DRAIN without DRAINING | Error: invalid source | Can't drain non-draining variable |
| Reference DRAINING var | Error: use-after-draining | Must use new variable name |
| Multiple DRAINs from one | Error: double drain | Each source drained exactly once |
| No conditional DRAIN | Control flow analysis | DRAIN must happen unconditionally |
| No cycles | Graph analysis | A can't drain B while B drains A |

#### Examples

```boon
// ERROR: Orphaned DRAINING (no DRAIN consumes it)
counter: 0 |> HOLD state { ... } |> DRAINING
click_count: 0 |> HOLD state { ... }
// COMPILE ERROR: 'counter' marked DRAINING but no DRAIN references it

// ERROR: DRAIN without DRAINING
counter: 0 |> HOLD state { ... }  // not marked DRAINING!
click_count: DRAIN { counter } |> HOLD state { ... }
// COMPILE ERROR: cannot DRAIN 'counter': not marked DRAINING

// ERROR: Reference to DRAINING variable
counter: 0 |> HOLD state { ... } |> DRAINING
click_count: DRAIN { counter } |> HOLD state { ... }
display: TEXT { {counter} }
// COMPILE ERROR: cannot reference 'counter': marked DRAINING (use 'click_count')

// ERROR: Multiple DRAINs from same source
counter: 0 |> HOLD state { ... } |> DRAINING
a: DRAIN { counter } |> HOLD state { ... }
b: DRAIN { counter } |> HOLD state { ... }
// COMPILE ERROR: multiple DRAINs from 'counter': only one allowed

// ERROR: Conditional DRAIN
old: 0 |> HOLD state { ... } |> DRAINING
condition |> WHEN {
    True => DRAIN { old }   // COMPILE ERROR: DRAIN in conditional
    False => 0
}

// ERROR: Cycle
a: DRAIN { b } |> HOLD state { ... }
b: DRAIN { a } |> HOLD state { ... }
// COMPILE ERROR: DRAIN cycle detected: a → b → a
```

#### Paired Removal Enforcement

```boon
// VALID: Both markers present
counter: 0 |> HOLD state { ... } |> DRAINING
click_count: DRAIN { counter } |> HOLD state { ... }

// ERROR: Removed DRAIN but kept DRAINING
counter: 0 |> HOLD state { ... } |> DRAINING  // orphaned!
click_count: 0 |> HOLD state { ... }
// COMPILE ERROR: 'counter' marked DRAINING but no DRAIN references it

// ERROR: Removed DRAINING but kept DRAIN
counter: 0 |> HOLD state { ... }  // now a normal active variable!
click_count: DRAIN { counter } |> HOLD state { ... }
// COMPILE ERROR: cannot DRAIN 'counter': not marked DRAINING

// VALID: Both markers removed
click_count: 0 |> HOLD state { ... }
// Compiles! State preserved under "click_count" storage key
```

---

### 3.6.4 Field-Level DRAIN

DRAIN works on individual fields, not just whole variables:

```boon
// Old combined scalar state (HOLD only stores scalars/flat objects, see §2.3.3)
app_state: [count: 0, mode: Dark] |> HOLD state { ... } |> DRAINING

// Split into separate variables
count: DRAIN { app_state.count } |> HOLD state { ... }
mode: DRAIN { app_state.mode } |> HOLD state { ... }

// Note: Lists use LIST {} (becomes Bus), NOT HOLD
// Before: users defined elsewhere as LIST {}
// After: users still defined as LIST {} - no DRAIN needed for lists
users: LIST {}  // Bus handles its own identity
```

**Semantics:**
- Drains specific field from scalar/flat object in HOLD
- Parent object still exists but field is empty/removed
- Lists (Bus) handle their own state and don't need DRAIN

---

### 3.6.5 Automatic Item Keys

Lists have automatic identity tracking that users never see.

#### How It Works

```rust
// Runtime internal - user never writes this
pub struct TrackedList {
    next_key: u64,              // Monotonic counter
    items: Vec<TrackedItem>,
}

pub struct TrackedItem {
    key: u64,                   // Invisible to user
    value: Value,
}
```

#### User Experience

```boon
// User writes normal list code - no keys visible
todos:
    LIST { new_todo(title: TEXT { Buy groceries }) }
    |> List/append(item: title_to_add |> new_todo())
    |> List/remove(item, on: item.todo_elements.remove_todo_button.event.press)
```

**What runtime does invisibly:**
- `LIST { ... }` → assigns key 0 to first item
- `List/append` → assigns `next_key++` to new item
- `List/remove` → removes item, key never reused
- Reorder → keys preserved, only order changes

---

### 3.6.6 Nested HOLD Identity

Nested HOLDs in list items use path-based identity:

```boon
// In new_todo function:
completed: False |> HOLD state { ... }
```

**Storage path**: `todos[_key:42].completed`

When list is DRAINed or persisted:
- Each item's internal key preserved
- Nested HOLD paths remain valid
- `_key:42` is internal, user never sees or writes it

---

### 3.6.7 Migration Workflows

#### Simple Rename

```boon
// Step 1: Add paired markers
counter: 0 |> HOLD state { state + 1 } |> DRAINING
click_count: DRAIN { counter } |> HOLD state { state + 1 }

// Step 2: Update all references (compiler forces this - counter is inaccessible)
document: TEXT { Count: {click_count} } |> Document/new()

// Step 3: Remove BOTH markers
click_count: 0 |> HOLD state { state + 1 }
// State preserved under "click_count" storage key
```

#### Add Field to Todo

```boon
// Before: Todo has [text: Text, completed: Bool]
// After: Add priority field

// new_todo function - just add the new field
new_todo: function(title) {
    [
        text: title
        completed: False |> HOLD state { ... }
        priority: Normal  // NEW - defaults for existing items
    ]
}
```

**Automatic handling**: Existing items get default value for new field.

#### Remove Field from Todo

```boon
// Before: Todo has [text, completed, priority]
// After: Remove priority

// Just remove from new_todo - existing priority values ignored on load
new_todo: function(title) {
    [
        text: title
        completed: False |> HOLD state { ... }
        // priority removed - old stored values ignored
    ]
}
```

#### Split Variable

```boon
// Before: Combined scalar state (see §2.3.3 - HOLD only stores scalars/flat objects)
app: [count: 0, mode: Dark] |> HOLD state { ... }

// Step 1: Mark app as DRAINING, add field-level DRAINs
app: [count: 0, mode: Dark] |> HOLD state { ... } |> DRAINING
count: DRAIN { app.count } |> HOLD state { ... }
mode: DRAIN { app.mode } |> HOLD state { ... }

// Step 2: Remove all markers
count: 0 |> HOLD state { ... }
mode: Dark |> HOLD state { ... }

// Note: Lists (Bus) are separate variables, not nested in HOLD
users: LIST {}  // No DRAIN needed - Bus manages its own identity
```

#### Cross-Module DRAIN

```boon
// module_a.bn - scalar state to migrate
settings: [theme: Dark, lang: EN] |> HOLD state { ... } |> DRAINING

// module_b.bn (imports module_a)
import module_a

// DRAIN from imported module (works for scalars/flat objects)
local_settings: DRAIN { module_a.settings } |> HOLD state { ... }

// Note: Lists don't need DRAIN - they're Bus nodes with their own identity
// module_a.bn
users: LIST {}  // Bus handles its own state

// module_b.bn - just reference directly, no DRAIN needed
import module_a
local_users: module_a.users  // Wire to imported Bus
```

**Compile-time tracking**: Compiler tracks DRAIN/DRAINING across module boundaries, ensures paired markers exist.

---

### 3.6.8 Cross-Domain Protocol

For server → frontend (no shared memory), DRAINING triggers a coordination protocol:

```
Backend                          Network                    Frontend
───────                          ───────                    ────────
1. users |> DRAINING
   - Stop new triggers
   - Flush pending msgs         ──→ [in-flight msgs] ──→   receive msgs
2. Wait for acks                ←── [acks] ←──────────     process msgs
3. Serialize final state        ──→ [state blob] ──────→
4. Remove 'users' node                                     4. users |> DRAIN
                                                              receives state
                                                           5. Create local_users
```

#### Cross-Domain Example

```boon
// Backend (server.bn) - scalar state migration
app_config: [theme: Dark, locale: EN] |> HOLD state { ... } |> DRAINING

// Frontend (app.bn)
import server

local_config: DRAIN { server.app_config } |> HOLD state { ... }

// Note: Lists work differently - they're Bus nodes that sync via delta streams
// Backend list state is replicated to frontend via WebSocket, not DRAIN
// See §6.8 for client-server sync protocol
```

#### Protocol Implementation

```rust
// Backend: DRAINING triggers this
impl CrossDomainDrain {
    async fn execute_draining(&mut self, var: &str) -> DrainToken {
        let node = self.get_node(var);

        // 1. Stop accepting new upstream triggers
        node.disconnect_upstream();

        // 2. Flush pending messages to all subscribers
        node.flush_pending().await;

        // 3. Wait for delivery confirmations
        node.wait_for_acks().await;

        // 4. Serialize final state
        DrainToken {
            source_key: var.to_string(),
            final_state: node.serialize(),
            sequence: node.final_sequence(),
        }
    }
}

// Frontend: DRAIN receives token
impl CrossDomainDrain {
    fn receive_drain(&mut self, token: DrainToken) -> Value {
        // Verify no lost messages
        assert_eq!(token.sequence, self.expected_seq);

        // Deserialize into local arena
        self.deserialize(token.final_state)
    }
}
```

---

### 3.6.9 Runtime-Specific Behavior

| Runtime | DRAINING Behavior | DRAIN Behavior |
|---------|-------------------|----------------|
| **FPGA** | Synthesis: mark for address remap | Synthesis: inherit MRAM address |
| **Browser** | At tick boundary: snapshot state | At tick boundary: load from storage |
| **Server** | Epoch barrier: flush + persist | Epoch boundary: load from storage |
| **Cross-domain** | Coordinated protocol: flush + transfer | Receive token, deserialize |

---

### 3.6.10 Critical Invariants

#### Invariant 1: Markers Don't Affect State Identity

DRAINING is **migration metadata**, not part of storage key:

```boon
// All of these have storage key "counter"
counter: 0 |> HOLD state { ... }
counter: 0 |> HOLD state { ... } |> DRAINING   // Same key!

// Adding DRAINING doesn't reset state
// State persists under "counter" until drain completes
```

**Why this matters:** If adding DRAINING reset state, migration would be useless.

#### Invariant 2: Can't Remove Markers During Active Drain

Deployment must be blocked if drain is in progress:

```
Timeline:
─────────
T0: Deploy code with DRAIN+DRAINING → migration starts
T1: Flush in progress (messages transferring)...
T2: Try deploy code WITHOUT markers → BLOCKED (would cause data loss!)
T3: Transfer completes
T4: Deploy code WITHOUT markers → OK (state safely in destination)
```

**Deployment rules:**

| Current State | Attempted Deploy | Result |
|---------------|------------------|--------|
| No active drain | Add DRAIN+DRAINING | OK - starts migration |
| Drain in progress | Keep both markers | OK - continue migration |
| Drain in progress | Remove any marker | **BLOCKED** - data loss |
| Drain completed | Remove both markers | OK - safe |

#### Invariant 3: State Flow Is Preserved

| Phase | Source Storage | Destination Storage |
|-------|----------------|---------------------|
| Before migration | "counter" → 42 | (empty) |
| Add DRAINING + DRAIN { } | "counter" → 42 (marked) | "click_count" → waiting |
| Transfer completes | "counter" → (drained) | "click_count" → 42 |
| Remove markers | "counter" → (GC'd) | "click_count" → 42 |

**Key points:**
- State never disappears during migration
- Source remains readable until transfer completes
- Destination receives complete state
- Markers can be safely removed only after completion

---

### 3.6.11 Implementation

#### Parser

DRAIN and DRAINING auto-tokenize as keywords (all multi-letter capitals are keywords).

Parser changes:
- `|> DRAINING` - pipeline operator that marks variable as draining source
- `DRAIN { target }` - block expression that drains from named DRAINING variable/field

**DRAIN block only allows:**
```rust
enum DrainTarget {
    Variable(String),           // DRAIN { counter }
    FieldPath(Vec<String>),     // DRAIN { app.users.settings }
    PassedField(String),        // DRAIN { PASSED.config }
}
// NOT arbitrary expressions - enforced at parse time
```

#### Compiler Analysis

```rust
pub struct DrainAnalysis {
    draining_vars: HashSet<VarId>,     // Variables marked DRAINING
    drain_sources: HashMap<VarId, VarId>,  // destination → source
}

impl DrainAnalysis {
    fn check_paired(&self) -> Result<(), Error> {
        // Every DRAINING must have exactly one DRAIN
        for draining in &self.draining_vars {
            if !self.drain_sources.values().any(|s| s == draining) {
                return Err(Error::OrphanedDraining { var: *draining });
            }
        }
        // Every DRAIN source must be DRAINING
        for source in self.drain_sources.values() {
            if !self.draining_vars.contains(source) {
                return Err(Error::DrainFromNonDraining { source: *source });
            }
        }
        Ok(())
    }
}
```

#### Arena Integration

```rust
impl Arena {
    /// O(1) ownership transfer
    fn drain(&mut self, source: SlotId) -> DrainedValue {
        let node = self.slots[source.index].take();
        DrainedValue { node, original_slot: source }
    }

    fn receive_drain(&mut self, target: SlotId, drained: DrainedValue) {
        self.slots[target.index] = Some(drained.node);
        // Subscriptions automatically follow the node
    }
}
```

---

### 3.6.12 Performance

| Operation | Complexity | Notes |
|-----------|------------|-------|
| DRAIN (same-domain) | O(1) | Arena pointer move |
| DRAIN (cross-domain) | O(n) | Serialization + network |
| List item lookup | O(1) | Internal key → HashMap |
| Storage key compute | O(1) | Variable name hash |
| Full snapshot | O(n) | n = total entities |
| Incremental save | O(k) | k = changed entities |

---

