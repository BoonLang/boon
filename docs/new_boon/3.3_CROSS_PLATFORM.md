## Chapter 3.3: Cross-Platform

This section designs a trait-based abstraction layer enabling a single `boon` crate to run on browser (WASM), server (native tokio), and CLI platforms.

### 3.3.1 Feasibility Assessment

**Current Platform Distribution:**
| Category | LOC | Percentage |
|----------|-----|------------|
| Platform-agnostic (parser, core engine) | ~17,500 | 78% |
| Browser-specific (bridge, some API) | ~5,700 | 22% |

**Abstraction Cost:**
- New trait code: ~1,050 LOC
- Refactoring existing: ~300 LOC
- **ROI: 33:1** (vs duplicating 17,500 LOC for server + CLI)

### 3.3.2 Core Platform Traits

The sync EventLoop (see §2.4) needs platform support for scheduling, storage, and logging. Platform provides **callbacks**, not async futures.

```rust
// platform/traits.rs

/// Schedule future work. Sync core, platform handles async wake-up.
pub trait PlatformTimer {
    /// Schedule next EventLoop tick after delay_ms
    fn schedule_tick(&self, delay_ms: u32, callback: Box<dyn FnOnce() + 'static>);

    /// Schedule work before next paint (browser) or immediately (CLI)
    fn schedule_microtask(&self, callback: Box<dyn FnOnce() + 'static>);

    /// Current wall-clock time in milliseconds
    fn now_ms(&self) -> f64;
}

/// Persist and restore snapshots
pub trait PlatformStorage {
    fn load(&self, key: &str) -> Option<String>;
    fn save(&self, key: &str, value: &str);
    fn remove(&self, key: &str);
}

/// Logger abstraction
pub trait PlatformLog {
    fn info(&self, msg: &str);
    fn warn(&self, msg: &str);
    fn error(&self, msg: &str);
}

/// Combined platform interface (passed to EventLoop)
pub struct Platform {
    pub timer: Box<dyn PlatformTimer>,
    pub storage: Box<dyn PlatformStorage>,
    pub log: Box<dyn PlatformLog>,
}
```

**Key design points:**
- EventLoop is **sync** (`run_tick()`), not async
- Platform provides **callbacks** (`schedule_tick`, `schedule_microtask`), not futures
- No `spawn_droppable` or `async fn sleep()` - those belong to old actor model

### 3.3.3 Platform Implementations

| Platform | Timer | Storage | Log |
|----------|-------|---------|-----|
| **Browser** | `queueMicrotask` / `setTimeout` | `localStorage` | `console.log` |
| **CLI** | tokio oneshot + sleep | File-based | `println!` |
| **Server** | tokio timers | Redis/file | `tracing` |

**NOT in platform traits (handled by bridge):**
- DOM rendering (browser-only)
- Element creation (browser-only)
- Event listeners (browser-only)

### 3.3.4 Feature Flags

```toml
[features]
default = ["platform-browser"]

# Platform features - mutually exclusive
platform-browser = ["zoon", "web-sys", "wasm-bindgen"]
platform-server = ["tokio/full"]
platform-cli = ["tokio/rt"]  # Minimal runtime

# Engine selection (during migration)
engine-v1 = []  # Old actor engine
engine-v2 = []  # New arena engine
```

### 3.3.5 Browser Platform Implementation

```rust
// platform/browser/timer.rs
pub struct BrowserTimer;

impl PlatformTimer for BrowserTimer {
    fn schedule_tick(&self, delay_ms: u32, callback: Box<dyn FnOnce() + 'static>) {
        // setTimeout wrapper
        set_timeout(callback, delay_ms);
    }

    fn schedule_microtask(&self, callback: Box<dyn FnOnce() + 'static>) {
        // queueMicrotask for immediate (before paint) execution
        queue_microtask(callback);
    }

    fn now_ms(&self) -> f64 {
        web_sys::window()
            .unwrap()
            .performance()
            .unwrap()
            .now()
    }
}

// platform/browser/storage.rs
pub struct LocalStorageBackend;

impl PlatformStorage for LocalStorageBackend {
    fn load(&self, key: &str) -> Option<String> {
        web_sys::window()
            .unwrap()
            .local_storage()
            .unwrap()
            .unwrap()
            .get_item(key)
            .unwrap()
    }

    fn save(&self, key: &str, value: &str) {
        web_sys::window()
            .unwrap()
            .local_storage()
            .unwrap()
            .unwrap()
            .set_item(key, value)
            .unwrap();
    }

    fn remove(&self, key: &str) {
        web_sys::window()
            .unwrap()
            .local_storage()
            .unwrap()
            .unwrap()
            .remove_item(key)
            .unwrap();
    }
}
```

### 3.3.6 CLI Platform Implementation

```rust
// platform/cli/timer.rs
use tokio::time::{sleep, Duration};
use tokio::sync::oneshot;

pub struct TokioTimer {
    handle: tokio::runtime::Handle,
}

impl PlatformTimer for TokioTimer {
    fn schedule_tick(&self, delay_ms: u32, callback: Box<dyn FnOnce() + 'static>) {
        self.handle.spawn(async move {
            sleep(Duration::from_millis(delay_ms as u64)).await;
            callback();
        });
    }

    fn schedule_microtask(&self, callback: Box<dyn FnOnce() + 'static>) {
        // CLI: Run immediately (no paint cycle like browser)
        //
        // REENTRANCY GUARD: EventLoop has in_tick flag (see §2.4 for full solution)
        // - in_tick is true during run_tick() execution
        // - If schedule_tick() is called while in_tick=true, it defers to pending_ticks
        // - At end of run_tick(), pending_ticks is checked and another tick scheduled if needed
        //
        // This prevents nested run_tick() calls while ensuring no events are lost.
        callback();
    }

    fn now_ms(&self) -> f64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs_f64() * 1000.0
    }
}

// platform/cli/storage.rs
pub struct FileStorage {
    base_path: PathBuf,
}

impl PlatformStorage for FileStorage {
    fn load(&self, key: &str) -> Option<String> {
        let path = self.base_path.join(format!("{}.json", key));
        std::fs::read_to_string(path).ok()
    }

    fn save(&self, key: &str, value: &str) {
        let path = self.base_path.join(format!("{}.json", key));
        std::fs::create_dir_all(&self.base_path).unwrap();
        std::fs::write(path, value).unwrap();
    }

    fn remove(&self, key: &str) {
        let path = self.base_path.join(format!("{}.json", key));
        let _ = std::fs::remove_file(path);
    }
}
```

### 3.3.7 API Function Portability

**Universal (All Platforms) - ~1,590 LOC:**
- Math/*, Text/*, Bool/*, List/*, Stream/*
- Ulid/*, Log/*, File/*, Directory/*, Build/*
- Document/new (outputs JSON in CLI, renders DOM in browser)
- Element/* (creates portable element data; CLI outputs JSON, browser renders DOM)

**Browser-Rendered (Uses Universal Element Data) - ~1,500 LOC:**
- Bridge: arena → Zoon DOM element rendering
- Router/*, Scene/*, Theme/* (browser navigation/styling)

**Important:** Element/* functions are **universal** - they create portable data structures (Router nodes with kind, style, children fields). The **rendering** is platform-specific:
- **Browser:** Bridge converts element data → Zoon DOM elements
- **CLI:** materialize() serializes element data → JSON output

**Platform-Variant:**
- Timer/interval: uses `PlatformTimer::schedule_tick()`
- Log/*: uses `PlatformLog`
- State persistence: uses `PlatformStorage`

### 3.3.8 Module Reorganization

```
crates/boon/src/
  parser/              # 100% platform-agnostic (unchanged)

  engine_v2/           # Core engine (platform-agnostic)
    arena.rs           # Arena, SlotId, ReactiveNode
    node.rs            # NodeKind variants
    message.rs         # Message, Payload
    event_loop.rs      # EventLoop, run_tick()
    routing.rs         # RoutingTable
    snapshot.rs        # GraphSnapshot

  evaluator_v2/        # Platform-agnostic evaluation
    mod.rs             # AST → arena compilation
    api.rs             # API function dispatch (M0/M1: all API functions here)

  # FUTURE REFACTOR (post-M1): Split api.rs into modular tree
  # api/
  #   universal/         # Platform-agnostic functions
  #     text.rs, bool.rs, list.rs, stream.rs, math.rs
  #   browser/           # Browser-only (feature-gated)
  #     element.rs, document.rs, router.rs

  platform/
    mod.rs             # Platform struct, traits
    traits.rs          # PlatformTimer, PlatformStorage, PlatformLog
    browser/           # Browser implementation
      timer.rs         # queueMicrotask / setTimeout
      storage.rs       # localStorage
      bridge.rs        # Arena → Zoon elements
    cli/               # CLI implementation
      timer.rs         # tokio-based
      storage.rs       # file-based
```

### 3.3.9 EventLoop Integration

The EventLoop receives a `Platform` reference and uses it for all platform-specific operations:

```rust
impl EventLoop {
    pub fn new(platform: Platform) -> Self {
        Self {
            platform,
            arena: Arena::new(),
            dirty_nodes: Vec::new(),
            timer_queue: BinaryHeap::new(),
            // ...
        }
    }

    pub fn schedule_timer(&mut self, node: SlotId, delay_ms: u32) {
        let deadline_ms = self.platform.timer.now_ms() + delay_ms as f64;
        self.timer_queue.push(TimerEvent {
            deadline_ms,
            node_id: node,
        });

        // Schedule platform wake-up
        let event_loop = self.clone();
        self.platform.timer.schedule_tick(delay_ms, Box::new(move || {
            event_loop.run_tick();
        }));
    }

    pub fn mark_dirty(&mut self, node: SlotId) {
        self.dirty_nodes.push(node);

        // Ensure tick runs (microtask for browser, immediate for CLI)
        let event_loop = self.clone();
        self.platform.timer.schedule_microtask(Box::new(move || {
            event_loop.run_tick();
        }));
    }
}
```

### 3.3.10 Benefits vs Costs

**Benefits:**
- Single source of truth (85% code shared)
- Consistent behavior across platforms
- Fast native testing (no WASM overhead)
- Future-proof (iOS, Android = just new trait impls)
- Enables SSR and CLI tooling

**Costs:**
- ~1,050 LOC of abstraction code
- Must test on all platforms

### 3.3.11 Summary

| Metric | Value |
|--------|-------|
| New abstraction code | ~1,050 LOC |
| Code duplication avoided | ~35,000 LOC |
| ROI | 33:1 |
| Shared code ratio | 85% |
| Platforms supported | Browser, Server, CLI |
| Complexity | Low (3 simple traits) |

**Verdict:** Unified engine with sync EventLoop + platform callbacks is simpler and more portable than async trait-based approach.

---

