# Chapter 5.3: Fixed-Size Philosophy

**Status:** Research / Future consideration
**Inspiration:** TigerBeetle's deterministic, fixed-allocation database design

This section explores whether the fixed-size constraints required for FPGA synthesis (§5.1) could also benefit the browser/server/CLI runtime (§2-3).

---

## 5.3.1 What is Fixed-Size Philosophy?

TigerBeetle's approach:
- **No dynamic allocation in hot path** - transactions are fixed-size records
- **Static limits are features** - forces design decisions upfront
- **Determinism enables debugging** - same input = same behavior always
- **Predictable performance** - no GC pauses, no allocation jitter

Their styleguide: prefer arrays over hashmaps, fixed buffers over dynamic strings, stack over heap, pre-compute sizes at compile time.

---

## 5.3.2 Pros for Web Apps/Servers/CLIs

### 5.3.2.1 Predictable Memory

```
Server with dynamic allocation:
  Request 1: 2MB → 5MB → 3MB → ??? (fragmentation)
  After 1M requests: Who knows? OOM at 3am.

Server with fixed-size:
  Each request: exactly 64KB arena
  1M requests: still exactly 64KB per request
  Capacity planning: trivial
```

You can calculate **exactly** how many concurrent users your server supports.

### 5.3.2.2 FPGA/Hardware Portability

Same code runs in browser AND synthesizes to FPGA. This is the killer feature:

```boon
-- This exact code could run in browser OR become hardware
counter: BITS[32] { 10u0 } |> HOLD state {
    PASSED.clk |> THEN { state |> Bits/add(BITS[32] { 10u1 }) }
}
```

### 5.3.2.3 Better Performance

- No allocator overhead at runtime
- Better cache locality (contiguous memory)
- No GC pauses or cleanup sweeps
- Deterministic latency (critical for real-time UIs)

### 5.3.2.4 Simpler Mental Model

Forces explicit resource thinking. The fixed version makes you answer: What happens when full? Ring buffer? Error? Pagination?

### 5.3.2.5 Security

- No buffer overflows from unbounded growth
- DoS attacks can't exhaust memory (fixed cap)
- Deterministic behavior aids security auditing

### 5.3.2.6 Debugging

- Memory layout is static - easier to inspect
- No heap corruption mysteries
- Bugs reproduce deterministically

---

## 5.3.3 Cons for Web Apps/Servers/CLIs

### 5.3.3.1 Flexibility Loss

```boon
-- User wants 101 todos but max is 100
-- "Sorry, delete something first" - bad UX?
```

Web conventions expect "unlimited" (or very high limits).

### 5.3.3.2 Over-Provisioning Waste

```
If MAX_TODOS = 1000 but typical user has 10:
  990 slots × sizeof(Todo) = wasted per user

For 1M users: potentially gigabytes of unused reserved memory
```

Dynamic allocation only uses what's needed.

### 5.3.3.3 Development Friction

- Must decide sizes **upfront** (often hard to know correct values)
- Changing limits requires recompilation/redeployment
- Prototype→production size mismatch causes surprises

### 5.3.3.4 Web Ecosystem Incompatibility

```
JSON response: {"items": [...unknown length...]}
DOM: arbitrary number of child elements
User input: copy-paste of arbitrary text
File upload: arbitrary size
```

The web is fundamentally dynamic at its boundaries.

### 5.3.3.5 Some Algorithms Need Dynamic Structures

- Trees/graphs with unknown topology
- Text editing (undo history, selections)
- Markdown/rich text parsing (nested structures)

### 5.3.3.6 Cold Path Overhead

TigerBeetle's hot path (transactions) is fixed. But web apps have many "cold paths" (admin panels, reports, settings) where fixed-size overhead is unnecessary.

---

## 5.3.4 The Key Insight: Boundary Placement

TigerBeetle's boundary: **Fixed core, dynamic at network edge**

Boon's boundary could be: **Fixed reactive graph, dynamic at persistence/network edge**

```
┌─────────────────────────────────────────────────────────────────┐
│                      FIXED-SIZE ZONE                             │
│                                                                  │
│   Reactive State (LATEST, HOLD, WHEN, WHILE)                    │
│   - All LIST[N, T] with compile-time N                          │
│   - All BITS[N] with compile-time N                             │
│   - All records with fixed fields                               │
│   - Arena-allocated, deterministic                              │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                      BOUNDARY ADAPTERS                           │
│                                                                  │
│   - JSON parsing: schema-validated, bounded                     │
│   - DOM rendering: virtual/pooled elements                      │
│   - User input: bounded TEXT[N]                                 │
│   - File I/O: streaming with fixed buffers                      │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                      DYNAMIC ZONE                                │
│                                                                  │
│   - IndexedDB / Server database (unbounded storage)             │
│   - Network responses (parsed into fixed structures)            │
│   - File system (accessed via streams)                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5.3.5 Practical Patterns (Corrected Boon Syntax)

### 5.3.5.1 Fixed Window into Unbounded Data

```boon
PAGE_SIZE: 20

-- Only keep visible items in reactive state (not all items)
visible_todos: [first: None, ...] |> HOLD state {
    scroll_event |> THEN {
        -- Load next page from IndexedDB/server
        -- Replace window contents, don't grow
        fetch_page(offset: new_offset)
    }
}

-- Total count for UI, but not all items in memory
todo_count: 0 |> HOLD state {
    count_changed |> THEN { new_count }
}
```

This is actually **better UX** - it's how every performant list works anyway (virtualization).

### 5.3.5.2 Ring Buffer for History

```boon
HISTORY_SIZE: 100

-- Chat: keep last N messages in reactive state
-- Initial state is a record with messages array
messages: [items: [...], write_index: 0] |> HOLD state {
    new_message |> THEN {
        -- Ring buffer: overwrite at write_index, advance
        BLOCK {
            next_index: state.write_index
                |> Bits/add(BITS[8] { 10u1 })
                |> Bits/modulo(BITS[8] { 10u100 })

            [
                items: state.items |> List/set(index: state.write_index, value: msg),
                write_index: next_index
            ]
        }
    }
}

-- Full history persisted to IndexedDB, loaded on scroll-up
```

### 5.3.5.3 Slot Pool for Dynamic Counts

```boon
MAX_CART_ITEMS: 50

-- Shopping cart with fixed slots using Option pattern
-- Initial: 50 None slots
cart: [slot_0: None, slot_1: None, ...] |> HOLD state {
    add_item |> THEN {
        -- Find first None slot and fill it
        state |> find_empty_slot() |> WHILE {
            Some(index) => state |> set_slot(index: index, value: Some(item))
            None => state  -- Full! UI should show error
        }
    }
    remove_item |> THEN {
        state |> set_slot(index: item.slot_index, value: None)
    }
}

-- Actual count for display (count non-None slots)
cart_count: cart |> count_filled_slots()
```

Real shopping carts rarely exceed 50 items. 50 is generous.

### 5.3.5.4 Bounded Text with Explicit Limits

```boon
-- Form with clear limits (like Twitter's 280 chars)
-- TEXT[N] would be a new bounded string type
username: "" |> HOLD state {
    input_event |> THEN {
        input.value |> Text/length() |> Bits/less_equal(BITS[8] { 10u30 }) |> WHILE {
            True => input.value   -- Accept: 30 chars or less
            False => state        -- Reject: keep old value
        }
    }
}
```

Users understand limits when they're explicit (character counters, etc.).

### 5.3.5.5 Schema-Validated JSON

```boon
-- Define expected response shape with fixed limits
ApiResponse: [
    items: [item_0: None, item_1: None, ...],  -- Max 100 slots
    total: BITS[32] { 10u0 },
    next_cursor: None
]

-- Parser rejects responses that don't fit schema
response: fetch_result |> Json/parse_strict(schema: ApiResponse) |> WHILE {
    Ok(data) => data
    Err(e) => default_response  -- Or show error
}
```

If API returns 101 items, that's an API contract violation - fail loudly or truncate explicitly.

---

## 5.3.6 What Works Well with Fixed-Size

| Domain | Why It Works |
|--------|--------------|
| **Forms** | Natural limits (username: 30, email: 100, etc.) |
| **UI State** | Finite states (tabs, modals, views) |
| **Games** | Need fixed timing, object pools standard |
| **Real-time** | Predictable latency critical |
| **Embedded/IoT** | Limited memory anyway |
| **Financial** | TigerBeetle proves this |
| **FPGA targets** | Required for synthesis |

## 5.3.7 What Needs Escape Hatches

| Domain | Escape Hatch Solution |
|--------|----------------------|
| **Rich text editing** | Streaming/external buffer, fixed cursor state |
| **File handling** | Stream processing with fixed chunk size |
| **Large datasets** | Pagination/virtualization with fixed window |
| **Unknown JSON** | Reject or use lenient mode with truncation |
| **Deep recursion** | Require tail-call or bounded iteration |

---

## 5.3.8 Tiered Fixed-Size Proposal

### Tier 1: Core Reactive State (MUST be fixed)

```boon
-- This is the reactive dataflow graph
-- All sizes known at compile time
-- Maps directly to arena slots AND hardware

AppState: [
    todos: [t0: None, t1: None, ...t99: None],  -- 100 slots
    filter: Active,                              -- enum tag
    selected: None                               -- Option[TodoId]
]
```

### Tier 2: Bounded I/O (fixed buffers, streaming)

```boon
-- Network/file access through fixed windows
BUFFER_SIZE: 65536  -- 64KB

fetch_buffer: Bytes/empty(size: BUFFER_SIZE)
file_chunk: Bytes/empty(size: 4096)
```

### Tier 3: External Unbounded (outside Boon core)

```
-- IndexedDB, server DB, filesystem
-- Accessed via Tier 2 bounded windows
-- Not part of reactive state
```

---

## 5.3.9 What This Enables

1. **Same code, browser + FPGA**: Core logic synthesizes to hardware
2. **Predictable server scaling**: Know exactly memory per user
3. **No OOM in production**: Capacity is compile-time known
4. **Faster execution**: Arena allocation, no GC
5. **Easier debugging**: Deterministic memory layout
6. **Security**: Bounded resource usage

## 5.3.10 What You Give Up

1. **Unbounded convenience**: Must think about limits
2. **Some flexibility**: Can't handle truly arbitrary input
3. **Ecosystem friction**: Need adapters for dynamic web APIs

---

## 5.3.11 Open Questions

1. **Syntax for fixed-size types**: How to express `LIST[100, Todo]` cleanly?
2. **Error handling**: What happens when limits are exceeded? Compile error? Runtime error? Silent truncation?
3. **Migration path**: How to adopt gradually in existing codebases?
4. **Developer experience**: Good error messages, easy limit tuning
5. **Interop**: How to interface with dynamic JavaScript/JSON world?

---

## 5.3.12 Recommendation

**For Boon specifically**, fixed-size core makes strong sense because:

1. **FPGA target requires it anyway** - unifying browser/FPGA is valuable
2. **Arena-based engine already designed** - §2-3 support this
3. **Reactive dataflow is naturally bounded** - finite state machines
4. **Web app state is usually small** - UI state rarely needs >1000 items
5. **Pagination is standard UX** - users expect it for large lists

**The main challenge** is developer experience:
- Good error messages when limits exceeded
- Easy syntax for common patterns (ring buffer, slot pool)
- Clear documentation on choosing limits
- Config-based limits for easy tuning

**Decision**: Defer to after §2-5.2 are complete. Revisit when:
- Arena engine is stable (§2-3 done)
- FPGA transpiler works (§5.1 done)
- Real-world usage patterns are observed

This is a **language-level decision** that affects all users, so it deserves careful consideration after gaining experience with the current design.
