## Chapter 3.7: Hot-Reload Flexibility

This chapter documents how flexible Boon's hot-reload can be for common code changes **without** requiring explicit DRAIN migration.

**Key Principle**: The new engine uses **name-based matching** to preserve state across most code changes automatically.

**See also**: §3.2.0 Identity Systems Reconciliation - explains how name-based matching (for hot-reload) coexists with SourceId (for runtime identity/determinism).

---

### 3.7.1 Code Change Categories

#### SAFE Changes (State Preserved Automatically)

| Change | Why Safe | Example |
|--------|----------|---------|
| **Add Log/info to pipe** | Stateless pass-through | `x \|> Log/info() \|> HOLD state {...}` |
| **Add List/map to pipe** | Items preserve identity via AllocSite + ItemKey (§2.1) | `todos \|> List/map(item, new: styled(item))` |
| **Add List/filter/retain** | Items preserve identity | `todos \|> List/retain(item, if: item.done)` |
| **Add variable to BLOCK** | Name-based matching | Add `debug: Log/info()` to existing BLOCK |
| **Reorder BLOCK variables** | Matched by name, not position | Move `b:` before `a:` |
| **Reorder Object fields** | Name-based matching | `[a: 1, b: 2]` -> `[b: 2, a: 1]` |
| **Whitespace/comments** | Parser ignores | Any formatting changes |
| **Add WHEN/WHILE arm** | Pattern-based matching | Add new pattern case |
| **Change interval/timeout** | Stateless - new value applies | `Duration[seconds: 1] \|> Timer/interval()` -> `Duration[ms: 500]` |
| **Change config values** | No persistence on plain values | `[timeout: 1000]` -> `[timeout: 500]` |

#### UNSAFE Changes (Require Explicit Migration)

| Change | Why Unsafe | Solution |
|--------|------------|----------|
| **Rename variable** | Name is identity | DRAIN+DRAINING |
| **Rename HOLD state param** | `HOLD state` -> `HOLD counter` | DRAIN+DRAINING |
| **Move HOLD to different variable** | Parent context is identity | DRAIN+DRAINING |
| **Split variable into multiple** | Original name gone | Field-level DRAIN |
| **Merge multiple vars into one** | Which state wins? | DRAIN+DRAINING (user chooses) |
| **Type change** (Number->Text) | Stored state incompatible | Warning + DRAIN with conversion |
| **Remove HOLD from variable** | State orphaned | Warning (state GC'd) |

---

### 3.7.2 Matching Strategies

| Construct | Matching Strategy | Notes |
|-----------|-------------------|-------|
| Variables | Name-based | Adding siblings doesn't affect existing |
| BLOCK variables | Name-based | Order doesn't matter |
| Object fields | Name-based | Order doesn't matter |
| LIST items | Content-based + position tiebreaker | Duplicates allowed |
| LATEST inputs | Content-based + position tiebreaker | Duplicates allowed |
| HOLD | State param name within parent context | Parent path matters |
| Function args | Name-based | Order doesn't matter |
| WHEN/WHILE arms | Structural pattern matching | Exact AST match |
| BYTES data | Position-based | Binary data is position-sensitive |

#### Content-Based Matching Algorithm

For LIST and LATEST with duplicate content:

```rust
fn match_list_items(old_items: &[Item], new_items: &mut [Item]) {
    let mut used_old_indices = HashSet::new();

    for (new_idx, new_item) in new_items.iter_mut().enumerate() {
        // Find old item with same content, prefer same position
        let old_match = old_items
            .iter()
            .enumerate()
            .filter(|(i, _)| !used_old_indices.contains(i))
            .filter(|(_, old)| expressions_structurally_equal(&old.node, &new_item.node))
            .min_by_key(|(i, _)| (*i as isize - new_idx as isize).abs())
            .map(|(i, old)| (i, old));

        if let Some((old_idx, old_item)) = old_match {
            used_old_indices.insert(old_idx);
            new_item.persistence = old_item.persistence.clone();
        } else {
            new_item.persistence = Some(Persistence::new());
        }
    }
}
```

#### Expression Structural Equality

Helper function for content-based matching:

```rust
fn expressions_structurally_equal(a: &Expression, b: &Expression) -> bool {
    match (a, b) {
        (Expression::Variable { name: n1 }, Expression::Variable { name: n2 }) => n1 == n2,
        (Expression::Literal(l1), Expression::Literal(l2)) => l1 == l2,
        (Expression::FunctionCall { path: p1, args: a1 },
         Expression::FunctionCall { path: p2, args: a2 }) => {
            p1 == p2 && a1.len() == a2.len() &&
            a1.iter().zip(a2).all(|(x, y)|
                x.name == y.name &&
                expressions_structurally_equal(&x.value, &y.value)
            )
        }
        (Expression::FieldAccess { object: o1, field: f1 },
         Expression::FieldAccess { object: o2, field: f2 }) => {
            f1 == f2 && expressions_structurally_equal(o1, o2)
        }
        (Expression::Object { fields: f1 }, Expression::Object { fields: f2 }) => {
            f1.len() == f2.len() &&
            f1.iter().all(|(k, v1)|
                f2.get(k).map(|v2| expressions_structurally_equal(v1, v2)).unwrap_or(false)
            )
        }
        (Expression::TaggedObject { tag: t1, fields: f1 },
         Expression::TaggedObject { tag: t2, fields: f2 }) => {
            t1 == t2 && expressions_structurally_equal(
                &Expression::Object { fields: f1.clone() },
                &Expression::Object { fields: f2.clone() }
            )
        }
        // Add other expression variants as needed
        _ => false,
    }
}
```

---

### 3.7.3 Gotchas and Solutions

#### Gotcha 1: HOLD Initial Value Changes

**Problem**: Stored state always wins over code-defined initial value.

```boon
// User has counter = 42, developer changes initial to 100
counter: 100 |> HOLD state { state + 1 }
// Without fix: counter shows 42 (stored wins)
// With fix: counter shows 100 (initial changed, detected)
```

**Solution**: Parser compares old vs new initial expression. If changed, mark as `NewOrChanged` so evaluator uses new initial.

---

#### Gotcha 2: LIST/LATEST Position Shifts

**Problem**: Current engine uses position index for matching.

```boon
// Before: LIST { TodoA, TodoB }
// After:  LIST { NewTodo, TodoA, TodoB }
// Without fix: NewTodo gets TodoA's state!
```

**Solution**: Content-based matching with position tiebreaker (see algorithm above).

---

#### Gotcha 3: WHEN/WHILE Arms

**Problem**: Arm bodies are processed with empty old_expressions.

```boon
x |> WHEN {
    Active => 0 |> HOLD state { state + 1 }  // Gets new ID on every code change!
}
```

**Solution**: Match arms by structural pattern equality, then match bodies.

---

#### Gotcha 4: Function Arguments

**Problem**: Arguments matched by position, not name.

```boon
// Before: func(a: x, b: y)
// After:  func(new: z, a: x, b: y)
// Without fix: new gets a's state!
```

**Solution**: Match arguments by name, not position.

---

#### Gotcha 5: Type Changes

**Problem**: Stored Number but code expects Text.

```boon
// Stored: 42 (Number)
counter: "hello" |> HOLD state { TEXT { {state} world } }
```

**Solution**: Use new initial + show warning. User can use DRAIN with conversion to preserve value:

```boon
counter: 0 |> HOLD state {...} |> DRAINING
text_counter: DRAIN { counter } |> Number/to_text() |> HOLD state {...}
```

---

#### Gotcha 6: Stateful Functions Removed

**Problem**: Functions like Math/sum have internal state.

**Solution**: Track stateful functions by source location. Warn when removed.

| Function | State Type |
|----------|-----------|
| `Math/sum` | Accumulated sum |
| `Math/count` | Item count |
| `Math/avg` | Running average |
| `Stream/debounce` | Buffered value + timer |
| `Stream/throttle` | Timing state |
| `Stream/take` / `Stream/skip` | Count |
| `Stream/buffer` | Buffered items |

---

### 3.7.4 Edge Cases

#### HOLD Inside Reusable Functions

```boon
counter_factory: function() {
    0 |> HOLD state { state + 1 }
}

counter_a: counter_factory()
counter_b: counter_factory()
```

**Behavior**: Each call site gets **separate state** (like React hooks). Identity includes call site path.

---

#### Nested HOLD (Parent Moves)

```boon
outer: 0 |> HOLD outer_state {
    inner: 0 |> HOLD inner_state { inner_state + 1 }
    outer_state + inner
}
```

**Behavior**: Inner HOLD's identity depends on outer's path. Renaming outer affects both.

**Warning shown**: "Renaming 'outer' affects nested HOLDs. Use DRAIN to preserve inner state."

---

#### Cross-Module Renames

```boon
// module_a.bn
counter: 0 |> HOLD state {...}  // Exported

// module_b.bn
import module_a
display: TEXT { {module_a.counter} }
```

**If module_a renames counter**: module_b gets compilation error (breaking API change).

---

#### Duplicate Patterns in WHEN

```boon
value |> WHEN {
    True => handler_a()
    True => handler_b()  // Duplicate pattern!
}
```

**Behavior**: Structural pattern matching, first match wins. Second arm is unreachable code.

**Compiler warning**: "Unreachable pattern: 'True' at line X already matches above."

---

#### Same Content in Different LIST Literals

```boon
list_a: LIST { todo("Buy milk"), todo("Buy eggs") }
list_b: LIST { todo("Buy milk"), todo("Buy eggs") }  // Same content!
```

**Behavior**: Each LIST is separate. Content-based matching only applies WITHIN a single LIST when comparing old vs new versions. Different variables have different identity regardless of content.

---

#### Stateful Function Moved in Pipe

```boon
// Before
values |> Math/sum() |> display()

// After - Math/sum moved
values |> filter() |> Math/sum() |> display()
```

**Behavior**: Stateful functions tracked by source location. Moving changes identity, state would be lost.

**Better design option**: Track by variable path + function name (not source position). Then state survives reorganization within same variable.

---

#### HOLD Initial Change During Active State

```boon
// Code change while user has state = 42
counter: 0 |> HOLD state {...}
// Changed to:
counter: 100 |> HOLD state {...}
```

**Behavior** (with Gotcha 1 fix):
- Parser detects initial value changed (0 → 100)
- New initial (100) is used
- Old stored value (42) is discarded
- This is **intentional** - developer wants to reset

**If developer wants to KEEP existing state but change default for new users**:
- Not directly supported - initial value IS the default
- Workaround: Don't change initial, handle in body logic

---

### 3.7.5 Developer Decision Tree

```
Is the change to stateful code (HOLD, List with nested HOLD)?
├── No → SAFE (proceed)
└── Yes
    ├── Variable/function name unchanged?
    │   ├── Yes → Is HOLD state param unchanged?
    │   │   ├── Yes → SAFE
    │   │   └── No → Need DRAIN
    │   └── No → Need DRAIN
    └── Adding NEW HOLD to existing variable?
        └── SAFE (starts fresh)
```

---

### 3.7.6 Migration Guide Summary

| Change Type | User Action | What Happens |
|-------------|-------------|--------------|
| Add Log/map/filter to pipe | Just do it | State preserved |
| Add variables to BLOCK | Just do it | State preserved |
| Reorder BLOCK/Object | Just do it | State preserved |
| Change config values | Just do it | New values used |
| Insert into LIST/LATEST | Just do it | State preserved |
| Change HOLD initial | Just do it | New initial used |
| Add/reorder function args | Just do it | State preserved |
| Add WHEN/WHILE arm | Just do it | State preserved |
| **Change type** | Acknowledge warning | New initial used |
| **Rename variable** | Use DRAIN or acknowledge | Warning shown |
| **Remove HOLD** | Acknowledge | Warning shown, state GC'd |

---

### 3.7.7 Design Principles

**Principle 1: No Silent State Loss**
Every state-affecting change is either automatically handled or warned.

**Principle 2: Safe by Default**
Most code changes preserve state automatically via name-based and content-based matching.

**Principle 3: Explicit When Necessary**
Changes that can't be auto-handled show warnings with suggestions.

**Principle 4: Expected Resets Are Documented**
- localStorage clear -> All state reset
- New HOLD -> Starts fresh
- New variable -> Fresh start

**Key Guarantee**: User will NEVER be surprised by silent state loss.

---

### 3.7.8 Compiler Warning System

For state-affecting changes, compiler warns:

```
Hot-reload warning: Variable 'counter' renamed to 'click_count'
    State under 'counter' will be orphaned.

    Suggestion: Use DRAIN migration:
    counter: 0 |> HOLD state {...} |> DRAINING
    click_count: DRAIN { counter } |> HOLD state {...}
```

**Warnings generated for:**
1. Variables removed that had HOLD (orphaned state)
2. HOLD state param renamed
3. Stateful functions removed
4. Type changes in HOLD variables
5. Nested HOLDs affected by parent rename

---

### 3.7.9 Why Name-Based Over Structural Hash

The design doc (3.2) proposes structural hashing. Analysis shows name-based is better:

| Aspect | Name-Based | Structural Hash |
|--------|------------|-----------------|
| Config changes | Works (name unchanged) | Breaks (literal hashed) |
| Variable reorder | Works (matched by name) | Breaks (parent path changes) |
| Simplicity | Simple name lookup | Complex hash computation |
| Debugging | Names are readable | Hashes need tooling |

**Conclusion**: Keep name-based matching, add content-based for LIST/LATEST.

---

### 3.7.10 Implementation Priority

| Fix | Priority | Impact |
|-----|----------|--------|
| HOLD initial detection | High | Users expect initial changes to apply |
| LIST content-based | High | Prevents silent state scramble |
| LATEST content-based | High | Prevents silent state scramble |
| Function args name-based | High | Prevents silent state scramble |
| WHEN/WHILE pattern-based | High | Prevents silent state loss |
| Compiler warnings | Medium | User awareness |
| Diff tool visualization | Low | Nice-to-have |

---

